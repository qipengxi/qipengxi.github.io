<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="几乎所有的事情都具有多面性"><title>多线程浅析（一）--创建线程/线程安全（同步）/生命周期 | 向阳成长</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">多线程浅析（一）--创建线程/线程安全（同步）/生命周期</h1><a id="logo" href="/.">向阳成长</a><p class="description">个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">多线程浅析（一）--创建线程/线程安全（同步）/生命周期</h1><div class="post-meta"><a href="/2019/06/06/多线程浅析（一）/#comments" class="comment-count"></a><p><span class="date">Jun 06, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><p>在介绍多线程之前首先要明确两个很重要的概念：线程/进程。</p>
<h4 id="什么是进程和线程呢？"><a href="#什么是进程和线程呢？" class="headerlink" title="什么是进程和线程呢？"></a>什么是进程和线程呢？</h4><p>​    先来大概看一下看书上的定义：<strong>进程</strong>是处于运行过程中的程序，具有一定的独立功能，是系统进行资源分配和调度的一个独立功能。<strong>线程</strong>是进程的组成部分，在程序中是独立的、并发的执行流,是进程的执行单元。是否容易理解？其实可以理解为电脑上的扫雷游戏。而线程就是扫雷游戏上的那个计时器。</p>
<p><img src="/2019/06/06/多线程浅析（一）/扫雷.PNG" alt></p>
<p>​    归纳起来可以这样说：操作系统可以同时执行多个任务（QQ聊天、看电影、写博客等），每个任务其实就是进程；进程又可以同时执行多个任务（看电影的时候不仅仅能够观看电影还能够发弹幕），对应的每个任务就是线程。</p>
<h4 id="线程和进程的关系？"><a href="#线程和进程的关系？" class="headerlink" title="线程和进程的关系？"></a>线程和进程的关系？</h4><p>​    线程是进程的组成部分，一个进程可以有多个线程。一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器以及自己的局部变量，但是不拥有系统资源，他与父进程的其他线程共享改进成所拥有的全部资源。不过也就是因为这样，在进行多线程编程的时候要防止线程冲突。</p>
<h4 id="多线程编程优点"><a href="#多线程编程优点" class="headerlink" title="多线程编程优点"></a>多线程编程优点</h4><ul>
<li>进程之间不能共享内存，但是线程之间共享内存就很容易</li>
<li>系统创建进程的时候需要为该进程分配系统资源，但是创建线程代价就小的多，因此使用多线程实现多任务并发行要比多进程效率高</li>
<li>Java语言内置了多线程功能的支持，而不是单纯的作为底层操作系统的调度方式，从而简化了java的多线程编程。</li>
</ul>
<hr>
<h3 id="多线程的创建和启动"><a href="#多线程的创建和启动" class="headerlink" title="多线程的创建和启动"></a>多线程的创建和启动</h3><h4 id="（一）-继承Thread类创建线程"><a href="#（一）-继承Thread类创建线程" class="headerlink" title="（一）.继承Thread类创建线程"></a>（一）.继承Thread类创建线程</h4><ul>
<li>定义Thread的子类，并重写该类的run方法，该run方法的方法体就是线程所要完成的任务表，因此run()也叫做线程执行体</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"继承Thread类创建线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//定义带参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myThread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义无参构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">myThread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建Thread子类的实例，也就是创建线程对象</li>
<li>调用线程对象的start()方法开启动该线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无参构造方法创建线程（默认）</span></span><br><span class="line">        myThread1 mt=<span class="keyword">new</span> myThread1();</span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无参构造方法创建线程（设置线程名称）</span></span><br><span class="line">        myThread1 mt1=<span class="keyword">new</span> myThread1();</span><br><span class="line">        mt1.setName(<span class="string">"哈咯"</span>);</span><br><span class="line">        mt1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//带参构造方法创建线程</span></span><br><span class="line">        myThread1 mt2=<span class="keyword">new</span> myThread1(<span class="string">"宝贝"</span>);</span><br><span class="line">        mt2.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（二）-实现Runnable接口创建线程"><a href="#（二）-实现Runnable接口创建线程" class="headerlink" title="（二）.实现Runnable接口创建线程"></a>（二）.实现Runnable接口创建线程</h4><ul>
<li>定义Runnable接口的实现类，并重写run方法，该run()方法的方法题同样是该线程的线程执行体</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个Runnable接口的实现类对象</span></span><br><span class="line">        myThread2 myThread2=<span class="keyword">new</span> myThread2();</span><br><span class="line">        <span class="comment">//创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(myThread2);</span><br><span class="line">        <span class="comment">//调用Thread里面的start方法开启多线程</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（三）-二者创建线程的对比"><a href="#（三）-二者创建线程的对比" class="headerlink" title="（三）.二者创建线程的对比"></a>（三）.二者创建线程的对比</h4><p>​    <strong>采用实现Runnable接口的方式创建多线程的优缺点</strong></p>
<ul>
<li>线程只是实现了接口，还能够继承其他的类</li>
<li>多个线程可以共享同一个target对象，所以非常适合多个线程处理同一份资源的情况。</li>
<li>编程稍微复杂一些。如果需要访问当前线程，必须使用Thread.currentThread()方法。</li>
</ul>
<p>​    <strong>采用继承Thread类创建线程的优缺点</strong></p>
<ul>
<li>编写较为简单，如果要访问当前线程，无需使用Thread.currentThread()方法，只需使用this就可以获取当前线程</li>
<li>因为已经继承了Thread类，就无法再次继承其他类了。</li>
</ul>
<hr>
<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><p>​    当线程被创建并且启动之后，并非一启动就立刻进入了执行状态，也不会一直处于执行状态（除非线程执行体够短），在线程的生命周期中，一个线程要经过 <strong>新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、以及死亡（Dead）</strong>，尤其是线程在启动之后不会一直霸占CPU，因此线程状态也会多次在运行、就绪之间进行切换。</p>
<p><img src="/2019/06/06/多线程浅析（一）/线程生命周期.PNG" alt></p>
<h4 id="（一）-新建和就绪状态"><a href="#（一）-新建和就绪状态" class="headerlink" title="（一）. 新建和就绪状态"></a>（一）. 新建和就绪状态</h4><p>​    当程序使用了<code>new</code>关键字创建了一个线程之后，该线程就处于了<strong>新建状态</strong>，这个时候的线程对象就如同其他普通的java对象一样，仅仅由java虚拟机为其分配内存并初始化其成员变量的值。但是不会表现出来任何线程的动态特征，程序也不会执行线程的线程执行体。</p>
<p>​    当线程对象调用了start()方法之后，线程进入<strong>就绪状态</strong>，java虚拟机会为其创建方法调用栈和程序计数器，不过出于这个状态中的线程并没有开始运行，只是表明该线程可以运行了，拥有了运行资格。至于呵是运行，要取决于JVM的线程调度。</p>
<h4 id="（二）-运行和阻塞状态"><a href="#（二）-运行和阻塞状态" class="headerlink" title="（二）.运行和阻塞状态"></a>（二）.运行和阻塞状态</h4><p>​    如果处于<strong>新建状态</strong>的线程获取了CPU，开始执行run()方法的方法体，则该线程进入<strong>运行状态</strong>。</p>
<p>​    发生以下情况的时候线程会进入<strong>阻塞状态</strong>：</p>
<ul>
<li>线程调用sleep()方法主动放弃处理器所占用的处理器（CPU）资源</li>
<li>线程调用了阻塞式的IO方法，在该方法返回之前，该线程被阻塞。</li>
<li>线程试图获得一个同步监视器，但是该监视器正在被其他线程占用。</li>
<li>线程在等待某个通知（notify）</li>
<li>程序调用了线程的suspend()方法将该线程挂起。（该方法容易导致死锁，所以应该尽量避免）</li>
</ul>
<p>当线程进入阻塞状态之后，其他线程就会获得执行的机会。被阻塞的线程会在适当的时候重新进入<strong>就绪状态</strong>而非<strong>运行状态</strong>。</p>
<p>​    进入阻塞状态之后的线程发生如下特定情况的时候会<strong>解除阻塞状态</strong>：</p>
<ul>
<li>调用sleep()方法的线程已经过了指定时间</li>
<li>线程调用的阻塞式IO方法已经返回</li>
<li>线程成功取得同步监视器</li>
<li>其他线程发出了一个通知（notify）</li>
<li>处于挂起状态的线程调用了resume()方法</li>
</ul>
<h4 id="（三）-线程死亡"><a href="#（三）-线程死亡" class="headerlink" title="（三）.线程死亡"></a>（三）.线程死亡</h4><p>​    线程会以如下方式结束，并进入<strong>死亡状态</strong></p>
<ul>
<li>run()或call()方法执行完成，线程正常结束</li>
<li>线程抛出一个未捕获的Exception或Error</li>
<li>直接调用该线程的stop()方法来结束该线程—-容易导致死锁，不建议使用</li>
</ul>
<p>==注意：主线程结束的时候不会对其他线程造成影响。一旦子线程启动之后就会和主线程拥有相同的地位==</p>
<hr>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>​    说到线程同步就不得不先引入另外一个话题了：<strong>线程安全</strong>。</p>
<p>​    先来看一段代码，以便更好的理解线程安全这个问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线程任务：卖票。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;正在卖第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Runnable接口实现类</span></span><br><span class="line">        RunnableImpl ri=<span class="keyword">new</span> RunnableImpl();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line">        Thread t0=<span class="keyword">new</span> Thread(ri);</span><br><span class="line">        Thread t1=<span class="keyword">new</span> Thread(ri);</span><br><span class="line">        Thread t2=<span class="keyword">new</span> Thread(ri);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用start方法开启多线程</span></span><br><span class="line">        t0.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面程序部分结果如下：</p>
<p><img src="/2019/06/06/多线程浅析（一）/售票安全.PNG" alt></p>
<p>从运行结果可以看出，第100百张票被卖出多次，这显然不符合实际要求。这就是因为多个线程在公用同一份信息的时候由于线程调度不当导致的问题。</p>
<p>为了解决这类线程安全问题，java便引入了<strong>线程同步</strong>。通常用来解决线程安全问题可以通过以下三个方法来进行：</p>
<h4 id="（一）-同步代码块"><a href="#（一）-同步代码块" class="headerlink" title="（一）.同步代码块"></a>（一）.同步代码块</h4><p>​    语法格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    </span><br><span class="line">    可能会出现线程安全问题的代码（访问了共享数据的代码）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>锁对象：</strong>把同步代码块锁住，只让一个线程在同步代码块中执行</p>
<ul>
<li><p>1.锁对象可以是任意的对象，但是建议将可能被并发访问的共享资源当成锁对象（本例中是ticket对象）</p>
</li>
<li><p>2.但是必须保证多个线程使用的锁对象是同一个</p>
</li>
</ul>
<p>==注意：==</p>
<ul>
<li>任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程就会释放对该同步监视器的锁定。</li>
<li>synchronized关键字可以修饰<strong>方法、代码块</strong>，但是不能修饰<strong>构造器</strong>和<strong>成员变量</strong>等。</li>
</ul>
<p>先来看一下同步代码块的具体使用（将上述代码改成如下）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建锁对象（可以是任意对象）</span></span><br><span class="line">    Object obj=<span class="keyword">new</span> Object();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置线程任务：卖票。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;正在卖第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试之后，之前的线程问题不会再出现。这就代表同步代码块对线程安全问题起到了控制作用。</p>
<h4 id="（二）-同步方法"><a href="#（二）-同步方法" class="headerlink" title="（二）.同步方法"></a>（二）.同步方法</h4><p>​    和同步代码块相对应，同步方法是使用synchronized关键字来修饰某个方法<strong>静态和非静态</strong>，则该方法成为同步方法。</p>
<p>​    下面通过一段简单的代码来展示同步方法的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建所对象（可以是任意对象）</span></span><br><span class="line">    Object obj=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务：卖票。</span></span><br><span class="line">    <span class="comment">//不在run方法里直接实现卖票操作而是定义一个sellTicketStatic()函数更符合面向对象	   //的设计规则</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"this:"</span>+<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            sellTicketStatic();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态同步方法的锁对象是谁呢？</span></span><br><span class="line"><span class="comment">     *      this是创建对象之后产生的，静态方法优先于对象。</span></span><br><span class="line"><span class="comment">     *      静态方法的锁对象是本类的class属性--&gt;class文件对象（反射）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicketStatic</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//synchronized (RunnableImpl.class)&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;正在卖第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *    定义一个同步方法</span></span><br><span class="line"><span class="comment">     *   同步方法也会把方法内部的代码锁住</span></span><br><span class="line"><span class="comment">      *  只让一个线程执行</span></span><br><span class="line"><span class="comment">       * 同步方法的对象是谁？</span></span><br><span class="line"><span class="comment">        *    就是实现类对象，new RunnableImpl()</span></span><br><span class="line"><span class="comment">         *   也就是this</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//synchronized (this)&#123;</span></span><br><span class="line">            <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;正在卖第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                ticket--;</span><br><span class="line">            &#125;</span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    从上诉代码<strong>24,25行以及41,42行</strong>中可以看出来，==静态方法的锁对象是本类的class属性–&gt;class文件对象；非静态方法的锁对象就是实现类对象：new RunnableImpl()，也就是this。==</p>
<h4 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h4><p>​    任何线程在进入同步代码块或者同步方法之前必须先获得对同步监视器的锁定，既然获得了锁定，就肯定会有释放锁定的时间，那么什么时候会释放对同步监视器的锁定呢？程序无法显示释放对同步监视器的锁定，线程会在如下情况<strong>释放对同步监视器的锁定</strong></p>
<ul>
<li>当前线程在同步方法、同步代码块执行结束，当前线程就会释放锁定</li>
<li>当前线程在同步方法、同步代码块中遇到<strong>break  return</strong>终止了该代码块或者方法的执行</li>
<li>当前线程在同步方法、同步代码块中遇到未处理的<strong>Error或者Exception</strong>,导致该代码块或方法异常结束</li>
<li>当前线程在执行同步方法、同步代码块时候，程序执行了同步监视器对象的<strong>wait()方法</strong>，则当前线程暂停，并释放同步监视器</li>
</ul>
<p><strong>在下列情况发生的时候不会释放锁定</strong></p>
<ul>
<li>线程执行同步代码块或者同步方法的时候，程序调用了<strong>Thread.sleep()、Thread.yield()方法</strong>来暂停当前线程的执行，当前线程不会释放同步监视器的锁定</li>
<li>线程执行同步代码块或者同步方法的时候，其他线程调用了该线程的<strong>suspend()方法</strong>将线程挂起，当前线程不会释放当前同步监视器的锁定。</li>
</ul>
<h4 id="（三）-同步锁（Lock）"><a href="#（三）-同步锁（Lock）" class="headerlink" title="（三）.同步锁（Lock）"></a>（三）.同步锁（Lock）</h4><p>​    Lock锁是从java5开始出现的一种同步机制，它提供了比synchronized方法以及synchronized代码块更广泛的锁定操作。java为Lock提供了实现类：ReentrantLock（可重入锁）。</p>
<p>使用步骤：</p>
<ul>
<li>1.在成员位置创建一个Reentrantlock对象</li>
<li>2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</li>
<li>3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</li>
</ul>
<p>​    接下来用一段代码展示Lock锁的具体使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个多个线程共享的票源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.在成员为之创建一个Reentrantlock对象</span></span><br><span class="line">    Lock l=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程任务：卖票。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁</span></span><br><span class="line">            l.lock();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--&gt;正在卖第"</span>+ticket+<span class="string">"张票"</span>);</span><br><span class="line">                    ticket--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁</span></span><br><span class="line">                <span class="comment">//为了保证锁一定会被释放，将释放锁放在finally语句中</span></span><br><span class="line">                l.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lock本身是一个接口，无法进行实例化，只能通过其实现类来实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock l=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line">或者</span><br><span class="line">ReentrantLock l=<span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>
<p>为了确保锁一定会被释放，应该将<code>l.unlock();</code>放入到finally语句中</p>
</div><div class="post-copyright"><blockquote><p>原文作者: 小青年</p><p>原文链接: <a href="http://yoursite.com/2019/06/06/多线程浅析（一）/">http://yoursite.com/2019/06/06/多线程浅析（一）/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/06/08/Cookie出现500错误（无效字符）/" class="pre">Cookie 报错500无效字符</a><a href="/2019/06/02/final修饰符/" class="next">final修饰符浅析</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是进程和线程呢？"><span class="toc-text">什么是进程和线程呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程和进程的关系？"><span class="toc-text">线程和进程的关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程编程优点"><span class="toc-text">多线程编程优点</span></a></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程的创建和启动"><span class="toc-text">多线程的创建和启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）-继承Thread类创建线程"><span class="toc-text">（一）.继承Thread类创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）-实现Runnable接口创建线程"><span class="toc-text">（二）.实现Runnable接口创建线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）-二者创建线程的对比"><span class="toc-text">（三）.二者创建线程的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的生命周期"><span class="toc-text">线程的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）-新建和就绪状态"><span class="toc-text">（一）. 新建和就绪状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）-运行和阻塞状态"><span class="toc-text">（二）.运行和阻塞状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）-线程死亡"><span class="toc-text">（三）.线程死亡</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程同步"><span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（一）-同步代码块"><span class="toc-text">（一）.同步代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（二）-同步方法"><span class="toc-text">（二）.同步方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放同步监视器的锁定"><span class="toc-text">释放同步监视器的锁定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（三）-同步锁（Lock）"><span class="toc-text">（三）.同步锁（Lock）</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/MyBatis里的一些区别/">MyBatis里的一些区别</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/17/MyBatis03/">MyBatis03</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/16/MyBatis02/">MyBatis02--配置文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/14/MyBatis01/">MyBatis01知识小记--xml方式开发MyBatis</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/SpringMVC异常处理机制/">SpringMVC异常处理机制浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/04/SpringMVC学习4/">SpringMVC学习--文件上传</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/SpringMVC学习3/">SpringMVC学习03---请求和响应</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/03/SpringMVC学习2/">SpringMVC学习02--web.xml和spring-mvc.xml</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/Spring整合Web/">Spring整合Web</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/09/02/SpringMVC学习1/">SpringMVC知识小记01</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">小青年.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>