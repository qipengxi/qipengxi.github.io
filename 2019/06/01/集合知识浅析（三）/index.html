<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="几乎所有的事情都具有多面性"><title>集合知识浅析（三） | 向阳成长</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">集合知识浅析（三）</h1><a id="logo" href="/.">向阳成长</a><p class="description">个人博客</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">集合知识浅析（三）</h1><div class="post-meta"><a href="/2019/06/01/集合知识浅析（三）/#comments" class="comment-count"></a><p><span class="date">Jun 01, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h2 id="Map体系"><a href="#Map体系" class="headerlink" title="Map体系"></a>Map体系</h2><p>首先来一张<code>Map</code>体系图：</p>
<p><img src="/2019/06/01/集合知识浅析（三）/Map继承关系.PNG" alt></p>
<h2 id="1-1-Map"><a href="#1-1-Map" class="headerlink" title="1.1 Map"></a>1.1 Map</h2><p>​    <code>Map</code>用于保存具有映射关系的数据，因此Map集合里面保存着两组值：<strong>key 和 value</strong>，<code>key</code>  <code>value</code>可以是任何引用类型的数据，同时<strong><code>key</code>不允许重复，<code>value</code>可以重复</strong>。key和value之间存在<strong>单向</strong>一对一的关系，通过key总是能找到唯一的确定的value。</p>
<p>​    如果将Map集合中所有的key放在一起来看的话，这些key就相当于一个Set集合（<strong>所有的key无序且不可重复</strong>），在Map接口里面的确包含了一个<code>keySet()</code>方法,可以用来获取这个<code>key</code>组成的“集合”。</p>
<p>​    Map和Set之间的关系相当密切。虽然Map里面存储的是<em>键值对</em>，Set里面存放的是单个对象，但是由于Map集合键值对的映射关系是<strong>单向一对一</strong>，因此如果将<code>value</code>看成<code>key</code>的附属的话，那么这个Map就可以当成Set来看待。事实上，在Map中还真的有一个方法：<strong><code>entrySet()</code></strong>。这个方法可以用来将Map的每一个键值对封装在一起形成一个整体（Set）。</p>
<p>​    如果将Map集合中所有的value放在一起来看，这些value就相当于一个List集合：<strong>元素和元素之间可以重复，元素可以根据索引值来查找</strong>，只不过Map中查找value用的索引值是key值。</p>
<p>==强调：==Java源码就是先实现了Map的一系列集合，然后通过包装一个value都等于null的Map集合实      现了Set集合类。</p>
<p>Map接口中定义了如下常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span>:删除所有的键值对</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>:查询是否包含指定的键</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span>:查询是否包含指定的键</span></span><br><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span>:返回指定key所对应的的value。没有这个key就返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>:判断集合是否为空</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Set <span class="title">entrySet</span><span class="params">()</span>:返回Map集合中所有键值对所组成的Set集合，集合元素都是Map.Entry对象</span></span><br><span class="line"><span class="function">Set <span class="title">keySet</span><span class="params">()</span>:返回Map中所有key组成的Set集合</span></span><br><span class="line"><span class="function">Collection <span class="title">values</span><span class="params">()</span>:返回Map中所有value组成的Collection集合</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key,Object value)</span>:向集合中添加一个键值对，如果集合中已经有了相同的key，那么就会覆盖掉原本的键值对并返回被覆盖掉的value</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map m)</span>:将制定Map中的键值对添加到本Map中</span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span>:删除指定key对应的键值对，返回对应的value；如果key不存在，就返回<span class="keyword">null</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key,Object value)</span>:Java 8新增方法。成功删除返回<span class="keyword">true</span>,否则返回<span class="keyword">false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key,V oldValue,V new newValue)</span>:用新的value替换旧的value</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>:返回集合元素个数</span></span><br></pre></td></tr></table></figure>
<p>Map中包括了一个内部类Entry，这个类封装了一个键值对。Entry包含如下三个方法：、</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">getKey</span><span class="params">()</span>:返回该Entry里面包含的key</span></span><br><span class="line"><span class="function">Object <span class="title">getValue</span><span class="params">()</span>:返回该Entry里面包含的value</span></span><br><span class="line"><span class="function">Object <span class="title">setValue</span><span class="params">(V value)</span>:设置Entry里面包含的value值，并返回这个值</span></span><br></pre></td></tr></table></figure>
<p>Map系列都重写了toString()方法。</p>
<h2 id="1-2-HashMap-Hashtable"><a href="#1-2-HashMap-Hashtable" class="headerlink" title="1.2  HashMap / Hashtable"></a>1.2  HashMap / Hashtable</h2><p>​    <code>HashMap</code>和<code>Hashtable</code>都是Map接口的典型实现类，他们的关系完全类似于<code>ArrayList</code>和<code>Vector</code>的关系。</p>
<p><strong>HashMap和Hashtable的典型区别：</strong></p>
<ul>
<li><p>Hashtable是一个线程安全的Map实现类，而HashMap是县城不安全的实现。所以HashMap比HashTable的性能高一些。但是再多线程条件下，使用Hashtable会更安全。</p>
</li>
<li><p>Hashtable的key和value不能为null,否则抛出NullPointerException异常。但是HashMap的key和value可以为null</p>
<p>  ​    <strong>和HashSet一样的是HashMap / Hashtable不能保证其中的键值对的顺序，而且判断key相等的标准也是通过equals()方法比较返回true,两个key的hashCode相等。</strong></p>
<p>  <strong>为了能够在HashMap / Hashtable中进行存储、获取对象，用作key的对象所属的类必须实现hashCode()和equals()方法。同时两个方法的判断标准应该一致：当两个key通过equals方法返回true时候，两个key的hashCode的值也应该相等</strong>。</p>
</li>
</ul>
<h2 id="1-3-LinkedHashMap"><a href="#1-3-LinkedHashMap" class="headerlink" title="1.3  LinkedHashMap"></a>1.3  LinkedHashMap</h2><p>​    同HashSet有一个子类LinkedHashSet一样，HashMap也有一个LinkedHashMap子类。这个类可以保证键值对的顺序（添加顺序和取出顺序），在迭代访问Map集合的全部元素时有比较好的性能</p>
<h2 id="1-4-Properties"><a href="#1-4-Properties" class="headerlink" title="1.4  Properties"></a>1.4  Properties</h2><p>​    <code>Properties</code>时<code>Hashtable</code>的一个子类，相当于一个key和value都是String类型的Map集合。经常用于从外部文件进行读写操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span>:获取Properties中指定属性名对应的属性值</span></span><br><span class="line"><span class="function">String <span class="title">getProperty</span><span class="params">(String key,String defaultValue)</span>:与上一个方法基本相似，但是集合中没有key值的情况下会返回指定的默认值</span></span><br><span class="line"><span class="function">Object <span class="title">setProperty</span><span class="params">(String key,String value)</span>:设置属性</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream inStream)</span>:从属性文件中（以输入流的形式）加载键值对。把加载到的键值对追加到Properties里面。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(OutPutStream out,String comments)</span>:将Properties中的键值对输出到指定的属性文件中（输出流的表示形式）</span></span><br></pre></td></tr></table></figure>
<h2 id="1-5-SortedMap-TreeMap"><a href="#1-5-SortedMap-TreeMap" class="headerlink" title="1.5  SortedMap / TreeMap"></a>1.5  SortedMap / TreeMap</h2><p>​    <code>SortedMap</code>是Map的子接口，而<code>TreeMap</code>是SortedMap的实现类。<code>TreeMap</code>是一个红黑树的数据结构，每个键值对作为数的一个节点。TreeMap存储元素的时候会根据key值对节点进行排序。TreeMap可以保证所有的键值对处于排序状态，同样TreeMap也有两种排序方式：</p>
<ul>
<li>自然排序：TreeMap的key必须实现Comparable接口，而且所有的key必须是同一个类的对象，否则会抛出ClassCastException异常</li>
<li>定制排序：创建TreeMap的时候，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不要求Map的key实现Comparable接口。</li>
</ul>
<p>注意：</p>
<ul>
<li>TreeMap判断两个key是否相同的标准和TreeSet判断两个元素相等的标准（<strong>也是唯一标准</strong>）是一样的：两个key通过compareTo()方法返回0，就认为两个key相等。</li>
<li>如果使用自定义类作为key，那么自定义类需要重写equals()和compareTo()方法，且应该保持一致的返回结果。（和TreeSet一模一样）。</li>
</ul>
<p>TreeMap中根据key顺序访问键值对的(部分)方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Map.Entry first/lastEntry():返回Map里面最小/大key对应的键值对，如果Map为空就返回<span class="keyword">null</span></span><br><span class="line">Object first/lastKey():返回Map中最小/大的key值。Map为空就返回<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">Map.Entry higher/lowerEntry():返回指定key后面一个为对应的键值对，如果Map为空就返回<span class="keyword">null</span></span><br><span class="line">Object higher/lowerKey():返回指定key后面一位的key值。Map为空就返回<span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"><span class="function">SortedMap <span class="title">subMap</span><span class="params">(Object fromKey,Object toKey)</span>:截取，不包括右</span></span><br><span class="line"><span class="function">SortedMap <span class="title">tailMap</span><span class="params">(Object fromKey)</span>:返回该Map的子Map,key的范围是大于fromKey的所有key</span></span><br><span class="line"><span class="function">SortedMap <span class="title">headMap</span><span class="params">(Object toKey)</span>:和上面一样，key的范围是小于toKey的所有key</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">NevigableMap <span class="title">subMap</span><span class="params">(Object fromKey,<span class="keyword">boolean</span> from,Object toKey,<span class="keyword">boolean</span> to)</span>:截取，是否包含取决于具体参数</span></span><br><span class="line"><span class="function">NevigableMap <span class="title">tailMap</span><span class="params">(Object fromKey,<span class="keyword">boolean</span> from)</span>:返回该Map的子Map,是否包含取决于第二个参数</span></span><br><span class="line"><span class="function">NevigableMap <span class="title">headMap</span><span class="params">(Object toKey,<span class="keyword">boolean</span> inclusive)</span>:是否包括取决于第二个参数</span></span><br></pre></td></tr></table></figure>
<h2 id="1-6-IndetityHashMap"><a href="#1-6-IndetityHashMap" class="headerlink" title="1.6  IndetityHashMap"></a>1.6  IndetityHashMap</h2><p>​    这个Map的实现机制和HashMap很相似，但是它在处理两个相等的key不一样。</p>
<p>​    在IdentityHashMap中，当且仅当两个key严格相等（key1==key2）的时候,IdentityHashMap才认为两个key相等。而对于普通的HashMap来说，只要key1和key2通过equals()方法返回true，并且他们的hashCode值相等即可。允许使用Null作为key和value。</p>
<h2 id="1-7-WeakHashMap"><a href="#1-7-WeakHashMap" class="headerlink" title="1.7  WeakHashMap"></a>1.7  WeakHashMap</h2><p>​    与HashMap用法基本相似。只不过HashMap的key保留了对实际对象的<strong>强引用</strong>，这意味着只要HashMap的对象不被销毁，那么该HashMap的所有key所引用的对象就不会被垃圾回收机制回收，HashMap也不会自动删除这些key所对应的的键值对；而WeakHashMap的key只保留了对实际对象的<strong>弱引用</strong>，当垃圾回收机制回收了key所对应的的实际对象之后，WeakHashMap就会自动删除该key所对应的的键值对。</p>
<h2 id="1-8-EnumMap"><a href="#1-8-EnumMap" class="headerlink" title="1.8 EnumMap"></a>1.8 EnumMap</h2><ul>
<li>EnumMap在内部以数组的形式保存，因此这种实现形式相当高效</li>
<li>根据key的自然排序（枚举值在枚举类中定义的顺序）来维护键值对的顺序</li>
<li>不允许使用null作为key。</li>
<li>创建EnumMap的时候必须指定一个枚举类吗，从而将该EnumMap集合和枚举类关联起来</li>
</ul>
<hr>
<hr>
<h2 id="各个Map实现类的性能分析："><a href="#各个Map实现类的性能分析：" class="headerlink" title="各个Map实现类的性能分析："></a>各个Map实现类的性能分析：</h2><ul>
<li>对于Map常用的实现类而言，HshMap和Hashtable几乎一样，但是Hashtable是一个古老的、线程安全的实现类，因此性能不如HashMap。</li>
<li>TreeMap通常比HashMap / Hashtable要慢，特别是在插入和删除键值对的时候更慢。因为TreeMap底层采用红黑树来管理键值对。但是TreeMap有一个好处：键值对总是处于有序状态，不需要专门进行排序操作。想要获取TreeMap的元素，只需要调用keySet()，得到key组成的Set集合，然后使用toArray()方法来转换成数组，接下来使用Arrays的binarySearch()方法在已排序的数组中进行快速的查询既可。</li>
<li>对于一般的应用场景，应当多考虑使用HashMap,但是程序要求一个总是排序好的Map的时候就应该使用TreeMap.</li>
<li>LinkedHashMap比HashMap要慢一些，因为需要维护两边保持键值对的添加顺序。</li>
<li>IdentityHashMap没有出色之处，只不过使用的是“==”来判断元素是否相等</li>
<li>EnumMap的性能最好，但是只能使用同一个枚举类的枚举值作为key。</li>
</ul>
</div><div class="post-copyright"><blockquote><p>原文作者: 小青年</p><p>原文链接: <a href="http://yoursite.com/2019/06/01/集合知识浅析（三）/">http://yoursite.com/2019/06/01/集合知识浅析（三）/</a></p><p>版权声明: 转载请注明出处(必须保留作者署名及链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/06/02/final修饰符/" class="pre">final修饰符浅析</a><a href="/2019/05/31/集合知识浅析（二）/" class="next">集合知识浅析（二）</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Map体系"><span class="toc-text">Map体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Map"><span class="toc-text">1.1 Map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-HashMap-Hashtable"><span class="toc-text">1.2  HashMap / Hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-LinkedHashMap"><span class="toc-text">1.3  LinkedHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Properties"><span class="toc-text">1.4  Properties</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-SortedMap-TreeMap"><span class="toc-text">1.5  SortedMap / TreeMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-IndetityHashMap"><span class="toc-text">1.6  IndetityHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-WeakHashMap"><span class="toc-text">1.7  WeakHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-EnumMap"><span class="toc-text">1.8 EnumMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各个Map实现类的性能分析："><span class="toc-text">各个Map实现类的性能分析：</span></a></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/02/mysql2/">mysql知识浅析2</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/30/mysql1/">MySql知识浅析1</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/复制多级文件夹/">复制多级文件夹</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/20/IO流/">IO流--字节流</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/20/文件/">File</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/20/递归和文件/">递归和文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/17/正则表达式浅析/">正则表达式</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/13/集合知识浅析（四）并发修改异常/">并发修改异常</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/10/内部类/">内部类浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/09/多线程浅析（二）/">多线程浅析（二）--线程通信</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">小青年.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script></body></html>