{"meta":{"title":"向阳成长","subtitle":"个人博客","description":"几乎所有的事情都具有多面性","author":"小青年","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"String , String Builder , String Buffer的区别浅析","slug":"String , String Builder , String Buffer的区别","date":"2019-05-29T13:14:53.886Z","updated":"2019-05-29T13:15:57.198Z","comments":true,"path":"2019/05/29/String , String Builder , String Buffer的区别/","link":"","permalink":"http://yoursite.com/2019/05/29/String , String Builder , String Buffer的区别/","excerpt":"","text":"String , String Builder , String Buffer的区别首先来看这三个类分别代表什么什么意思​ String类代表字符串 ，但是它是代表一个常量，它的值在创建之后不能够被更改。 ​ StringBuilder与StringBuffer虽然也是代表字符串，但他们都是变量，他们在创建对象实例并且赋值之后可以重新更改值得内容。 ​ 这三者的区别主要存在与两点：运行速度和线程安全 运行速度:​ 三者的运行速度大小如下：StringBuilder &gt; StringBuffer &gt; String ​ 原因： ​ 先来看一段代码: 1234String s=&quot;Hello&quot;;System.out.println(s);s=s+&quot;World&quot;System.out.println(s); ​ 上述代码输出的结果是Hello 和HelloWorld,这段代码在虚拟机上的执行过程实际是这样的：首先，在创建了一个对象s之后，将Hello赋值给了s，然后又创建了一个同名对象s，并且将之前的s对象的值和World进行拼接之后赋值给了这个新的s。那么第一次创建的对象s去哪了呢？答案是被虚拟机的垃圾回收机制回收掉了（连同对象s 的值）。因此，在对String类型的对象进行操作的时候实际上就是一个不断创建同名新对象回收老对象的一个过程，这期间需要不断的消耗虚拟机的资源，因此执行速度很慢。 ​ 但是StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 线程安全:​ StringBuilder是线程不安全的，StringBuffer是线程安全的 总结： String：适用于少量的字符串操作的情况 String Builder：适用于单线程下在字符缓冲区进行大量操作的情况 String Buffer：适用多线程下在字符缓冲区进行大量操作的情况 String常用构造方法： 123456public String()：空构造public String(byte[] bytes)：把字节数组转换成字符串public String(byte[] bytes,int offset,int length)：把字节数组一部分转换成字符串public String(char[] value)：把字节数组转换成字符串public String(byte[] bytes,int offset,int count)：把字符数组一部分转换成字符串public String(String original)：把字符串常量值转成字符串,换句话说新创建的字符串是参数字符串的副本。 常用函数： 123456789101112131415161718192021222324252627282930313233343536String类的获取功能 int length();获取长度 char charAt(int index);返回指定索引位置的字符 int indexOf(int ch);返回指定字符在此字符串第一次出现的索引 int indexOf(String_01 str);返回指定字符串（首字母）在此字符串第一次出现的索引 int indexOf(int ch,int fromIndex);返回指定字符在此字符串从指定位置之后第一次出现的索引 String substring(int start);截取字符串，默认到末尾。返回被截取的子串。 String substring(int start,int end); String类的转换功能 byte[] getBytes();把字符串转换成字节数组 char[] toCharArray();把字符串转换成字符数组 static String valueOf(char[] chs);把字符数组转换成字串，其他类型数组用不了此方法 static String valueOf(int i);把某种类型数据转换成字符串(四类八种除了byte/short,外加) String类的valueOf方法可以把任意类型的数据转换成字符串 toCharArray():可以将字符串转化成数组 String toLoweCase(); String toUpperCase(); String concat(String str):进行字符串的拼接 toCharArray(): 将此字符串转换为新的字符数组。 String类的其他功能 替换功能 String replace(char old,char new); String replace(String old,String new); String replaceFirst(String regex, String replacement)用给定的序列替换调用者的第一个子 字符串 去除字符串两端空格 String trim(); 按照字典顺序比较字符串 int compareTo(String str); int compareToIgnoreCse(String str); 判断功能： boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开头。 boolean startsWith(String prefix, int toffset) 测试在指定索引处开始的此字符串的子字符串 是否以指定的前缀开头。 拆封功能 String[] split(String regex)：根据给定的表达式拆分此字符串 注意：1.String s=new String(&quot;hello&quot;);String s=&quot;hello&quot;区别： ​ 前者创建两个对象（常量池中没有这个hello对象的时候）或一个对象（常量池中有这个hello对象的时候），后者创建一个对象（常量池中没有这个hello对象的时候）或不创建对象（常量池中有这个hello对象的时候） 2.字符串如果是变量相加，先开空间，在拼接。 12String s1=&quot;Hello&quot;,s2=&quot;World&quot;;s1+s2 3.字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1&quot;Hello&quot;+&quot;World&quot; String Builder和String Buffer常用构造方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 1234StringBuilder() 构造一个没有字符的字符串构建器，初始容量为16个字符。 StringBuilder(int capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。 StringBuilder(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。 StringBuilder(String str) 构造一个初始化为指定字符串内容的字符串构建器。 常用方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 1234567891011121314StringBuilder append(参数) 将指定参数的字符串表示附加到序列中。除了byte/short StringBuilder append(char[] str) 将 char数组参数的字符串表示追加到此序列。 StringBuilder append(char[] str, int offset, int len) 将 char数组参数的子阵列的字符串表示追加到此序列。 StringBuilder append(String str) 将指定的字符串附加到此字符序列。 StringBuilder append(StringBuffer sb) 追加指定的 StringBuffer到这个序列。 int capacity() 返回当前容量。 char charAt(int index) 返回指定索引位置的值void setCharAt(int index, char ch) 设置指定位置的值为ch StringBuilder reverse() 导致该字符序列被序列的相反代替。StringBuilder replace(int start, int end, String str) 用指定的 String的字符替换此序列的子字符串中的字符 int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 int indexOf(String str, int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串的最后一次出现的字符串中的索引，从指定索引开始向后搜索。","categories":[],"tags":[],"keywords":[]},{"title":"接口的知识浅析","slug":"接口的知识浅析","date":"2019-05-26T15:58:29.816Z","updated":"2019-05-28T16:11:42.154Z","comments":true,"path":"2019/05/26/接口的知识浅析/","link":"","permalink":"http://yoursite.com/2019/05/26/接口的知识浅析/","excerpt":"","text":"接口什么是接口？​ 接口是多个类的一种公共规范，它是一种引用数据类型。接口中最重要的内容是接口中的抽象方法。 接口如何定义？格式：​ 1public interface 接口名称&#123;...&#125; 如何使用接口呢？1.接口不能直接使用，必须有一个“实现类”来实现接口格式： 1public class 实现类名称 implements 接口名称1,接口名称2...&#123;...&#125; 2.接口的实现类必须重写接口中的所有抽象方法3.创建实现类的对象，进行使用如果是Java 7,那么接口中可以包含的内容有：常量/抽象方法 如果是Java 8,还可以额外包含：默认方法/静态方法 如果是Java 9,还可以额外包含：私有方法 接口中的抽象方法（最重要的）格式： 1public abstract 返回值类型 方法名称(参数列表) 注意： ​ public abstract这两个关键字修饰符是固定格式，但是可以选择性的省略 接口中的default（默认）方法格式： 1public default 返回值类型 方法名称(参数列表)&#123;...&#125; 这个默认方法有什么用？​ 作用：默认方法会被实现类自动继承，因此可以用于接口升级。 什么叫做接口升级？​ 比如有一个接口A，并且B,C实现该接口，但是如果接口A中进行了抽象方法的修改，那么相应的就要去修改B,C 但是现实开发中这种并无法理想实现（比如实现了A接口的某个方法已经投入了大规模使用），因此这个时候进行接口的升级操作就需要用到这个默认的方法。 ​ 高级吗？一点都不高级。就是只需要把需要接口中新增的方法声明称默认方法就可以了。😂 接口中的静态方法（Java 8开始）格式： 1public static 返回值类型 方法名称(参数列表)&#123;...&#125; 接口中静态方法的使用​ 通过接口名称直接调用： 1接口名称.静态方法名(参数) ​ 注意： ​ 不能通过接口实现类的对象去调用接口中的静态方法 ​ 例如： 1234567891011121314public interface A&#123; public static void test()&#123; System.out.println(&quot;你好&quot;); &#125;&#125;public class B extends A&#123; public static void main(String[] args)&#123; A.test();//正确 new B().test();//错误 &#125;&#125; 接口中的私有方法（Java 9开始）1.普通私有方法​ 作用：解决多个默认方法之间重复代码问题 ​ 格式： 1private 返回值类型 方法名称(参数列表)&#123;...&#125; 2.静态私有方法​ 作用：解决多个静态方法之间重复代码问题 ​ 格式： 1private static 返回值类型 方法名称(参数列表)&#123;...&#125; 私有方法有啥用啊？来看一段代码(以普通私有方法为例)： 12345public interface A&#123; public default void methodDefault1&#123;...&#125; public default void methodDefault2&#123;...&#125;&#125; 假设methodDefault1方法和methodDefault2方法中有大量重复的代码的话,可以将这部分重复代码抽离出来形成一个新的方法。但是！抽离出来的这部分方法应当只能由methodDefault1和methodDefault2来使用，而不能由实现类来使用 将公共代码抽离出来，这样一来，便无法在实现类中访问到methodCommon(),如下： 12345678910111213public interface A&#123; public default void methodDefault1&#123; ... methodCommon(); &#125; public default void methodDefault2&#123; ... methodCommon(); &#125; private void methodCommon()&#123; 公共方法 &#125;&#125; 接口中的常量​ 接口中也可以定义”成员变量”，但是必修使用 public static final 三个关键字修饰。从效果上看，相当于接口的常量。这三个关键之可以省略，但是即使省略之后，也默认还是这三个修饰。而且必须赋值。 格式： 1public static final 数据类型 常量名称 = 数据值 如何访问呢？ ​ 这样理解：修饰符里面由static关键字，那么自然只能通过接口名进行访问：接口名.常量名 接口使用注意事项​ 1.接口内没有静态代码块或者构造方法（有了构造方法就可以直接new了） ​ 2.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要重写一次就行，而且必须重写。 ​ 3.如果实现类没有完全重写接口的抽象方法，那么实现类同样是一个抽象类 ​ 4.接口与接口之间是多继承的（类和类之间单继承，类和接口之间多实现） ​ 5.多个父接口当中的抽象方法重复没事，但是默认方法重复的话，那么子接口必须进行默认方法的重写并且要带有default关键字","categories":[],"tags":[],"keywords":[]}]}