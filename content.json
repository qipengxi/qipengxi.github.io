{"meta":{"title":"向阳成长","subtitle":"个人博客","description":"几乎所有的事情都具有多面性","author":"小青年","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"","slug":"集合知识浅析（二）","date":"2019-05-31T09:03:27.458Z","updated":"2019-06-01T00:27:33.415Z","comments":true,"path":"2019/05/31/集合知识浅析（二）/","link":"","permalink":"http://yoursite.com/2019/05/31/集合知识浅析（二）/","excerpt":"","text":"集合知识浅析（二）—-Collection从集合知识浅析（一）可以知道在JAVA中集合体系主要可以分成两大类：Collection和Map。 #####今天先介绍Collection的体系知识。 ##1.1 Collection ​ Collection是单列集合的根接口，提供了所有单列集合的共性方法。在这个接口下有两个很重要的子接口：java.util.List和java.util.Set。 ​ 其中List中元素有序，可重复，有索引因此可以使用普通的for循环进行遍历，Set中的元素无序，不可重复，没有索引因此不能够使用普通for循环进行遍历，那Collection当中提供了和索引相关的方法吗？答案是否定的。 注意：由于Collection List Set是接口，因此不能进行实例化,只能使用期实现类来进行实现。 Collection常用方法 1234567891011boolean add(Object o):添加元素boolean addAll(Collection c):将集c里面的元素全部添加进指定集合void clear():清空集合boolean contains(Object o):返回集合里面是否包含指定元素boolean isEmpty():判断集合是否为空Iterator iterator():返回一个迭代器，用于遍历集合内容boolean remove():删除指定元素（删除第一个）boolean removeAll():删除指定元素（全部）boolean retain():从集合中删除集合c里面不包含的元素int size():返回集合里面元素的个数Object[] toArray():把集合转换成一个数组，所有的集合元素会变成相应的数组元素 ​ 在传统的模式下，当把一个对象放到集合里面之后，集合就会将该对象的类型当成Object类型。如果要进行集合元素的其他一些操作的话需要进行向下转型操作。但是在JDK 1.5之后，可以使用来泛型进行改进。 1.2 Set​ Set和Collection没有多大的差别。只不过在Set中不允许有重复的元素。在Collection中定义的方法，在Set中都可以使用。 1.2.1 HashSet​ HashSet是Set的典型实现类，HashSet按照Hash算法进行集合元素的存储，因此在存取和查找方面具有很好的性能。 特点： 1234* HashSet不保证元素的排列顺序，也就是说取出来的顺序和放进去的顺序有可能不一致* HashSet不是同步的，也即是线程不安全。* 元素可以为NULL* 底层是Hash表 为什么HashSet中不允许有重复元素呢？ ​ 这主要依赖于两个方法：hashCode和equals。 在介绍具体原理之前，先介绍一些相关其他知识： ​ 哈希值：是一个十进制的整数，由系统随机给出（也就是对象的地址值，是一个逻辑地址而非实际存储的物理地址），在Object类中可以使用hashCode返回对象的哈希值。 ​ HashSet集合存储数据的结构(哈希表): ​ 哈希表： ​ 在JDK 1.8之前，哈希表底层采用 数组+链表 来实现。即使用链表处理冲突，具有相同Hash值的对象都存储在一个链表里面。但是当相同哈希值的元素很多的时候进行查找的效率就很低，因此在JDK1.8开始，哈希表采用了 数组+链表+红黑树 实现。当链表长度超过阈值（8）的时候，就会将链表转换成红黑树，从来减少了查找时间，提高效率。 下面来看一段代码： 12345678HashSet&lt;String&gt; set=new HashSet&lt;&gt;();String s1=new String(\"abc\");String s2=new String(\"abc\");set.add(s1);set.add(s2);set.add(\"通话\");set.add(\"重地\");set.add(\"abc\"); Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法来判断元素是否相同。 set.add(s1): add方法会调用s1的hashCode方法，计算字符串”abc”的哈希值得出结果为96354，在集合中查找有没有这个哈希值的元素，没有有的话就把s1存入集合中 set.add(s2): add方法会调用s2的hashCode方法，计算字符串”abc”的哈希值为96354，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较s2.equals(s1),返回true。两个元素的哈希值相同，而且equals方法返回true，可以认定两个元素相同。就不会把s2存储到集合中。 set.add(&quot;通话&quot;)： add方法会调用hashCode方法，计算字符串“重地”的哈希值为1179395，在集合中没有找到相同哈希值的元素，就会将这个元素添加到集合中 set.add(&quot;重地&quot;): add方法会调用 “通话” 的hashCode方法，计算字符串”abc”的哈希值为1179395，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较&quot;通话&quot;.equals(&quot;重地&quot;),返回false。两个元素的哈希值相同，equals方法返回false，可以认定两个元素不相同。就会把s2存储到集合中。 1.2.2 LinkedHashSet​ LinkedHashSet是HashSet的一个子类，不过他与HashSet不同的是，LinkedHashSet底层多了一个链表，这样能够保证LinkedHashSet的元素是有序的 1.2.3 TreeSet​ TreeSet是SortedSet接口的实现类,正如名字所示TreeSet可以确保集合元素处于排序状态。和HashSet相比,还额外提供了如下方法： 12345678Comparator comparator():如果TreeSet采用了定制排序，那么该方法会返回定制排序所使用的Comoparator， 如果采用的是自然排序就返回nullObject first():返回集合中的第一个元素Object last():返回集合中的最后一个元素Object lower(Object e):返回集合中位于指定元素之前的元素Object higher(Object e):返回集合中位于指定元素之后的元素SortedSet subSet(Object fromElement,Object toElement):返回此Set的子集合，包左不包右SortedSet headSet(Object toElement):返回此Set子集，由小于toElement的元素组成SortedSet tailSet(Object fromElement):返回此Set子集，由大于等于toElement的元素组成 ​ TreeSet支持的的排序分为两种：自然排序（默认情况）/定制排序 自然排序：​ TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小，然后将集合元素按照升序排列，这种方式就是自然排序。 ​ 如果试图想TreeSet集合添加一个对象，在自然排序条件下该对象所属的类必须实现Comparable接口，否则程序会出现运行时期异常：ClassCastException。并且由于大部分类在实现compareTo(Object obj)方法的时候，都需要将被比较对象obj抢之类型转换成相同类型（因为只有相同类的两个实例才会比较大小），这也就要求了TreeSet集合里面的对象都属于一个类。 实现了Comparable接口的常用类： 1BigDecimal、BigInteger / Character / Boolean / String /Date、Time ​ 注意： * 和HashSet判断对象是否相同不一样的是TreeSet判断两个对象是否相同的**唯一标准**就是通过调用该对象的`compareTo(Object obj)`方法和容器中的其他对象比较大小，如果返回值是 **0** ，那么TreeSet就会认为他们相等，否则就认为他们不相等。 * HashSet根据哈希值来找到元素在集合中的存储位置，TreeSet则是根据红黑树的结构来确定元素在集合中的位置。 * 虽然往TreeSet集合中添加自定义对象的时候可以添加多种类型的对象（自定义类必须实现Comparable接口并且实现compareTo方法没有进行强制类型转换），但是当试图取出集合元素的时候，不同类型的元素依然会发生`ClassCastExcepion`异常。**所以！如果希望TreeSet能够正常运行，TreeSet只能添加同一种类型的对象。** * 当需要把一个对象放入TreeSet集合中的时候，重写该对象对应类的equals方法时候应该保证该方法与`compareTo(Object obj)`有一样的结果。规则如下：如果两个对象通过equals方法比较返回true时，这两个对象通过`compareTo(Object obj)`方法比较应该返回 0 。因为如果`compareTo(Object obj)`返回0，TreeSet就不会让元素进入集合内（因为compareTo(Object obj)的返回结果是作为TreeSet元素是否相等的唯一标准），但是equals方法返回false时候代表两个元素不相等，结果TreeSet和Set规则冲突。 #####定制排序： ​ TreeSet的自然排序是根据集合元素的大小进行升序排序。如果需要实现定制排序（比如降序排序），则需要通过Comparator接口。这个接口里面包含了一个int compare(T t1,T t2)方法。根据返回值和0的关系来判断大小。 1.2.4 EnumSet​ EnumSet是一个专门为枚举设计的类，其中的元素必须是指定枚举类型的枚举值。该枚举类型在创建EnumSet的时候现实或者隐含的指定。也是有序的，不允许空值，否则会抛出NullPointerException异常。 ​ EnumSet没有暴露任何构造器来创建该类的实例，也就是说无法像其他集合一样new一个对象出来。但是它提供了如下方法来创建EnumSet对象： 1234567EnumSet allOf(Class elementType):创建一个包含指定枚举类里面所有枚举值的EnumSet集合EnumSet copyOf(Collection c):使用普通集合来创建EnumSet集合EnumSet copyOf(EnumSet e)EnumSet noneOf(Class elementType):使用指定元素类型来新建一个空的EnumSet集合EnumSet of(E first，E...rest):创建一个包含一个或多个枚举值得EnumSet集合。传入的枚举值必须属于同一个值EnumSet range(E from,E to):创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合EnumSet complementOf(EnumSet s):创建一个其元素类型与指定EnumSet里元素类型相同的集合，新的集合包含原来那个集合不包含的，此枚举类剩下的枚举值 ##1.3 各个Set实现类的性能分析 HashSet和TreeSet是Set的两个典型实现。那么在应用中应该如何选择呢？ * 记住一句话：只有需要一个保持排序的Set集合的时候再选择T`reeSet`,否则就选择`HashSet`。此外HashSet有一个子类：`LinkedHashSet`,对于普通的插入删除操作，性能要比HashSet稍微差一些，但是由于有了链表的存在，使得`LinkedHashSet`在遍历方面会更快。 * `EnumSet`是所有Set实现类中性能最好的，但是它只能保存同一个枚举类的枚举值作为集合元素。 * `HashSet` `TreeSet` `EnumSet` 都是**线程不安全的**，如果有多个线程同时访问Set集合并且超过一个线程对Set集合进行了修改，那么必须使用`Collections`工具类的`synchronizedSortedSet`方法来包装Set集合,代码如下： 1SortedSet s=Collections.synchronizedSortedSet(new TreeSet(...));","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"集合知识浅析（一）","date":"2019-05-30T09:17:17.601Z","updated":"2019-05-30T16:22:41.500Z","comments":true,"path":"2019/05/30/集合知识浅析（一）/","link":"","permalink":"http://yoursite.com/2019/05/30/集合知识浅析（一）/","excerpt":"","text":"集合知识浅析（一）1.1集合概述 Java是面向对象的语言，面向对象语言对事物的描述是通过对象体现的，为了方便对多个对象 进行操作，就必须把这个对象进行存储，但是想要存储多个对象，就不能是一个基本数据类型 而应该是一个容器类型。 为什么不选择数组或者字符缓冲区来存储多个对象呢？ ​ 数组和StringBuffer就是容器，但是StringBuffer的结果是一个字符串，不一定能够满足要求。 因此只能选择数组作为容器，即对象数组，但是对象数组无法适应变化的需求，因为数组长度固定。因此Java提供了相应的集合类用来使用 数组和集合的区别: 1）数组长度固定，集合长度可变； 2）数组用来存储同一类型数据，集合可以存储不同类型 3）数组可以用来存储基本数据类型，也可以用来存储引用类型集合只能存 储引用类型 集合可以存储多个元素的，但是，存储多个元素也是有不同需求的，比如说，多个元素中不能有相同 元素，针对不同的需求，Java提供了不同的集合类，多个集合类的数据结构不同，但是绝对有共性。通过不断提取共性，就可以得到所有集合类的一个总集合：Collection 数据结构:数据的存储方式 1.2继承关系Java的集合类主要由Collection和Map两个接口派生出来。也即： Map的继承关系： Collection的继承关系：","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"泛型浅析","date":"2019-05-30T02:37:42.560Z","updated":"2019-05-31T06:48:41.403Z","comments":true,"path":"2019/05/30/泛型浅析/","link":"","permalink":"http://yoursite.com/2019/05/30/泛型浅析/","excerpt":"","text":"##泛型 首先来看一下什么叫做泛型​ 泛型是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊类型。也叫做参数化类型，把类型当作参数一样传递。 ​ 其实说白了，可以将泛型看成对集合里面元素的一种限制手段 ​ 简而言之就是使用集合那种结构的时候会出现黄色警告线，但是往往我们会忽略这样的警告，进而导致类型不匹配等不可预知的错误。但是采用泛型的话会在创建对象或者调用方法的时候如果出现参数类型不匹配的结果会直接报错，而不是仅仅给出警告。 格式： 12&lt;数据类型&gt; 此处的数据类型只能是引用类型。 使用位置： 1看API文档，如果类，接口，抽象类后面跟有&lt;E&gt;就说明要使用泛型。一般来说就是在集合中使用(如果集合不使用泛型的话，默认就是Object类型，可以存储任意类型的数据。 泛型应用： 泛型类： 把泛型定义在类上 格式：public class 类名&lt;泛型类型1....&gt; 注意：泛型类型必须是引用类型 举例： public class Test&lt;E&gt;{ private E name; public void setName(E name){ this.name=name; } } 泛型方法： 把泛型定义在方法上 格式：public &lt;泛型类型&gt; 返回类型 方法名(泛型类型) 举例： public &lt;E&gt; void method(E e){ ... } 泛型接口： 把泛型定义在接口上 格式：public interface 接口名&lt;泛型类型1....&gt; 举例： public interface myInterface&lt;E&gt;{} 注意：泛型是没有继承概念的 泛型通配符​ 当使用泛型类或者接口的时候，在传递的数据中如果泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符之后，只能使用Object类中的共性方法，集合中元素自身的方法无法使用。不能创建对象使用，只能作为方法的参数使用 高级使用 —-受限泛型​ 设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以设置一个上限或者下限。 ###### 泛型的上限： ​ 格式：类型名称&lt;? extends 类&gt; 对象名称 ​ 意义：之能接受该类型以及其子类 ​ 举例：public static void getElement(Collection&lt;? extends XXX&gt; coll){} 反省的下限​ 格式：类型名称&lt;? super 类&gt; 对象名称 ​ 意义：之能接受该类型以及其父类 ​ 举例：public static void getElement(Collection&lt;? super XXX&gt; coll){}","categories":[],"tags":[],"keywords":[]},{"title":"String , String Builder , String Buffer的区别浅析","slug":"String , String Builder , String Buffer的区别","date":"2019-05-29T13:14:53.886Z","updated":"2019-05-29T13:55:03.993Z","comments":true,"path":"2019/05/29/String , String Builder , String Buffer的区别/","link":"","permalink":"http://yoursite.com/2019/05/29/String , String Builder , String Buffer的区别/","excerpt":"","text":"String , String Builder , String Buffer的区别首先来看这三个类分别代表什么什么意思​ String类代表字符串 ，但是它是代表一个常量，底层是一个被final修饰的数组，它的值在创建之后不能够被更改。 ​ StringBuilder（字符串缓冲区）与StringBuffer（字符串缓冲区）虽然也是代表字符串并且底层也是数组，但是这个数组没有被final修饰，他们都是可变量，他们在创建对象实例并且赋值之后可以重新更改值得内容。 ​ 这三者的区别主要存在与两点：运行速度和线程安全 运行速度:​ 三者的运行速度大小如下：StringBuilder &gt; StringBuffer &gt; String ​ 原因： ​ 先来看一段代码: 123456String s=&quot;Hello&quot;;System.out.println(s);//HelloSystem.out.println(s.getBytes());//[B@3f99bd52s=s+&quot;World&quot;；System.out.println(s);//HelloWorldSystem.out.println(s.getBytes());//[B@119d7047 ​ 上述代码输出的结果是Hello [B@3f99bd52 和HelloWorld [B@119d7047,这段代码在虚拟机上的执行过程实际是这样的：首先，在创建了一个对象s之后，将Hello赋值给了s，然后又创建了一个同名对象s，并且将之前的s对象的值和World进行拼接之后赋值给了这个新的s。那么第一次创建的对象s去哪了呢？答案是被虚拟机的垃圾回收机制回收掉了（连同对象s 的值）。因此，在对String类型的对象进行操作的时候实际上就是一个不断创建同名新对象的删除旧对象的一个过程，这期间需要不断的消耗虚拟机的资源，因此执行速度很慢。 ​ 但是StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 线程安全:​ StringBuilder是线程不安全的，StringBuffer是线程安全的 总结： String：适用于少量的字符串操作的情况 String Builder：适用于单线程下在字符缓冲区进行大量操作的情况 String Buffer：适用多线程下在字符缓冲区进行大量操作的情况 StringBuilder/StringBuilder - - &gt; String ​ 可以使用StringBuilder的构造方法：StringBuilder(String str) String - - &gt;StringBuilder/StringBuilder ​ 可以使用StringBuilder的toString方法 String常用构造方法： 123456public String()：空构造public String(byte[] bytes)：把字节数组转换成字符串public String(byte[] bytes,int offset,int length)：把字节数组一部分转换成字符串public String(char[] value)：把字节数组转换成字符串public String(byte[] bytes,int offset,int count)：把字符数组一部分转换成字符串public String(String original)：把字符串常量值转成字符串,换句话说新创建的字符串是参数字符串的副本。 常用函数： 123456789101112131415161718192021222324252627282930313233343536String类的获取功能 int length();获取长度 char charAt(int index);返回指定索引位置的字符 int indexOf(int ch);返回指定字符在此字符串第一次出现的索引 int indexOf(String_01 str);返回指定字符串（首字母）在此字符串第一次出现的索引 int indexOf(int ch,int fromIndex);返回指定字符在此字符串从指定位置之后第一次出现的索引 String substring(int start);截取字符串，默认到末尾。返回被截取的子串。 String substring(int start,int end); String类的转换功能 byte[] getBytes();把字符串转换成字节数组 char[] toCharArray();把字符串转换成字符数组 static String valueOf(char[] chs);把字符数组转换成字串，其他类型数组用不了此方法 static String valueOf(int i);把某种类型数据转换成字符串(四类八种除了byte/short,外加) String类的valueOf方法可以把任意类型的数据转换成字符串 toCharArray():可以将字符串转化成数组 String toLoweCase(); String toUpperCase(); String concat(String str):进行字符串的拼接 toCharArray(): 将此字符串转换为新的字符数组。 String类的其他功能 替换功能 String replace(char old,char new); String replace(String old,String new); String replaceFirst(String regex, String replacement)用给定的序列替换调用者的第一个子 字符串 去除字符串两端空格 String trim(); 按照字典顺序比较字符串 int compareTo(String str); int compareToIgnoreCse(String str); 判断功能： boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开头。 boolean startsWith(String prefix, int toffset) 测试在指定索引处开始的此字符串的子字符串 是否以指定的前缀开头。 拆封功能 String[] split(String regex)：根据给定的表达式拆分此字符串 注意：1.String s=new String(&quot;hello&quot;);String s=&quot;hello&quot;区别： ​ 前者创建两个对象（常量池中没有这个hello对象的时候）或一个对象（常量池中有这个hello对象的时候），后者创建一个对象（常量池中没有这个hello对象的时候）或不创建对象（常量池中有这个hello对象的时候） 2.字符串如果是变量相加，先开空间，在拼接。 12String s1=&quot;Hello&quot;,s2=&quot;World&quot;;s1+s2 3.字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1&quot;Hello&quot;+&quot;World&quot; String Builder和String Buffer常用构造方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 1234StringBuilder() 构造一个没有字符的字符串构建器，初始容量为16个字符。 StringBuilder(int capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。 StringBuilder(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。 StringBuilder(String str) 构造一个初始化为指定字符串内容的字符串构建器。 常用方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 123456789101112131415StringBuilder append(参数) 将指定参数的字符串表示附加到序列中。除了byte/short StringBuilder append(char[] str) 将 char数组参数的字符串表示追加到此序列。 StringBuilder append(char[] str, int offset, int len) 将 char数组参数的子阵列的字符串表示追加到此序列。 StringBuilder append(String str) 将指定的字符串附加到此字符序列。 StringBuilder append(StringBuffer sb) 追加指定的 StringBuffer到这个序列。 int capacity() 返回当前容量。 char charAt(int index) 返回指定索引位置的值void setCharAt(int index, char ch) 设置指定位置的值为ch StringBuilder reverse() 导致该字符序列被序列的相反代替。StringBuilder replace(int start, int end, String str) 用指定的 String的字符替换此序列的子字符串中的字符 int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 int indexOf(String str, int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串的最后一次出现的字符串中的索引，从指定索引开始向后搜索。 String toString() 返回表示此顺序中的数据的字符串。","categories":[],"tags":[],"keywords":[]},{"title":"接口的知识浅析","slug":"接口的知识浅析","date":"2019-05-26T15:58:29.816Z","updated":"2019-05-28T16:11:42.154Z","comments":true,"path":"2019/05/26/接口的知识浅析/","link":"","permalink":"http://yoursite.com/2019/05/26/接口的知识浅析/","excerpt":"","text":"接口什么是接口？​ 接口是多个类的一种公共规范，它是一种引用数据类型。接口中最重要的内容是接口中的抽象方法。 接口如何定义？格式：​ 1public interface 接口名称&#123;...&#125; 如何使用接口呢？1.接口不能直接使用，必须有一个“实现类”来实现接口格式： 1public class 实现类名称 implements 接口名称1,接口名称2...&#123;...&#125; 2.接口的实现类必须重写接口中的所有抽象方法3.创建实现类的对象，进行使用如果是Java 7,那么接口中可以包含的内容有：常量/抽象方法 如果是Java 8,还可以额外包含：默认方法/静态方法 如果是Java 9,还可以额外包含：私有方法 接口中的抽象方法（最重要的）格式： 1public abstract 返回值类型 方法名称(参数列表) 注意： ​ public abstract这两个关键字修饰符是固定格式，但是可以选择性的省略 接口中的default（默认）方法格式： 1public default 返回值类型 方法名称(参数列表)&#123;...&#125; 这个默认方法有什么用？​ 作用：默认方法会被实现类自动继承，因此可以用于接口升级。 什么叫做接口升级？​ 比如有一个接口A，并且B,C实现该接口，但是如果接口A中进行了抽象方法的修改，那么相应的就要去修改B,C 但是现实开发中这种并无法理想实现（比如实现了A接口的某个方法已经投入了大规模使用），因此这个时候进行接口的升级操作就需要用到这个默认的方法。 ​ 高级吗？一点都不高级。就是只需要把需要接口中新增的方法声明称默认方法就可以了。😂 接口中的静态方法（Java 8开始）格式： 1public static 返回值类型 方法名称(参数列表)&#123;...&#125; 接口中静态方法的使用​ 通过接口名称直接调用： 1接口名称.静态方法名(参数) ​ 注意： ​ 不能通过接口实现类的对象去调用接口中的静态方法 ​ 例如： 1234567891011121314public interface A&#123; public static void test()&#123; System.out.println(&quot;你好&quot;); &#125;&#125;public class B extends A&#123; public static void main(String[] args)&#123; A.test();//正确 new B().test();//错误 &#125;&#125; 接口中的私有方法（Java 9开始）1.普通私有方法​ 作用：解决多个默认方法之间重复代码问题 ​ 格式： 1private 返回值类型 方法名称(参数列表)&#123;...&#125; 2.静态私有方法​ 作用：解决多个静态方法之间重复代码问题 ​ 格式： 1private static 返回值类型 方法名称(参数列表)&#123;...&#125; 私有方法有啥用啊？来看一段代码(以普通私有方法为例)： 12345public interface A&#123; public default void methodDefault1&#123;...&#125; public default void methodDefault2&#123;...&#125;&#125; 假设methodDefault1方法和methodDefault2方法中有大量重复的代码的话,可以将这部分重复代码抽离出来形成一个新的方法。但是！抽离出来的这部分方法应当只能由methodDefault1和methodDefault2来使用，而不能由实现类来使用 将公共代码抽离出来，这样一来，便无法在实现类中访问到methodCommon(),如下： 12345678910111213public interface A&#123; public default void methodDefault1&#123; ... methodCommon(); &#125; public default void methodDefault2&#123; ... methodCommon(); &#125; private void methodCommon()&#123; 公共方法 &#125;&#125; 接口中的常量​ 接口中也可以定义”成员变量”，但是必修使用 public static final 三个关键字修饰。从效果上看，相当于接口的常量。这三个关键之可以省略，但是即使省略之后，也默认还是这三个修饰。而且必须赋值。 格式： 1public static final 数据类型 常量名称 = 数据值 如何访问呢？ ​ 这样理解：修饰符里面由static关键字，那么自然只能通过接口名进行访问：接口名.常量名 接口使用注意事项​ 1.接口内没有静态代码块或者构造方法（有了构造方法就可以直接new了） ​ 2.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要重写一次就行，而且必须重写。 ​ 3.如果实现类没有完全重写接口的抽象方法，那么实现类同样是一个抽象类 ​ 4.接口与接口之间是多继承的（类和类之间单继承，类和接口之间多实现） ​ 5.多个父接口当中的抽象方法重复没事，但是默认方法重复的话，那么子接口必须进行默认方法的重写并且要带有default关键字","categories":[],"tags":[],"keywords":[]}]}