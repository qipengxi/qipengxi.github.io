{"meta":{"title":"向阳成长","subtitle":"个人博客","description":"几乎所有的事情都具有多面性","author":"小青年","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Spring常见设计模式浅析---单例设计模式","slug":"Spring单例模式","date":"2019-08-30T07:05:53.940Z","updated":"2019-08-30T12:25:28.100Z","comments":true,"path":"2019/08/30/Spring单例模式/","link":"","permalink":"http://yoursite.com/2019/08/30/Spring单例模式/","excerpt":"","text":"什么是单例设计模式单例设计模式是属于创建型的一种常用软件设计模式，通过单例模式创建的类在当前进程中只有一个 实例，是设计模式中最简单的形式之一。 为什么要有单例设计模式对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID(序号)生成器。如在Windows中就只能打开一个任务管理器。如果不使用机制对窗口对象进行唯一化，将弹出多个窗口，如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此有时确保系统中某个对象的唯一性即一个类只能有一个实例非常重要。 如何实现单例设计模式如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。 因此，要实现一个单例模式必须要满足三个要点： 将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象，以禁止他人创建实例 在该类内部产生一个唯一的实例化对象，并且将其封装为private static类型，以确保加载该类时，单例就会自动被创建（变量属于类，且不能被直接访问到） 定义一个静态方法返回这个唯一对象，确保外部能通过这个唯一接口访问到实例。 ==饿汉式：==饿汉式在类创建的时候，对象就被创建。 12345678910111213public class Singleton&#123; //在该类内部产生一个唯一的实例化对象 private static Singleton singleton = new Singleton(); //将构造方法私有化 private Singleton() &#123;&#125; //定义一个静态方法返回这个唯一对象 public static Singleton newInstance()&#123; return singleton; &#125;&#125; ==懒汉式：==饿汉模式就是需要用到对象的时候，对象才被创建出来（Spring中getBean()的时候用到了该模式） 12345678910111213141516public class Singleton&#123; //在该类内部产生一个唯一的实例化对象 private static Singleton singleton; //将构造方法私有化 private Singleton() &#123;&#125; //定义一个静态方法返回这个唯一对象 public static Singleton newInstance()&#123; if(singleton == null)&#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Spring常见设计模式浅析--工厂模式","slug":"Spring工厂模式","date":"2019-08-29T12:02:22.223Z","updated":"2019-08-30T07:09:41.357Z","comments":true,"path":"2019/08/29/Spring工厂模式/","link":"","permalink":"http://yoursite.com/2019/08/29/Spring工厂模式/","excerpt":"","text":"工厂模式又可以具体分成简单工厂模式（静态工厂方法（StaticFactory Method）模式）和工厂方法模式 1. 简单工厂模式简单工厂模式并不属于23中设计模式中的一种。属于类的创新型模式，也被叫做静态工厂方法模式，主要是通过专门定义一个类来负责创建其他类的实例，这些被创建的实例都拥有相同的父类 23中设计模式： 创建型 工厂方法模式（FactoryMethod）、抽象工厂模式（AbstractFactory）、 建造者模式（Builder）、原型模式（Prototype）、单例模式(Singleton) 结构型 适配器模式(Adapter)、桥接模式（Bridge）、组合模式（Composite）、 装饰器模式（Decorator）、门面模式（Facade）、享元模式（Flyweight）、 代理模式（Proxy） 行为型 解释器模式（Interpreter）、模板方法模式（TemplateMethod）、 责任链模式（ChainofResponsibility）、命令模式（Command）、 迭代器模式（Iterator）、调解者模式（Mediator）、备忘录模式（Memento）、 观察者模式（Observer）、状态模式（State）、策略模式（Strategy）、 访问者模式（Visitor） 1.1 简单工厂模式的一些概念 工厂角色：这是简单工厂模式的核心，有其负责创建所有类的内部逻辑 抽象产品角色：简单工厂模式所创建的所有类的父类，这里的父类即可以是接口，也可以是抽象类，负责描述所有实例所共有的公共接口。 具体产品角色：简单工厂所创建的具体实例对象。 1.2 深入理解简单工厂模式解决的问题是如何去实例化一个合适的对象。他的核心思想就是要有一个专门的类来负责创建实例这一个过程。如果简单工厂模式所设计的具体产品之间没有共同的逻辑的话，那么就可以使用接口来扮演抽象产品这一角色，但是如果具体产品之间有功能逻辑上的关联，那么就需要将这些相同的部分提取出来形成一个抽象类，然后让产品继承这个类。（这是为了实现更好的复用性）。举个容易理解的小例子：比如说我要去餐厅吃饭，肯定要先告诉服务员点餐，然后服务员告诉厨房，厨房生产出来饭菜。在这个小例子中，我就是客户端，我只负责告诉你我要什么东西，其他的不管；服务员就是抽象产品角色，负责接收我要什么东西，但是服务员又不会做饭，因此服务员会让厨房的人烧饭；厨师就是具体产品角色，负责将我要的食物创建出来。再来举个小例子，比如我点了三个菜，一个只放盐，一个只放糖，另外一个只放酱油，那，这三样菜直接没有具体的关系，因此可以将每样菜都当成一个接口。如果三样菜都放了糖，那么厨师不可能做不一样的菜去不同的地方找糖，肯定会把糖放在一个碗里面，这个碗就是抽象类。 1.3 代码展示 新建食物的接口（抽象产品角色） 123public interface Food&#123; public void makeFood();&#125; 新建具体的食物，鱼香肉丝，肉末茄子。。（具体产品角色） 1234567891011public class 鱼香肉丝 implements Food&#123; public void makeFood()&#123; System.out.println(\"鱼香肉丝做好了\"); &#125;&#125;public class 肉末茄子 implements Food&#123; public void makeFood()&#123; System.out.println(\"肉末茄子做好了\"); &#125;&#125; 建立具体的厨房来加工食物（工厂角色） 12345678910public class FoodFactory&#123; public static Food getFood(食物的类型)&#123; if(鱼香肉丝)&#123; return new 鱼香肉丝; &#125; if(肉末茄子)&#123; return new 肉末茄子; &#125; &#125;&#125; 建立客户端实现测试（顾客） 12345678910111213141516public class simpleFactory&#123; public static void main(String[] args)&#123; //实例化各种食物,类似于询问服务员有没有菜品 Food fishPork=FookFactory.getFood(\"鱼香肉丝\"); Food PorkEggplant=FookFactory.getFood(\"肉末茄子\"); //获取食物,有实物就点菜 if(fishPork!=null)&#123; 鱼香肉丝.makeFood(); &#125; if(PorkEggplant!=null)&#123; 肉末茄子.makeFood(); &#125; &#125;&#125; 1.3 简单工厂的优缺点 优点： 工厂类，也即工厂角色是整个模式的关键所在，包含有必要的逻辑判断可以根据外接给定的信息来决定应该创建那个具体的类。用户在使用的时候可以直接根据工厂来创建所需要的实例，而不需要关系这些对象到底是怎么创建出来的（顾客只管点菜，不管做菜）。有利于整个体系结构的优化 缺点： 工厂类集中了所有实例的创建逻辑，这就导致了一旦这个工厂出现了问题，所有使用该工厂创建对象的客户端都会受到牵连（类似于将所有鸡蛋装在了一个篮子里，篮子掉地上了，鸡蛋全都碎掉）。 由于简单工厂类的所有具体产品都是基于同一个共同的抽象类或者接口，这样一来，如果产品的种类增加（食物工厂不仅造食物，还造汽车），就需要增加不同的抽象类或者接口并且工厂还需要判断需要创建哪种种类的产品（食物还是汽车），这就和创建同种种类产品的不同具体产品（是食物里面的鱼香肉丝还是肉末茄子）产生了冲突违背了单一职责。（单一职责原则（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定一个类应该只有一个发生变化的原因）。并且最重要的是，简单工厂模式丧失了灵活性和可维护性（每增加一个具体的产品，都需要修改具体产品角色和工厂角色）。违背了开放封闭原则，（开放封闭原则（OCP，Open Closed Principle）是所有面向对象原则的核心，也就是对扩展开放对修改封闭。软件设计本身所追求的目标就是封装变化、降低耦合，而开放封闭原则正是对这一目标的最直接体现。） 简单工厂模式由于使用了静态工厂方法，因此无法被继承、重写。造成工厂角色无法形成基于继承的等级结构 1.4 简单工厂模式的实际应用 Spring 中的 BeanFactory 就是简单工厂模式的体现，根据传入一个唯一的标识来获得 Bean 对象，但 是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。（singleton就是传参之前创建，加载bean到容器的时候就创建了；protetype是传参之后创建，也就是getBean()这个方法的时候创建） JDBC操作数据库，当使用java语言操作数据库的时候不需要关心JDBC是如何去实现不同数据库之前的操作实现的，只需要：注册并加载驱动（Class.forName()），创建数据库连接对象Connection，创建SQL语句，提交SQL语句进行查询即可。JDBC如何来实现具体数据库的操作？那和客户端无关。 2 工厂方法模式2.1 工厂方法模式的一些概念 抽象工厂角色：具体工厂的父类 具体工厂角色：抽线工厂的子类，被外界调用生产产品，描述具体的生产功能（比如生产糖果等） 抽象产品角色：具体产品的父类，用来描述具体产品的公共接口 具体产品角色：描述生产的具体产品 2.2 深入理解工厂方法模式，又称工厂模式、多态工厂模式和虚拟构造器模式，通过定义工厂父类负责定义创建对象的公共接口，而子类则负责生成具体的对象，是对简单工厂模式的升级。工厂方法模式将类的实例化（具体产品的创建）延迟到工厂类的子类（具体工厂）中完成，也就是说有工厂类的子类决定到底应该实例化哪一个类。也就是说此时工厂类不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样一来，在有新产品需要增加的时候就不需要修改工厂类逻辑而只是添加新的工厂子类，符合了开放封闭原则。 2.3 代码展示 创建抽象工厂类，定义具体工厂的公共接口 123abstract class Factory&#123; public abstract Product Manufacture();&#125; 创建抽象产品类，定义具体产品的公共接口 123abstract class Product&#123; public abstract void Show();&#125; 创建具体产品类（继承抽象产品类）， 定义生产的具体产品； 12345678910111213class ProductA extends Product&#123; @Override public void Show() &#123; System.out.println(\"生产出了产品A\"); &#125;&#125;class ProductB extends Product&#123; @Override public void Show() &#123; System.out.println(\"生产出了产品B\"); &#125;&#125; 创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法 12345678910111213class FactoryA extends Factory&#123; @Override public void Manufacture() &#123; return new ProductA(); &#125;&#125;class FactoryB extends Factory&#123; @Override public void Manufacture() &#123; return new ProductB(); &#125;&#125; 测试 12345678910public class FactoryPattern &#123; public static void main(String[] args)&#123; FactoryA factoryA=new FactoryA(); factoryA.Manufacture().Show(); FactoryB factoryB=new FactoryB(); factoryB.Manufacture().Show(); &#125;&#125; 2.4 代码理解可能有人认为以上代码如果需要产品C的话，那么不还是要修改代码嘛？没错，但是这里的修改代码就是扩展、增加方法，只需要继承工厂接口就可以了，而不需要对工厂进行什么修改。也就是说每增加一种产品，只要增加相应的具体产品类和相应的工厂子类就行了 2.5 优缺点优点： 更符合开闭原则：对修改关闭，对扩展开放。每增加一种产品，只要增加相应的具体产品类和相应的工厂子类就行了；而简单工厂模式需要秀爱工厂类的逻辑判断 符合单一职责原则：每个具体的工厂类只负责一种产品的创建生产；但是简单工厂模式依旧需要进行逻辑判断来决定生产哪种产品 没有静态工厂方法，可以形成基于继承的等级结构，增加了多态性的体现。 缺点： 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销 一个具体工厂只能创建一种具体产品，功能简化过头，太单一了！ 2.6 应用场景 当一个类不知道它所需要的对象的类时 在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。","categories":[],"tags":[],"keywords":[]},{"title":"Spring-AOP小记","slug":"Spring学习3","date":"2019-08-29T00:18:53.828Z","updated":"2019-08-29T06:49:54.762Z","comments":true,"path":"2019/08/29/Spring学习3/","link":"","permalink":"http://yoursite.com/2019/08/29/Spring学习3/","excerpt":"","text":"1.Spring 的 AOP 简介1.1 什么是 AOPAOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 1.2 AOP 的作用及其优势作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护 1.3 AOP 的底层实现实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。 Spring 框架会监控切入点方法（被增强方法）的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 1.4 AOP 的动态代理技术常用的动态代理技术 JDK 代理 : 基于接口的动态代理技术 cglib 代理：基于父类的动态代理技术 .png) 1.5 JDK 的动态代理 首先jdk代理是基于接口的动态代理，那么肯定要有个接口啊 1234public interface TargetInterface &#123; //目标方法 public void method();&#125; 动态代理代理的是啥？代理的是目标类的对象，那么首先就要有个目标类呀 1234567public class Target implements TargetInterface &#123; //目标方法 @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; 动态代理代码 1234567891011121314Target target = new Target(); //创建目标对象//创建代理对象TargetInterface proxy = (TargetInterface) Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"前置增强代码...\"); Object invoke = method.invoke(target, args); System.out.println(\"后置增强代码...\"); return invoke; &#125; &#125;); 调用代理对象的方法测试 1System.out.println(proxy.method()); .png) ==注意：== 如果目标类有返回值的话，return invoke就会返回响应的返回值，否则返回null； 代理对象调用任何目标方法都会触发执行public Object invoke(Object proxy, Method method, Object[] args) ，这个方法的invoke里面的invoke函数不一样，里面的invoke是Method所对应的方法，这个method封装的就是目标方法，args是目标方法的参数，target是目标对象（注意不是代理对象） 1.6 cglib 的动态代理 同样要有个目标类 12345public class Target &#123; public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; 动态代理代码 1234567891011121314Target target = new Target(); //创建目标对象Enhancer enhancer = new Enhancer(); //创建增强器enhancer.setSuperclass(Target.class); //设置父类，这一步也就是说要为谁增强enhancer.setCallback(new MethodInterceptor() &#123; //设置回调 @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"前置代码增强....\"); Object invoke = method.invoke(target, objects); System.out.println(\"后置代码增强....\"); return invoke; &#125;&#125;);Target proxy = (Target) enhancer.create(); //创建代理对象 测试 12//测试,当调用接口的任何方法时，代理对象的代码都无序修改proxy.method(); 1.7 AOP 相关概念Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 AOP相关术语： Target（目标对象）：代理的目标对象 Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点。就是类里面的方法 Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。就是类里面要被增强的方法。一个类里面有很多方法，这些方法都可以叫Joinpoint，但是只有需要被增强的方法才被叫做Pointcut Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。就是用来增强的方法 Aspect（切面）：是切入点（被增强的方法）和通知（用来增强的方法）的结合，在访问目标方法的时候Spring框架会自动去执行增强。一般是一个切面类，里面有Advice(增强方法) Weaving（织入）：是指把增强方法应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。其实目的就是告诉Spring框架哪些方法需要进行哪些增强 123&lt;!--method:增强的方法--&gt;&lt;!--pointcut:被增强的方法--&gt;&lt;!--&lt;aop:before method=\"method2\" pointcut=\"execution(public void xqp.proxy.aop.Target.save())\"/&gt;--&gt; 2 XML 配置 AOP 详解2.1 实例 导入 AOP 相关坐标 123456789101112&lt;!--导入spring的context坐标，context依赖aop--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- aspectj的织入 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt;&lt;/dependency&gt; 创建目标接口和目标类（内部有切点，即要被增强的方法） 12345678910public interface TargetInterface &#123; public void method();&#125;public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; 创建切面类（内部有增强方法） 123456public class MyAspect &#123; //前置增强方法 public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; 将目标类和切面类的对象创建权交给 spring（这个时候，无论是目标类还是切面类对于Spring容器来说都只是普通的bean） 1234&lt;!--配置目标类--&gt;&lt;bean id=\"target\" class=\"xqp.aop.Target\"&gt;&lt;/bean&gt;&lt;!--配置切面类--&gt;&lt;bean id=\"myAspect\" class=\"xqp.aop.MyAspect\"&gt;&lt;/bean&gt; 在 applicationContext.xml 中配置织入关系—导入aop命名空间 1234567891011&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\" http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; 在 applicationContext.xml 中配置织入关系—配置切点表达式和前置增强的织入关系(告诉Spring谁是切面类（里面含有增强方法），哪些是目标方法，也即被增强方法（切点）) 1234567&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!--配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt; &lt;aop:before method=\"before\" pointcut=\"execution(public void xqp.aop.Target.method())\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 测试 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(\"classpath:applicationContext.xml\")public class AopTest &#123; @Autowired private TargetInterface target; @Test public void test1()&#123; target.method(); &#125;&#125; 2.2 切点表达式的写法 表达式语法： execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 访问修饰符可以省略 返回值类型、包名、类名、方法名可以使用星号* 代表任意 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表 12345execution(public void xqp.aop.Target.method()) execution(void xqp.aop.Target.*(..))execution(* xqp.aop.*.*(..))execution(* xqp.aop..*.*(..))execution(* *..*.*(..)) 通知的类型： &lt;aop:通知类型 method=“切面类中方法名” pointcut=“切点表达式”&gt;&lt;&lt;/aop:通知类型&gt;&gt; 2.3 切点表达式的抽取当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。 123456789&lt;aop:config&gt; &lt;!--引用myAspect的Bean为切面对象--&gt; &lt;aop:aspect ref=\"myAspect\"&gt; &lt;!--抽取切点表达式--&gt; &lt;aop:pointcut id=\"myPointcut\" expression=\"execution(* xqp.aop.*.*(..))\"/&gt; &lt;!--引用抽取的切点表达式--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"myPointcut\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 3 注解配置 AOP详解 首先要创建目标接口和目标类，同时将目标类交给Spring容器（@Component(“target”)） 1234567891011public interface TargetInterface &#123; public void method();&#125;@Component(\"target\")//将目标类对象创建权交给Spring容器public class Target implements TargetInterface &#123; @Override public void method() &#123; System.out.println(\"Target running....\"); &#125;&#125; 创建切面类（内部有增强方法)，将切面类交给Spring容器（@Component(“myAspect”)）并且配置织入关系（@Aspect 和 @Before(“execution( com.itheima.aop..*(..))”)） 123456789@Component(\"myAspect\")//将切面类对象创建权交给Spring容器@Aspect//声明这个类是切面类public class MyAspect &#123; //配置织入关系（告诉Spring容器被增强的方法是谁，以及增强方法是谁） @Before(\"execution(* xqp.aop.*.*(..))\") public void before()&#123; System.out.println(\"前置代码增强.....\"); &#125;&#125; 在配置文件中开启组件扫描和 AOP 的自动代理 12345&lt;!--组件扫描--&gt;&lt;context:component-scan base-package=\"xqp.aop\"/&gt;&lt;!--aop的自动代理--&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; ==注意：自动代理必须配置，要不Spring容器无法识别通知类型和声明切面类的注解== 3.1 注解通知的类型通知的配置语法：@通知注解(“切点表达式”) 3.2 切点表达式的抽取同 xml配置，aop 一样，我们可以将切点表达式抽取。抽取方式是在切面内定义方法，在该方法上使用@Pointcut注解定义切点表达式，然后在在增强注解中进行引用。具体如下： 12345678910111213141516@@Component(\"myAspect\")@Aspectpublic class MyAspect &#123; //定义方法进行切点表达式的抽取 @Pointcut(\"execution(* xqp.proxy.anno.*.*(..))\") public void pointcut()&#123;&#125; //@Around(\"pointcut()\") @Around(\"MyAspect.pointcut()\") public Object method4(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(\"环绕前\"); Object proceed = proceedingJoinPoint.proceed(); System.out.println(\"环绕后\"); return proceed; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Spring知识小记2","slug":"Spring学习2","date":"2019-08-26T11:43:03.352Z","updated":"2019-08-29T01:33:33.957Z","comments":true,"path":"2019/08/26/Spring学习2/","link":"","permalink":"http://yoursite.com/2019/08/26/Spring学习2/","excerpt":"","text":"Spring的注解开发Spring本身是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。 Spring的原始注解 注解 说明 @Component 使用在类上用于实例化Bean @Controller 使用在web层类上用于实例化Bean @Service 使用在service层类上用于实例化Bean @Repository 使用在dao层类上用于实例化Bean @Autowired 使用在字段上用于根据类型依赖注入 @Qualifier 结合@Autowired一起使用用于根据名称进行依赖注入 @Resource 相当于@Autowired+@Qualifier，按照名称进行注入 @Value 注入普通属性 @Scope 标注Bean的作用范围 @PostConstruct 使用在方法上标注该方法是Bean的初始化方法 @PreDestroy 使用在方法上标注该方法是Bean的销毁方法 ==注意：使用注解开发的时候，需要在applicationContext.xml中配置组件扫描，用来指定哪个包以及子包下的Bean需要进行扫描以便识别使用注解配置的类，字段以及方法== 1&lt;context:component-scan base-package=\"xqp\"/&gt; 使用@Component，@Controller，@Service或者@Repository来表示哪些类需要利用Spring容器进行实例化，也就是哪些类需要使用Spring容器来产生对象 123//@Component(\"userService\")@Service(\"userService\")public class UserServiceImpl implements UserService &#123;&#125; 使用@Autowired，@Qualifier或者@Resource进行属性的注入(引用类型的数据注入)，使用@Value进行普通属性的注入 12345678910111213141516171819202122232425public class UserServiceImpl implements UserService &#123; //这样并没有多大价值 //@Value(\"xqp\") //这才是value的作用,从Spring容器里面获取配置文件里的东西 @Value(\"$&#123;jdbc.driver&#125;\") private String str; //如果单独只写@Autowired的话是按照数据类型从Spring容器中进行匹配 //也就是如果Spring扫描到这个注解之后会尝试从Spring里面找一个类型userDao //类型的Bean,找到之后会直接注入到这个地方，但是如果有多个同样的Bean的话就会出错 //@Qualifier(\"userDao\")是按照id的值从容器中进行匹配 //但是必须结合@Autowired一起使用// @Autowired// @Qualifier(\"userDao\") //这个name是要注入的Bean的id的值 @Resource(name = \"userDao\") private UserDao userDao; public void save() &#123; //这里因为提前对UserDao进行了注入，因此可以进行方法调用 userDao.save(); System.out.println(str); &#125;&#125; ==也许有人会有疑问，这里既然是set方法进行注入，为什么对应的类里面没有提供set方法呢？因为这里使用的是注解注入的方式，因此可以不写set方法，但是如果使用的.xml方式进行注入的话，就不能省略setXxx方法== 使用@Scope进行Bean的作用范围配置 123//@Scope(\"singleton\")@Scope(\"prototype\")public class UserServiceImpl implements UserService &#123;&#125; 使用@PostConstruct，@PreDestroy进行初始化方法和销毁方法的配置 1234567891011public class UserServiceImpl implements UserService &#123; @PostConstruct public void init()&#123; System.out.println(\"init...\"); &#125; @PreDestroy public void destory()&#123; System.out.println(\"destory...\"); &#125;&#125; Spring的新注解使用上面的注解还不能全部替代xml配置文件，还需要使用注解替代的配置如下： 非自定义的Bean的配置： 加载properties文件的配置：context:property-placeholder 组件扫描的配置：context:component-scan 引入其他文件： 注解 @Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解 @ComponentScan 用于指定Spring在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的&lt;context:component-scan base-package=”com.itheima”/&gt;一样 @Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中 @PropertySource 用于加载.properties 文件中的配置 @Import 用于导入其他配置类 123456789101112//标志该类是Spring的核心配置类,表明这个类是一个配置类@Configuration//配置组件扫描，//指定哪个包及其子包下的Bean需要进行扫描一遍识别使用注解配置的类、字段和方法//&lt;context:component-scan base-package=\"xqp\"/&gt;@ComponentScan(\"xqp\")//加载分配置文件（如果配置信息过多的话会将配置信息配置在不同的文件里）//此时在加载主配置文件的时候，就需要在主配置文件当中注入分配置文件@Import(&#123;DataSourceConfiguration.class&#125;)public class SpringConfiguration &#123;&#125; 123456789101112131415161718192021222324//加载外部的properties文件,免得参数不灵活//&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;@PropertySource(\"classpath:jdbc.properties\")public class DataSourceConfiguration &#123; @Value(\"$&#123;jdbc.driver&#125;\") private String driver; /*&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!--这里的name属性值写的是setXxx后面的xxx--&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"&gt;&lt;/property&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt;*/ //Spring会将当前方法的返回值以指定名称 //存储到Spring容器当中 @Bean(\"dataSource\") public DataSource getDataSource() throws Exception &#123; ComboPooledDataSource dataSource=new ComboPooledDataSource(); dataSource.setDriverClass(driver); return dataSource; &#125;&#125; Spring整合Junit开发首先肯定要导入Spring集合Junit的坐标 123456789101112&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; 使用@Runwith注解替换原来的运行期 12@RunWith(SpringJUnit4ClassRunner.class)public class SpringJunitTest &#123;&#125; 使用@ContextConfiguration指定配置文件或配置类 123456@RunWith(SpringJUnit4ClassRunner.class)//加载spring核心配置文件//@ContextConfiguration(value = &#123;\"classpath:applicationContext.xml\"&#125;)//加载spring核心配置类,(这里如果有多个配置类的话，需要加载的是主配置类)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123;&#125; 使用@Autowired注入需要测试的对象 123456@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService;&#125; 创建测试方法进行测试 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)public class SpringJunitTest &#123; @Autowired private UserService userService; @Test public void testUserService()&#123; userService.save(); &#125;&#125; Spring进行数据源配置首先来看最传统的手动创建数据源： 导入c3p0和druid以及mysql数据库驱动的坐标 123456789101112131415161718&lt;!-- C3P0连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.39&lt;/version&gt;&lt;/dependency&gt; 手动创建C3P0连接池 123456789101112@Testpublic void testC3P0() throws Exception &#123; //创建数据源 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //设置数据库连接参数 dataSource.setDriverClass(\"com.mysql.jdbc.Driver\"); dataSource.setJdbcUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUser(\"root\"); dataSource.setPassword(\"root\"); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 手动创建Druid连接池 12345678910111213@Testpublic void testDruid() throws Exception &#123; //创建数据源 DruidDataSource dataSource = new DruidDataSource(); //设置数据库连接参数 dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/test\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"root\"); //获得连接对象 Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 这样就把数据写固定了，稍稍改进一下 提取jdbc.properties配置文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/testjdbc.username=rootjdbc.password=root 读取jdbc.properties配置文件创建连接池 123456789101112@Testpublic void testC3P0ByProperties() throws Exception &#123; //加载类路径下的jdbc.properties,这里不需要写配置文件名的后缀 ResourceBundle rb = ResourceBundle.getBundle(\"jdbc\"); ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass(rb.getString(\"jdbc.driver\")); dataSource.setJdbcUrl(rb.getString(\"jdbc.url\")); dataSource.setUser(rb.getString(\"jdbc.username\")); dataSource.setPassword(rb.getString(\"jdbc.password\")); Connection connection = dataSource.getConnection(); System.out.println(connection);&#125; 但是想用Spring来配置数据源 可以将DataSource的创建权交由Spring容器去完成 DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入 123456&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"jdbcUrl\" value=\"jdbc:mysql://localhost:3306/test\"/&gt; &lt;property name=\"user\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"root\"/&gt;&lt;/bean&gt; 测试从容器当中获取数据源 12345ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\");DataSource dataSource = (DataSource)applicationContext.getBean(\"dataSource\");Connection connection = dataSource.getConnection();System.out.println(connection); 虽然使用了Spring来配置数据源，但是又把数据写死了啊，不好 抽取jdbc的配置文件 首先，需要引入context命名空间和约束路径 命名空间： 1xmlns:context=\"http://www.springframework.org/schema/context\" 约束路径： 12http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 1234567&lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt;&lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt;&lt;/bean&gt;","categories":[],"tags":[],"keywords":[]},{"title":"Spring知识小记1","slug":"Spring学习1","date":"2019-08-25T05:47:51.769Z","updated":"2019-08-30T11:13:19.447Z","comments":true,"path":"2019/08/25/Spring学习1/","link":"","permalink":"http://yoursite.com/2019/08/25/Spring学习1/","excerpt":"","text":"1.Bean标签的范围（scope） 取值范围 说明 singleton 这是默认值，单例 prototype 多例 request WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 request 域中 session WEB 项目中，Spring 创建一个 Bean 的对象，将对象存入到 session 域中 gloable session WEB 项目中，应用在 Portlet 环境，如果没有 Portlet 环境那么globalSession 相当于 session 当scope的取值是singleton的时候： Bean的实例化个数：1 Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例 1ApplicationContext applicationContext=new ClassPathXmlApplicationContext(\"applicationContext.xml\"); Bean的生命周期： ​ 对象创建：当应用加载，创建容器时，对象就被创建了 ​ 对象运行：只要容器在，对象一直活着 ​ 对象销毁：当应用卸载，销毁容器时，对象就被销毁了 当scope的取值是prototype的时候： Bean的实例化个数：多个,每次进行一次getBean()就会实例化一个新的对象 Bean的实例化时机：当调用getBean()方法时实例化Bean 1Object userService = applicationContext.getBean(\"userService\"); Bean的生命周期 对象创建：当使用对象时，创建新的对象实例 对象运行：只要对象在使用中，就一直活着 对象销毁：当对象长时间不用时，被 Java 的垃圾回收器回收了 2. 如何进行Bean的实例化（如何利用Spring获取对象）Bean的实例化有三种方式：无参构造方法实例化，工厂静态方法实例化，工厂实例方法实例化 2.1 无参构造方法实例化1&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"/&gt; 这样就可以利用UserDao userDao = (UserDao)applicationContext.getBean(“userDao”);获得UserDao的对象了。 2.2 工厂静态方法实例化要使用这个方法肯定要先有个静态工厂，比如： 12345public class StaticFactoryBean &#123; public static UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 然后再进行Spring容器的配置 12&lt;bean id=\"userDao\" class=\"xqp.factory.StaticFactoryBean\" factory-method=\"createUserDao\" /&gt; ==其中factory-method是用来指向具体的方法的，这里因为是静态的，因此通过getBean()方法后会或的对应的class的属性，进而得到对应的类（不是类的对象），最后在根据factory-method方法来表明这个类应该调用那个方法来返回所需要的对象== 2.4 工厂实例方法实例化同样的，肯定需要一个工厂（非静态的），比如： 12345public class DynamicFactoryBean &#123; public UserDao createUserDao()&#123; return new UserDaoImpl(); &#125;&#125; 然后再进行Spring容器的配置 12&lt;bean id=\"factoryBean\" class=\"xqp.factory.DynamicFactoryBean\"/&gt;&lt;bean id=\"userDao\" factory-bean=\"factoryBean\" factory-method=\"createUserDao\"/&gt; ==因为是非静态的，因此需要利用对象调用方法来进行返回所需要的对象，比如传统方法应该这样写：DynamicFactoryBean a=new DynamicFactoryBean(); a.createUserDao();来返回所需要的对象。因此在通过getBean()方法后会得到factory-bean的属性值进而得到对应的对象，那么这个对象是谁呢？那来的？答案是根据id=”factoryBean”,进而得到class的属性的值获得对应类的对象，然后这个对象会根据factory-method的值决定调用哪个函数来返回所需要的对象== 3. Bean的依赖注入（如何往对象里面设置参数，比如username,age等）依赖注入（Dependency Injection）：它是 Spring 框架核心 IOC 的具体实现。在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取 3.1 依赖注入的两种方式 构造方法（引用类型数据的注入为例） 123&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"xqp.service.impl.UserServiceImpl\"&gt; &lt;constructor-arg name=\"userDao\" ref=\"userDao\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; ==这里的constructor-arg标签是对构造方法中参数的注入，其中name是参数的名称，参数名称是啥，那么就是啥；ref指向的是要注入的Bean,和第一个标签里的id相对应== setXxx方法注入（引用类型数据的注入为例，如果是用的是xml方式的话set方法不能省略，但是如果使用的是注解方式，那么set方法可以省略） 首先随便添加一个set方法 12345678910public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 在Spring容器中调用set方法进行注入 1234&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"xqp.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt;&lt;/bean&gt; ==注意：引用类型的数据注入需要使用带有ref的方式，ref指向要注入的数据，普通类型的注入直接使用value进行数据注入；name是参数的名称== 如果使用set方法注入，并且注入数据少的话可以使用p命名空间注入（就是简化了而已）。 P命名空间注入本质也是set方法注入，但比起上述的set方法注入更加方便，主要体现在配置文件中，如下： 首先，需要引入P命名空间： 1xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 其次，需要修改注入方式： 1&lt;bean id=\"userService\" class=\"xqp.service.impl.UserServiceImpl\" p:userDao-ref=\"userDao\"/&gt; 3.2 依赖注入的数据类型 普通数据类型 123456789101112131415public class UserDaoImpl implements UserDao &#123; private String company; private int age; public void setCompany(String company) &#123; this.company = company; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public void save() &#123; System.out.println(company+\"===\"+age); System.out.println(\"UserDao save method running....\"); &#125;&#125; 1234&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"company\" value=\"大疆\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"15\"&gt;&lt;/property&gt;&lt;/bean&gt; 引用数据类型 12345678910public class UserServiceImpl implements UserService &#123; private UserDao userDao; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; @Override public void save() &#123; userDao.save(); &#125;&#125; 1234&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"/&gt;&lt;bean id=\"userService\" class=\"xqp.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"userDao\"/&gt;&lt;/bean&gt; 集合数据类型（List为例） List&lt;普通数据类型&gt; 1234567891011public class UserDaoImpl implements UserDao &#123; private List&lt;String&gt; strList; public void setStrList(List&lt;String&gt; strList) &#123; this.strList = strList; &#125; @Override public void save() &#123; System.out.println(strList); System.out.println(\"UserDao save method running....\"); &#125;&#125; 123456789&lt;bean id=\"userDao\" class=\"com.itheima.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"strList\"&gt; &lt;list&gt; &lt;value&gt;aaa&lt;/value&gt; &lt;value&gt;bbb&lt;/value&gt; &lt;value&gt;ccc&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; List&lt;引用数据类型&gt; 1234567891011public class UserDaoImpl implements UserDao &#123; private List&lt;User&gt; userList; public void setUserList(List&lt;User&gt; userList) &#123; this.userList = userList; &#125; @Override public void save() &#123; System.out.println(userList); System.out.println(\"UserDao save method running....\"); &#125;&#125; 1234567891011121314151617181920&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"userList\"&gt; &lt;list&gt; &lt;!--进行引用类型的注入--&gt; &lt;bean class=\"xqp.domain.User\" ref=\"user1\"/&gt; &lt;bean class=\"xqp.domain.User\" ref=\"user2\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"user1\" class=\"xqp.domain.User\"&gt; &lt;!--User里面也有属性，因此也需要一块进行注入--&gt; &lt;property name=\"name\" value=\"Tom\"&gt;&lt;/property&gt; &lt;property name=\"addr\" value=\"beijing\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"user2\" class=\"xqp.domain.User\"&gt; &lt;!--User里面也有属性，因此也需要一块进行注入--&gt; &lt;property name=\"name\" value=\"Lucy\"&gt;&lt;/property&gt; &lt;property name=\"addr\" value=\"tianjing\"&gt;&lt;/property&gt;&lt;/bean&gt; Map&lt;String,User&gt; 12345678910111213141516171819&lt;bean id=\"user1\" class=\"xqp.domain.User\"&gt; &lt;!--User里面也有属性，因此也需要一块进行注入--&gt; &lt;property name=\"name\" value=\"Tom\"&gt;&lt;/property&gt; &lt;property name=\"addr\" value=\"beijing\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"user2\" class=\"xqp.domain.User\"&gt; &lt;!--User里面也有属性，因此也需要一块进行注入--&gt; &lt;property name=\"name\" value=\"Lucy\"&gt;&lt;/property&gt; &lt;property name=\"addr\" value=\"tianjing\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;property name=\"userMap\"&gt; &lt;map&gt; &lt;!--这个key代表的map的key，叫啥都行，无所谓--&gt; &lt;!--ref指向的是要注入的Bean，是要引用容器当中的Bean的id--&gt; &lt;entry key=\"aaaa\" value-ref=\"user1\"&gt;&lt;/entry&gt; &lt;entry key=\"bbbb\" value-ref=\"user2\"&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/property&gt; Properties 123456789101112public class UserDaoImpl implements UserDao &#123; private Properties properties; public void setProperties(Properties properties) &#123; this.properties = properties; &#125; @Override public void save() &#123; System.out.println(properties); System.out.println(\"UserDao save method running....\"); &#125;&#125; 123456789&lt;bean id=\"userDao\" class=\"xqp.dao.impl.UserDaoImpl\"&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"p1\"&gt;aaa&lt;/prop&gt; &lt;prop key=\"p2\"&gt;bbb&lt;/prop&gt; &lt;prop key=\"p3\"&gt;ccc&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 3.3 分模块开发 实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过import标签进行加载，比如： 12&lt;import resource=\"applicationContext-user.xml\"/&gt;&lt;import resource=\"applicationContext-product.xml\"/&gt;","categories":[],"tags":[],"keywords":[]},{"title":"redis&jedis初探","slug":"redis","date":"2019-08-12T07:48:26.978Z","updated":"2019-08-12T08:49:51.496Z","comments":true,"path":"2019/08/12/redis/","link":"","permalink":"http://yoursite.com/2019/08/12/redis/","excerpt":"","text":"redis是一款高性能的NOSQL系列的非关系型数据库。那什么又是NOSQL呢？ NOSQL是一项全新的数据库理念，全称是Not Only SQL,也就是“不仅仅是SQL”，它的产生是为了解决大规模数据集合多种数据种类带来的难题。 NOSQL和关系型数据库比较 优点 成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。 查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。 存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。 缺点 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。 不提供关系型数据库对事务的处理。 主流的NOSQL产品 键值(Key-Value)存储数据库 典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 数据模型： 一系列键值对 优势： 快速查询 劣势： 存储的数据缺少结构化 列存储数据库 典型应用：分布式的文件系统 数据模型：以列簇式存储，将同一列数据存在一起 优势：查找速度快，可扩展性强，更容易进行分布式扩展 劣势：功能相对局限 文档型数据库 典型应用：Web应用（与Key-Value类似，Value是结构化的） 数据模型： 一系列键值对 优势：数据结构要求不严格 劣势： 查询性能不高，而且缺乏统一的查询语法 图形(Graph)数据库 典型应用：社交网络 数据模型：图结构 优势：利用图结构相关算法。 劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案 什么是Redis?Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。 Redis支持的键值数据类型有以下几种： 字符串类型 string 存储： set key value 获取： get key 删除： del key 哈希类型 hash 存储： hset key field value 获取： hget key field: 获取指定的field对应的值 hgetall key：获取所有的field和value 删除： hdel key field 列表类型 list 添加： lpush key value： 将元素加入列表左边 rpush key value：将元素加入列表右边 获取： lrange key start end：获取某个范围的值 删除： lpop key：删除列表最左边的元素，并将元素返回 rpop key： 删除列表最右边的元素，并将元素返回 集合类型 set 存储：sadd key value 获取：smembers key：获取set集合中所有元素 删除：srem key value：删除set集合中的某个元素 有序集合类型 sortedset 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value redis的应用场景： 缓存（数据查询、短连接、新闻内容、商品内容等等） 聊天室的在线好友列表 任务队列。（秒杀、抢购、12306等等） 应用排行榜 网站访问统计 数据过期处理（可以精确到毫秒 分布式集群架构中的session分离 通用的命令： keys * : 查询所有的键 type key ： 获取键对应的value的类型 del key：删除指定的key value Redis的持久化redis是一个内存数据库，当redis服务器重启，或者电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。 RDB：默认方式，不需要进行配置，默认就使用这种机制，在一定的间隔时间中，检测key的变化情况，然后持久化数据 编辑redis.windwos.conf文件 AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据 编辑redis.windwos.conf文件","categories":[],"tags":[],"keywords":[]},{"title":"JSON","slug":"Json","date":"2019-08-12T03:12:45.400Z","updated":"2019-08-12T05:58:40.259Z","comments":true,"path":"2019/08/12/Json/","link":"","permalink":"http://yoursite.com/2019/08/12/Json/","excerpt":"","text":"JSON全称是JavaScript Object Notation，即JavaScript对象表示法。多用于存储和交换文本信息的语法，能够进行数据的传输并且比XML体量更小，解析也更加容易。 JSON里面的一些基本规则： 数据在名称/值对中：json数据是由键值对构成的 键用引号(单双都行)引起来，也可以不使用引号 值得取值类型： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） {“address”:{“province”：”陕西”….}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{}定义json 格式 方括号保存数组：[] 如何获取数据呢？ json对象.键名 json对象[“键名”] 数组对象[索引] 遍历 比如现在有两种格式的数据： var person = {“name”: “张三”, age: 23, ‘gender’: true}; var ps = [ ​ {“name”: “张三”, “age”: 23, “gender”: true}, ​ {“name”: “李四”, “age”: 24, “gender”: true}, ​ {“name”: “王五”, “age”: 25, “gender”: false} ​ ]; 获取person对象中所有的键和值（for in 循环） **for(var key in person){ //这样的方式获取不行。因为相当于 person.&quot;name&quot; //alert(key + &quot;:&quot; + person.key); alert(key+&quot;:&quot;+person[key]); }** 获取ps中的所有值 **for (var i = 0; i &lt; ps.length; i++) { var p = ps[i]; for(var key in p){ alert(key+&quot;:&quot;+p[key]); } }** JSON数据和java对象的相互转换 JSON转为Java对象 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 readValue(json字符串数据,Class类型) Java对象转换JSON 导入jackson的相关jar包 创建Jackson核心对象 ObjectMapper 调用ObjectMapper的相关方法进行转换 writeValue(参数1，obj)： 参数一： File：将obj对象转换为JSON字符串，并保存到指定的文件中 Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中 OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中 注解 @JsonIgnore：排除属性。不会被转换 @JsonFormat：属性值得格式化，按照指定格式转换 @JsonFormat(pattern = “yyyy-MM-dd”)","categories":[],"tags":[],"keywords":[]},{"title":"Ajax的实现方式","slug":"Ajax","date":"2019-08-12T02:58:38.112Z","updated":"2019-08-12T07:15:13.705Z","comments":true,"path":"2019/08/12/Ajax/","link":"","permalink":"http://yoursite.com/2019/08/12/Ajax/","excerpt":"","text":"Ajax全称是ASynchronous JavaScript And XML，是一种异步的传输技术。 什么叫做异步呢？先来看同步！ 同步：客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。 异步：客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。 Ajax是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新 Ajax的实现方式Ajax的实现方式总共有两种：原生的JS实现方式，另外一种是JQ实现方式 JS实现方式： 1234567891011121314151617181920212223242526272829303132//发送异步请求//1.创建核心对象var xmlhttp;if (window.XMLHttpRequest)&#123; // code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();&#125;else&#123; // code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;//2. 建立连接/* 参数： 1. 请求方式：GET、POST * get方式，请求参数在URL后边拼接。send方法为空参 * post方式，请求参数在send方法中定义 2. 请求的URL： 3. 同步或异步请求：true（异步）或 false（同步） */ xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);//3.发送请求 xmlhttp.send();//4.接受并处理来自服务器的响应结果//获取方式 ：xmlhttp.responseText//什么时候获取？当服务器响应成功后再获取//当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。 //判断readyState就绪状态是否为4，判断status响应状态码是否为200 xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; //获取服务器的响应结果 var responseText = xmlhttp.responseText; alert(responseText); &#125;&#125; JQ实现方式 $.get/post(url, [data], [callback], [type]) url：请求路径 data：请求参数 callback：回调函数 type：响应结果的类型 12345678910111213141516171819202122//第一种方式$.ajax(&#123; url:\"ajaxServlet\", type:\"POST\", data:&#123;\"username\":\"jack\",\"age\":23&#125;, success:function (message) &#123; alert(message) &#125;, error:function () &#123; alert(\"Wrong\"); &#125;&#125;);//第二种方式$.get(\"ajaxServlet\",&#123;username:\"rose\"&#125;,function (data) &#123; alert(data);&#125;,\"text\");//第三种方式$.post(\"ajaxServlet\",&#123;username:\"rose\"&#125;,function (data) &#123; alert(data);&#125;,\"text\");","categories":[],"tags":[],"keywords":[]},{"title":"JQuery知识小记2","slug":"JQuery_2","date":"2019-08-12T02:27:48.518Z","updated":"2019-08-12T02:55:58.022Z","comments":true,"path":"2019/08/12/JQuery_2/","link":"","permalink":"http://yoursite.com/2019/08/12/JQuery_2/","excerpt":"","text":"动画 隐藏和显示元素 show(speed,[easing],[fn]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) speed：动画的速度。三个预定义的值(“slow”,”normal”, “fast”)或表示动画时长的毫秒数值(如：1000) easing：用来指定切换效果，默认是”swing”，可用参数”linear” fn：在动画完成时执行的函数，每个元素执行一次。 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 遍历 JS遍历方式 for(初始化值;循环结束条件;步长) jq的遍历方式 jquery对象.each(function(index,element){}); index:就是元素在集合中的索引 element：就是集合中的每一个元素对象 this：集合中的每一个元素对象 123$(\"#city li\").each(function (index, element) &#123; alert(index+\"---\"+$(element).html());&#125;); $.each(object, [callback]) 123$.each(($(\"#city li\")),function () &#123; alert($(this).html());&#125;); for..of: jquery 3.0 版本之后提供的方式 123for (li of $(\"#city li\")) &#123; alert(li.innerHTML);&#125; 事件绑定 jquery标准的绑定方式 jq对象.事件方法(回调函数)； ==注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。== on绑定事件/off解除绑定 jq对象.on(“事件名称”,回调函数) jq对象.off(“事件名称”)：如果off方法不传递任何参数，则将组件上的所有事件全部解绑 事件切换：toggle jq对象.toggle(fn1,fn2…) 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2…..","categories":[],"tags":[],"keywords":[]},{"title":"jquery-1","slug":"JQuery_1","date":"2019-08-11T00:23:40.354Z","updated":"2019-08-12T02:27:25.143Z","comments":true,"path":"2019/08/11/JQuery_1/","link":"","permalink":"http://yoursite.com/2019/08/11/JQuery_1/","excerpt":"","text":"JQuery是一个快速、简介的JavaScript框架，封装了JavaScript常用的功能代码，提供了一种渐变的JavaScript设计模式，又花了HTML文档操作、事件处理、动画设计以及Ajax交互。 JQuery和JS对象的转换 JQuery –&gt; JS：JQ对象[索引]或者JQ对象.get(索引) JS –&gt; JQuery：$(js对象) 选择器 基本选择器 标签选择器（元素选择器） $(“html标签名”)：获得所有匹配标签名称的元素 id选择器 $(“#id的属性值”)：获得与指定id属性匹配的元素 类选择器 $(“.class的属性值”)：获得与指定的class属性值匹配的元素 并集选择器 $(“选择器1，选择器2, …”)：获得多个选择器选中的所有元素 层级选择器 后代选择器 $(“A B”)：选择A元素内部的所有B元素 子选择器 $(“A &gt; B”)：选择A元素内部的所有B子元素 属性选择器 属性名称选择器 $(“A[属性名]”) ：包含指定属性的选择器 属性选择器 $(“A[属性名=’值’]”)： 包含指定属性等于指定值的选择器 复合属性选择器 $(“A[[属性名=’值’]][]…”) ：包含多个属性条件的选择器 过滤选择器 首元素选择器 :first 获得选择的元素中的第一个元素 尾元素选择器 :last 获得选择的元素中的第一个元素 非元素选择器 :not(selector) 不包括指定内容的元素 偶数选择器 :even 偶数，从 0 开始计数 奇数选择器 :odd 奇数，从 0 开始计数 等于选择器 :eq(index) 指定索引元素 大于选择器 :gt(index) 大于指定索引元素 小于选择器 :lt(index) 小于指定索引元素 标题选择器 :header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器 :enabled 获得可用元素 不可用元素选择器 :disabled 获得不可用元素 选中选择器 :checked 获得单选/复选框选中的元素 :selected 获得下拉框选中的元素 DOM操作 内容操作 html()： 获取/设置元素的标签体内容 text()：获取/设置元素的标签体纯文本内容 val()： 获取/设置元素的value属性值 属性操作 通用属性 attr()：获取/设置元素的属性，如果操作的是元素自定义的属性，则建议使用attr removeAttr()：删除属性 prop()：获取/设置元素的属性，如果操作的是元素的固有属性，则建议使用prop removeProp()：删除属性 对class属性进行操作 addClass()：添加class属性值 removeClass()：删除class属性值 toggleClass()：切换class属性 css()：设置样式 CRUD append():父元素将子元素追加到末尾 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾 prepend():父元素将子元素追加到开头 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头 appendTo(): 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾 prependTo(): 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头 after():添加元素到元素后边 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系 before():添加元素到元素前边 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 insertAfter() 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系 insertBefore() 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系 remove():移除元素 对象.remove():将对象删除掉 empty():清空元素的所有后代元素。 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点","categories":[],"tags":[],"keywords":[]},{"title":"常见乱码问题以及解决方案（不定期更新）","slug":"乱码问题以及解决方案","date":"2019-07-29T11:30:48.031Z","updated":"2019-07-31T01:45:28.422Z","comments":true,"path":"2019/07/29/乱码问题以及解决方案/","link":"","permalink":"http://yoursite.com/2019/07/29/乱码问题以及解决方案/","excerpt":"","text":"所有的乱码问题其实都是由于编解码使用的码表不一致而导致的。 1.tomcat启动日志乱码找到tomcat的安装路径，找到conf目录，打开logging.properties文件 将java.util.logging.ConsoleHandler.encoding = UTF-8改成java.util.logging.ConsoleHandler.encoding = GBK 这样就可以解决Tomcat启动日志中中文乱码的问题 2.get方式请求参数乱码在tomcat 8 之后get方式请求参数乱码的问题已经得到了解决，无需关心。但是这之前的乱码问题并没有得到解决。 第一种解决方法： 将发生乱码的地方重新手动进行编码： ​ new String(request.getParameter(“属性”).getBytes(“iso-8859-1”), “UTF-8”)；这句话的意思就是：将拿到的数据反向查询iso-8859-1码表，然后利用所的结果利用新的码表（utf-8）再去构建一个对应的新的数据。 第二种解决方法（不要使用这种方式，因为在开发中不可能去更改服务器的配置）： 在tomcat的安装路径中找到conf目录，再找到servel.xml，将 里面新增一个属性：URIEncoding=”utf-8” ==超链接点击也属于get方式请求== 3.post方式请求参数乱码 第一种解决方式： 在获取请求参数之前，重新进行编码设置即可。request.setCharacterEncoding(“utf-8”) 第二种解决方法（不要使用这种方式，因为在开发中不可能去更改服务器的配置）： 在tomcat的安装路径中找到conf目录，再找到servel.xml，将 里面新增一个属性：URIEncoding=”utf-8” 第三种解决方式（不要使用这种方式，因为在开发中不可能去更改服务器的配置）： 在tomcat的安装路径中找到conf目录，再找到servel.xml，将 里面新增一个属性：useBodyEncodingForURI=”true” 4.response响应乱码 告诉浏览器服务器发送的消息体数据的编码，建议浏览器使用该编码解码 content-type:服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition:服务器告诉客户端应该以什么格式打开响应体数据 response.setHeader(“content-type”,”text/html;charset=utf-8”); 简单写法： response.setContentType(“utf-8”); response.setCharacterEncoding(“客户端使用的编码类型”);这种方式只能在知道客户端使用的编码类型条件下才可以这样使用 5.Cookie存取乱码在tomcat 8之后Cookie支持中文数据，这里不作考虑。主要来看tomcat 8之前 在写入Cookie的时候，先用URL编码进行编码： newData = URLEncoder.encode(oldData，”utf-8”) 在读取Cookie的时候，要用URL编码进行解码 newData = URLDecoder.decode(oldData，”utf-8”)","categories":[],"tags":[],"keywords":[]},{"title":"request和response知识点小记","slug":"requestAndresponse","date":"2019-07-28T00:27:43.760Z","updated":"2019-07-28T07:30:23.256Z","comments":true,"path":"2019/07/28/requestAndresponse/","link":"","permalink":"http://yoursite.com/2019/07/28/requestAndresponse/","excerpt":"","text":"requestrequest对象是由服务器来进行创建的，主要用来获取客户端发送的请求信息。 由于客户端的请求信息可以划分成请求行、请求头、请求体（get方式有，post方式才有）。 1.获取请求行（GET /虚拟目录/资源路径?参数=参数值 HTTP/版本） 获取请求方式：GET String getMethod() 获取虚拟目录： String getContextPath() 获取Servlet路径（资源路径）： String getServletPath() 获取get方式的请求参数： String getQueryString() 获取请求的URI（虚拟目录/资源路径）： String getRequestURI() 获取请求的URL（http://localhost/day14/demo1）: String getRequestURL() 获取协议以及版本 String getProtocol() 获取客户端的IP地址 String getRemoteAddr() 2.获取请求头数据 String getHeader(String name)：通过请求头的名称获取请求头的值 Enumeration getHeaderNames()：获取所有的请求头名称 3.获取请求体数据（post方式独有） 获取流对象： BufferReader getReader() ServletInputStream getInputStream() 从流对象中获取数据 4.其他通用获取功能 String getParameter(String name)：根据参数名获取参数值 String getParameterMap(String name)：根据参数名称获取参数值的数据 Enumeration getParameterNames()：获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap()：获取所有参数的map集合 5.中文乱码 get方式在tomcat8已经不存在，被解决了 post方式： 在获取参数之前，设置request的编码request.setCharacterEncoding(“utf-8”) 6.请求转发：一种在服务器内部的资源跳转方式 先获取请求转发器对象：RequestDispatcher(String path) 使用请求其对象进行转发：forward(ServletRequest request，ServletResponse response) 特点： 浏览器地址栏路径不发生变化 只能是转发到当前服务器内部资源 转发是一次请求 可以通过请求域进行共享数据 请求转发过程中，使用request域共享数据，实际上数据会保存到request对象中的一个Map集合中 7.获取ServletContext ServletContext getServletContext() responseresponse主要用来设置响应消息。 1.设置响应行 setStatus(int sc)：设置状态码 2.设置响应头 setHeader(String name,String value) 3.设置响应体 获取输出流 PrintWriter getWriter() ServletOutputStream getOutputStream() 使用输出流，将数据输出到客户端浏览器 4.重定向 设置状态码：response.setStatus(302) 设置响应头：response.setHeader(“location”,”跳转路径”) 或者： response.sendRedirect(“跳转路径”); 特点： 地址栏发生变化 重定向可以访问其他服务器的资源 重定向是两次请求，不能使用request对象来共享数据","categories":[],"tags":[],"keywords":[]},{"title":"分页查询记录","slug":"分页查询","date":"2019-07-25T02:25:21.630Z","updated":"2019-07-25T09:26:57.328Z","comments":true,"path":"2019/07/25/分页查询/","link":"","permalink":"http://yoursite.com/2019/07/25/分页查询/","excerpt":"","text":"分页查询是一个很重要的功能，今天第一次正式接触到。偷偷记录一下 1. 分析1.1 服务器端首先来看服务器端需要给客户端那些数据，才能让客户端将分页工具条以及列表数据展示出来呢？ 首先在客户端应当展示一个数据的总记录数：int totalCount（该数据给客户端使用） 其次需要一个总页码：int totalPage=（totalCount%每页显示条数）==0？（totalCount/每页显示条数）：（totalCount/每页显示条数）+1（该数据给客户端使用） 还需要一个集合来展示查询出来的数据信息：List list 需要在客户端动态的去添加当前是第几页，如何判断呢？就需要服务器来告诉客户端当前是哪一页：int currentPage（该数据由客户端提供） 需要计算totalPage,需要使用到每页展示多少条数据：int rows,（该数据由客户端提供） 以上那些数据如何传递给客户端呢？当然是使用封装了。利用一个类把这些数据封装起来：PageBean 1.2 客户端客户端需要给服务器传递那些数据，服务器才能查询出来那个PageBean对象呢？ 客户端需要提供每页需要显示多少条信息的数据给服务器：int rows。这个数据可以设置成固定值（该数据给服务器端使用） 客户端需要给服务器提供一个当前页码用于给服务器计算开始查询的索引：int currentPage（该数据给服务器端使用） 2. 实现 在看来执行的一个流程图 2.1 服务器端Page：PageBean SearchUserByPageServlet：分页查询的Servlet UserService： UserServiceImpl： UserDao： UserDaoImpl： 2.2 客户端在服务器端进行后端操作结束之后，就需要在客户端将效果展示出来 首先来修改显示数据那一部分（第一行的page.list，剩下的哪些是我的其他它代码，user是对单个用户信息的封装类的对象）这一部分也就是去遍历page.list这个被分页查询出来的结果集合，然后分别用User对象user拿到每个用户的信息展示到页面上，如果把page.list换成user的话，就会把全部数据信息展示出来，没有分页效果： 在来修改分页条的一部分，让它变成真正的动态分页条，这样分页条的效果就会随着数据的变化而变化（这里将每页显示的数据固定为rows=8条） 最后再来修改分页条后面的文字信息，这里会显示总共有多少条数据以及分页条总共有多少页 这样就能完成一个基本的分页效果了，不过还有很多细节需要进行修改完善。","categories":[],"tags":[],"keywords":[]},{"title":"Servlet随手记（不定期更新）","slug":"Servlet随手小记","date":"2019-07-24T12:35:21.719Z","updated":"2019-07-24T13:16:29.576Z","comments":true,"path":"2019/07/24/Servlet随手小记/","link":"","permalink":"http://yoursite.com/2019/07/24/Servlet随手小记/","excerpt":"","text":"1. Servlet配置的两种方式 在Servlet 3.0之前是通过web.xml来进行配置 12345678&lt;servlet&gt; &lt;servlet-name&gt;/随便写&lt;/servlet-name&gt; &lt;servlet-class&gt;要访问的Servlet所在的全类名&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;/随便写&lt;/servlet-name&gt; &lt;url-pattern&gt;/要通过哪种路径访问该Servlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ==注意：== 两个值必须保持一致 前面的反斜杠可有可无 的值通常都是Servelt的名字首字母小写 的反斜杠不可以省略不写 在Servlet 3.0之后可以通过进行配置 在类的上方添加如下注释：@WebServlet(“/要通过哪种路径访问该Servlet”) 2. Servlet的执行原理 当服务器接受到客户端的请求之后，会对请求的URL进行解析，得到访问Servlet的资源路径。也就是在里面配置的那个路径 在找到这个路径之后就会到web.xml文件去查找是否有对应的值与之相同 如果有的话就会得到对应的，然后在根据里面的值去寻找里面的。（这也就是为什么要求两个值必须相同）。 如果找到的话，就会得到对应的，然后tomcat会将这个类（Servlet本身就是一个类）的字节码文件家在进内存，并且创建这个类（Servlet）的对象 调用Servlet里面被实现的方法 3.Servlet访问路径的配置 一个Servlet可以定义多个访问路径： 只有一个访问路径的时候：@WebServlet(“/d4”) 有多个访问路径的时候：@WebServlet({“/d4”,”/dd4”,”/ddd4”}) 路径的一些规则： /xxx：路径匹配 /xxx/xxx:多层路径，目录结构 *.后缀名：后缀名匹配 ==注意：== 1. **/*.后缀名** 是错误的写法 2. ***** 是错误的写法","categories":[],"tags":[],"keywords":[]},{"title":"Tomcat随手小记","slug":"Tomcat随手记","date":"2019-07-24T12:18:49.057Z","updated":"2019-07-24T12:34:56.908Z","comments":true,"path":"2019/07/24/Tomcat随手记/","link":"","permalink":"http://yoursite.com/2019/07/24/Tomcat随手记/","excerpt":"","text":"学习过程中，开始接触到了服务器这一块。记录一下容易忘记的东西吧。 项目部署到tomcat服务器上有三种方式： 直接将项目放到webapps目录下即可。 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。war包会自动解压缩 配置conf/server.xml文件，在标签体中配置 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写","categories":[],"tags":[],"keywords":[]},{"title":"路径随手记（不定期更新）","slug":"相对路径随手记（不定期更新）","date":"2019-07-12T01:53:43.359Z","updated":"2019-07-29T10:47:16.596Z","comments":true,"path":"2019/07/12/相对路径随手记（不定期更新）/","link":"","permalink":"http://yoursite.com/2019/07/12/相对路径随手记（不定期更新）/","excerpt":"","text":"一直以来对相对路径不是特别清楚，特来个小笔记复习一下 在Java中，相对路径这个概念并不是一层不变的，随着Java知识内容的不同,相对路径这个概念也在不断的变化。 IO中的相对路径​ 首先来说一下首次接触到的IO流里面的相对路径，这个时候的相对路径是相对于当前项目的根目录而言的。那么啥又叫当前项目的根目录呢？额。。。嗯。。。来看具体代码吧。 ​ a.txt这个文件是放在E:\\IdeaProjects\\base-code\\baseCode下面的，其中base-code是项目的名称，而baseCode是项目里面具体模块的名称。再来看我是从什么地方访问的这个文件 ​ 访问这个文件的java类放在这个项目中某个模块里面多个层级目录下的，而这个类和这个类访问的a.txt的相对位置关系是啥？想一想？这个类放在src目录下，而这个类访问的a.txt文件的位置是与src目录平级的。那么如何找他们的相对路径关系呢？这样想，在src目录下能找到这个a.txt文件吗？很明显找不到，那么在哪个目录下面既能找到这个类又能找到这个类访问的a.txt文件呢？当然这两个资源都放在这个项目下面，在这个项目里面肯定能找到，但这不是重点！范文太大了，一个项目都有好几十个各种各样的目录和文件呢，直接在项目里面找找到猴年马月啊。那就缩小范围吧，这两个资源文件都放在这个项目下的baseCode这个模块下，这才是重点！！！也就是说这个模块是这两个资源文件存放位置==相同目录的最后一个目录==，也把这称为==根目录==。所以这里写的相对路径就是：baseCode\\\\a.txt。说白了，这里的根目录就是起到一个限制作用，限制你在哪个目录下面才能访问到想要访问的资源文件，而且这个目录必须是最后一个层级的目录。 ​ 假如此时我把a.txt移到src目录下，会出现什么结果呢？ 吼吼吼，报错了。因为相对路径变了。在与src平级的目录下找不到a.txt这个文件。 但是这个时候如果把相对路径改为baseCode\\\\src\\\\a.txt或者就正确了。但是注意啊，如果写成\\\\src\\\\a.txt就不对了，为啥呢？我个人的理解是一个项目里面可以有很多的模块（不可以重名），而每个模块下又会有src这个目录，如果直接写\\\\src\\\\a.txt的话，idea根本分不清是哪一个模块下的src里面的a.txt文件，因此无法访问到。当然了，模块之间是可以相互访问的，但是这里不做介绍。 关于IO流里面的相对路径就先介绍到这里，如果有其他的还会后续更新 类加载器中的相对路径​ 这个相对来说就要简单粗暴的多了。这里的相对路就就是相当于当前模块的src文件夹而言的。 ​ 依然来看例子 如果把要访问的文件不放在src下面，利用IO流里面相对路径的概念来进行访问的话会报错： ​ 这表明IO流里面的相对路径规则在这里并不适用。或者说，如果把这种配置文件放在src以外的目录地方，就压根访问不到（包括牛皮的绝对路径）。因此提醒大家，==类加载器里面用到的文件要全部放在src目录下面==。放在这个目录下（无论放在这个目录的那个地方）利用类加载器总是能正确的直接利用文件名访问到。 前端中的相对路径前端中的相对路径是相对于当前HTML文件而言的。这是什么意思呢？其实更精确的表达式相对于当前HTML所在路径（目录）而言的。比如来看以下几种情况简单了解一下： 如果html和要访问的资源文件（图片啊比如）在同一级目录下(同一个文件夹下，目录层级相同)，那么可以直接通过资源文件名进行访问。test.html和banner_1.jpg都在Practice目录下，因此可以直接访问 但是如果二者不在同一级目录下的话就要分情况了，如果HTML在父级目录，要访问的资源文件在更深层次的目录下。test.html所在路径的根目录是HTML，而banner_1.jpg所在目录是Practice，而这个目录是HTML下面的一个目录，因此要访问banner_1.jpg就需要到HTML目录下相应的目录里面去寻找。 如果HTML在子级目录(目录层级更深)，那么想要访问高级别的目录资源文件的话，无法通过高级别的目录名+资源文件名访问。而只能利用../返回上级目录。test.html在Parctice目录下，而banner_1.jpg在Practice的父目录HTML下，因此test.html要想访问该资源文件就需要向后退一级到父目录下才能访问到。 ==注意：在HTML中，引入资源文件的时候比如图片，相对路径前面其实都隐藏了一个当前html所在路径的目录。== ../表示的是返回上一级 ../../ 表示的是返回上两级 以此类推 ./表示的就是当前目录，可以省略不写。 ./1.jpg 跟 1.jpg 是一模一样的。 tomcat中的路径小记由于tomcat并不是在本地的，因此其路径表示也和以上几种有所不同。上面几种路径都和本地文件相关，获取的文件全都存储在本地，无论是相对路径还是绝对路径都和本地磁盘有关。但是tomcat就不一样了，它涉及项目或者资源在远端服务器部署的一个路径问题，和本地磁盘关系不大。 比如说现在有一个web项目，这个项目会存在于两个地方，一个是tomcat服务器，一个是本地的工作空间。之后通过浏览器访问web项目的时候，实际上是去寻找tomcat服务器上的项目，这个项目的路径被叫做真实路径或者文件运行路径。获取这个真实路径可以使用String getRealPath()获取。 首先来看项目在远端服务器上的一个目录结构（以Tomcat为例，注意不是在idea里面的项目结构）： 项目的根目录 ​ WEB-INF目录： ​ web.xml：web项目的核心配置文件 ​ classes目录：防止字节码文件的目录 ​ lib目录：用于存放依赖的jar包 在idea当中java代码是写在src目录下，但是这个目录在tomcat服务器中并不存在，那么java代码在服务器中存放在哪呢？是以字节码的形式存储在classes目录下。而在本地磁盘上面部署到服务器上的项目则是被放在out目录下 看一下idea上文件存放位置和在服务器上存放位置的一个对应关系 idea中： tomcat服务器中（使用ServletContext对象调用getRealPath()获取）： 由以上结果可以看出来，存放在idea的web目录下的文件在服务器上对应的是直接放在项目根路径下的；存放在idea的WEB-IF目录下的文件在服务器上对应的是存放在服务器上的WEB-INF目录下；存在在idea的src目录下的文件在服务器上对应的是存放在服务器上WEB-INF下的classes文件下 那么被发布到远程服务器的项目在本地是保存在什么地方的呢？来看一下： 每一个项目都会对应一个相应的配置（我的这些配置存放路径如下）：C:\\Users\\Administrator.IntelliJIdea2018.1\\system\\tomcat\\_base-code 再来看一下这个配置里面都有啥： 不知道啥意思？我也不知道。无所谓。接着看，进入到conf目录再进入到Catalina目录找到有个xml文件打开 有个变量：docBase,这是什么？当往服务器上发布项目的时候总得找到发布什么项目到服务器上吧，根据什么来找呢？就是根据这个docBase路径找到要发布的项目。 再进入到这个目录里面来看看： 之后这个路径里面所有的东西都会被发布到服务器上去（这是一个项目，不是零零散散的东西！），再来看看WEB-INF里面有什么东西： 看吧，这样的目录结构很熟悉吧？WEB-INF下面有classes、lib、web.xml，项目在服务器端的目录结构不就是这个样子嘛。","categories":[],"tags":[],"keywords":[]},{"title":"数据库连接池浅析","slug":"数据库连接池","date":"2019-07-08T12:20:07.647Z","updated":"2019-07-10T06:52:37.497Z","comments":true,"path":"2019/07/08/数据库连接池/","link":"","permalink":"http://yoursite.com/2019/07/08/数据库连接池/","excerpt":"","text":"数据库连接池 概念：就是一个容器，用来存放数据库连接。当系统没初始化好了之后，容器被创建，容器中会申请一些连接对象(这些连接对象已经和数据库进行了连接)，当用户访问数据库的时候，会自动从容器中获取连接对象，用户访问结束之后，会将连接对象归还给容器 好处： 1.能够节约资源 2.用户访问更加高效 实现： 标准接口：DataSource javax.sql包下的 方法： 获取链接：getConnection() 归还链接：如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，就不会再关闭连接而是归还链接。 一般由数据库厂商实现 1.C3p0 2.Druid c3p0 步骤： 导入jar包：c3p0-0.9.2.1.jar 和 mchange-commons-java-0.2.3.4 定义配置文件： 名称：c3p0.properties 或者 c3p0-config.xml。 路径：直接将文件放在src目录下即可。 创建核心对象：数据库连接池对象 ComboPooledDataSource 获取链接 getConnection 12345678//1.创建数据库连接池对象DataSource dataSource=new ComboPooledDataSource();//获取链接对象Connection connection = dataSource.getConnection();//打印System.out.println(connection); Durid 步骤： 导入jar包：druid-1.0.9.jar 定义配置文件： 是properties形式的 可以叫任意名称，可以放在任意目录下 加载配置文件。Properties 获取数据库连接池对象 通过工厂类获取：DruidDataSourceFactory 获取链接 getConnection 1234567891011121314//导入jar包//定义配置文件//利用Properties加载配置文件Properties properties=new Properties();InputStream resourceAsStream = Demo1.class.getClassLoader().getResourceAsStream(\"druid.properties\");properties.load(resourceAsStream);//获取连接池对象DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);//获取链接Connection connection = dataSource.getConnection();System.out.println(connection);","categories":[],"tags":[],"keywords":[]},{"title":"JDBC知识小结","slug":"JDBC","date":"2019-07-06T06:02:36.197Z","updated":"2019-07-11T06:04:43.188Z","comments":true,"path":"2019/07/06/JDBC/","link":"","permalink":"http://yoursite.com/2019/07/06/JDBC/","excerpt":"","text":"JDBC1. 什么是JDBC?​ JDBC的全称就是Java DataBase Connectivity ,也即是Java数据库连接。主要使用Java语言来操作数据库。它定义了一套操作所有关系型数据库的规则（其实就是接口，具体的实现由不同的数据库厂商自身提供数据库驱动JAR包），使用者可以利用JDBC进行编程操作数据库，但是实际上真正执行的代码是驱动jar包中的类。 2. 如何利用JDBC进行编程？ 步骤： 1.导入驱动jar包 复制JAR包到项目的lib目录下（自己新建如果没有的话，这个目录一般都是用来放JAR包的） 右键–&gt;add as library,将jar包加载到项目空间中 2.注册驱动 3.获取数据库连接对象：Connection 4.定义sql语句 5.获取执行SQL语句的对象：Statement 6.执行sql，接受返回结果 7.处理结果 8.释放资源 3. JDBC里的对象 DriverManager：驱动管理对象 功能： 注册驱动 1static void registerDriver(Driver driver) 使用 DriverManager注册给定的驱动程序 写代码的时候用的是：Class.forName(“com.mysql.jdbc.Driver”); 为什么不一样呢？来看Driver的源码(一看便知)： 123456789101112public class Driver extends NonRegisteringDriver implements java.sql.Driver &#123; public Driver() throws SQLException &#123; &#125; static &#123; try &#123; DriverManager.registerDriver(new Driver()); &#125; catch (SQLException var1) &#123; throw new RuntimeException(\"Can't register driver!\"); &#125; &#125;&#125; ==注意：mysql5之后的注册驱动逻辑：Class.forName(“com.mysql.jdbc.Driver”);就可以不写了==， 因为在connector JAR包里面有个文件：META-INF，里面有个文件夹services里面有个文件：java.sql.Driver。在这个文件里面有com.mysql.jdbc.Driver能够自动的进行驱动注册 获取数据库连接 1static Connection getConnection(String url, String user, String password) 尝试建立与给定数据库URL的连接。 String url：指定连接的路径 123jdbc:mysql://IP地址（域名）:3306/数据库名称如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，那么url可以简写：jdbc:mysql:///数据库名称 String user：连接数据库所用的用户名 String password：连接数据库所用的用户密码 Connection：数据库连接对象 功能： 获取执行SQL的对象 12Statement createStatement() 创建一个 Statement对象，用于将SQL语句发送到数据库 PreparedStatement prepareStatement(String sql) 创建一个 PreparedStatement对象，用于将参数化的SQL语句发送到数据库。 管理事务 开启事务： 1void setAutoCommit(boolean autoCommit):调用该方法设置参数是false,即开启事务 提交事务： 1void commit() 回滚事务： 1void rollback() Statement：用于执行静态SQL语句并返回其生成的结果的对象。 执行sql 123boolean execute(String sql):可以执行任意的sqlint executeUpdate(String sql):执行DML语句（insert,update,delete）,DDL语句（create,alter,drop）。返回值代表影响的行数，如果返回值&gt;0则执行成功，否则执行失败ResultSet executeQuery(String sql):执行DQL语句（select） ResultSet：结果集对象 boolean next():游标向下移动一行，判断当前行是否是最后一行末尾 getXxx(参数):获取数据（Xxx代表数据类型） int：代表列的编号（从1开始） String：代表列的名称 使用步骤： 游标向下移动一行 判断是否有数据 获取数据 PreparedStatement：表示预编译的SQL语句的对象。 ==sql注入问题==：在拼接sql的时候有一些sql的特殊关键字参与字符串的拼接。会造成安全性的问题。 1select * from user where username=&apos;bhjklh&apos; and password=&apos;ghjk&apos; or &apos;a&apos;=&apos;a&apos;; 例如上诉代码，虽然用户名和密码都是随便输入的，判断结果是false，但是最后的or却返回true，因此结果返回true，造成登录安全性问题。 解决sql注入：使用PreparedStatement。 预编译的SQL：参数使用占位符：? 替代。 使用步骤： 1.导入驱动jar包 2.注册驱动 3.获取数据库连接对象：Connection 4.定义sql语句 ==注意：==sql的参数使用?作为占位符 5.获取执行SQL语句的对象：PreparedStatement Connection.preparedStatement(String sql) 给?赋值：setXxx(参数1，参数2) ​ 参数1：？的位置编号。从1开始 ​ 参数2：？的值 6.执行sql，接受返回结果 7.处理结果 8.释放资源 ==注意：==后期都会使用PreparedStatement来完成增删改查 1.可以防止SQL注入 2.效率更高 4. JDBC操作事务 开启事务 setAutoCommit(boolean autoCommit)：调用该方法设置参数为false,开启事务 在执行sql之前开启事务 提交事务 commit() 当所有的sql都执行完了再提交事务 回滚事务 rollback() 在catch中回滚事务 5. JDBC Template Spring框架对JDBC进行了简单封装。提供了JDBC Template来简化JDBC的开发 步骤： 导入jar包 创建jdbcTemplate对象，依赖于数据源DataSource 获取数据源对象dataSource JdbcTemplate template=new JdbcTemplate(dataSource); 调用JdbcTemplate来完成CRUD的操作 update()：执行DML语句。增删改语句。 queryForMap()：查询结果，将结果集封装map集合，列名为key,值为value ==注意：==这个方法的查询结果集只能是1 queryForList()：查询结果，将结果集封装list集合 ==注意：==将每一条记录封装为一个Map集合，再将Map集合封装为List集合 query()：查询结果，将结果等装成JavaBean对象 ==注意：==query的参数：RowMapper 一般使用BeanPropertyRowMapper实现类，可以完成数据到JavaBean(必须是标准的)的自动封装。 2. new BeanPropertyRowMapper&lt;类型&gt;(类型.class) queryForObject：查询结果，将结果封装为对象 ==注意：==一般用于聚合函数的查询","categories":[],"tags":[],"keywords":[]},{"title":"mysql知识浅析2","slug":"mysql2","date":"2019-07-02T06:53:43.659Z","updated":"2019-08-30T11:44:44.527Z","comments":true,"path":"2019/07/02/mysql2/","link":"","permalink":"http://yoursite.com/2019/07/02/mysql2/","excerpt":"","text":"1. 多表之间的关系1.1 分类 ​ 一对一 人和身份证 分析：一个人只有一个身份证，一个身份证只能对应一个人 ​ 一对多（多对一） 部门和员工 分析：一个部门有多个员工，一个员工只能对应一个部门 ​ 多对多 学生和课程 分析：一个学生可以选择多门课程，一个课程可以被很多学生选择 1.2 实现关系 ​ 一对多（多对一） 如：部门和员工 实现方式：在多的一方建立外键，指向一的一方的主键 多对多 如：学生和课程 实现方式：多对多的关系实现需要借助第三张中间表，中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。 一对一 人和身份证 实现方式：可以在任意一方添加唯一外键指向另一方的主键 2. 范式2.1 概念​ 设计数据库的时候需要遵守的一些规范。 ​ 设计关系数据库的时候，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余度越小 2.2 分类​ 目前关系型数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式（4NF）以及第五范式（5NF），也被称为完美范式。 第一范式（1NF）：每一项都是不可再分的原子数据项 第二范式（2NF）：在1NF的基础上，非码属性完全依赖于码属性（在1NF的基础上消除了非主属性对主码的部分函数依赖） 第三范式（3NF）：在2NF的基础上，任何非主属性不依赖于其他非主属性（在2NF基础上消除了传递依赖） 相关的几个概念： 函数依赖：A–&gt;B 通过A属性（属性组）的值可以唯一确定B属性的值。 学号–&gt;姓名 （学号，课程名）–&gt;分数 完全函数依赖：A–&gt;B B属性的值确定需要依赖于A属性组全部的值。 （学号，课程名）–&gt;分数 部分函数依赖：A–&gt;B B属性的值确定需要依赖于A属性组部分的值。 （学号，课程名）–&gt;姓名 传递函数依赖：A–&gt;B,B–&gt;C 通过A属性（属性组）的值可以为一确定B属性的值，再通过B属性（属性组）的值可以唯一确定C属性的值，则称C传递函数依赖于A 学号–&gt;系名称，系名称–&gt;系主任 码：如果在一张表中，一个属性或者属性组被其他所有属性完全依赖，就称这个属性（属性组）是该表的码 主属性：码属性组中的所有属性 非主属性：其他除了码属性组的属性 ​ 3. 多表查询3.1 笛卡尔积​ 有两个集合A,B，取这两个集合的所有组成情况。 3.2 内连接查询（解决笛卡尔积中无用的数据） 隐式内连接：使用where条件消除无用数据 1234567891011121314查询所有员工信息和对应部门信息 SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;查询员工表的名称，性别，部门表的名称 SELECT emp.`name`,emp.`gender`,dept.`name` FROM emp,dept WHERE emp.`dept_id` = dept.`id`; SELECT t1.name, t1.gender, t2.name FROM emp t1, dept t2 WHERE t1.dept_id=t2.id; 显式内连接 123select 字段列表 from 表名1 [inner] join 表名2 on 条件 select * from emp inner join dept on emp.dept_id = dept.id; 3.3 外连接查询（为了获取交集以外的数据） 左外连接：查询的是左表所有记录（表1）以及其交集部分（on条件判断） 1234567891011select 字段列表 from 表1 left [outer] join 表2 on 条件 SELECT t1.*, t2.name FROM emp t1, LEFT JOIN dept t2 ON t1.dept_id=t2.id; 右外连接：查询的是右表所有记录（表2）以及其交集部分（on条件判断） 1234567891011select 字段列表 from 表1 left [outer] join 表2 on 条件 SELECT t1.*, t2.name FROM emp t1, RIGHT JOIN dept t2 ON t1.dept_id=t2.id; 3.4 子查询​ 查询中嵌套查询，称嵌套的查询是子查询。也就是将一条查询语句的结果当做另外一条查询语句的条件。 3.4.1 子查询的结果是单行单列的 子查询可以作为条件，使用运算符进行判断。运算符：&gt; &gt;= &lt; &lt;= =… 12-- 查询工资最高的员工信息SELECT * FROM emp WHERE emp.salary=(SELECT MAX(salary) FROM emp); 3.4.2 子查询的结果是多行单列的 子查询作为条件，使用运算符 IN 进行判断 123456789-- 查询财务部和市场部的所有员工信息思路： SELECT id FROM dept WHERE NAME=&quot;财务部&quot; OR NAME=&quot;市场部&quot;; -- 查询处部门的id SELECT * FROM emp WHERE dept_id =3 OR dept_id=2; -- 查询对应id的所有信息 SELECT * FROM emp WHERE dept_id IN(2,3); -- 改进 成型代码： SELECT * FROM emp WHERE dept_id IN(SELECT id FROM dept WHERE NAME=&quot;财务部&quot; OR NAME=&quot;市场部&quot;); SELECT * FROM emp WHERE dept_id IN(SELECT id FROM dept WHERE NAME IN (&quot;财务部&quot;,&quot;市场部&quot;));-- 改进 3.4.3 子查询的结果是多行多列的 子查询可以作为一张虚拟表，进行一个表的查询 12345-- 查询员工入职日期是2011-11-11之后的员工信息和部门信息 SELECT * FROM dept , (SELECT * FROM dept WHERE emp.`join_date` &gt; &apos;2011-11-11&apos;) AS dept2 WHERE dept.id = dept2.dept_id; -- 普通内连接查询 SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id`=t2.`id` AND t1.`join_date`&gt;&apos;2011-11-11&apos;; 4. 事务4.1 事务的基本介绍 概念：如果一个包含多个业务步骤的操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 操作： 开启事务：start transcation 回滚：rollback 提交：commit 事务提交的两种方式 手动提交：需要先开启事务，再提交。进行增删改的操作之后，一定要用commit进行提交。Oracle默认手动提交事务。 自动提交：MySQL数据库中，事务默认自动提交。一条DML语句会自动提交一次事务 修改事务的默认提交方式 查看事务的默认提交方式： 123select @@autocommit;-- 1:自动提交-- 0:手动提交 修改默认提交方式： 1set @@autocommit = 0; 4.2 事务的四大特征 原子性：不可分割的最小操作单位，要么同时成功要么同时失败 持久性：事务一旦提交或者回滚，数据库会持久化的保存数据 隔离性：多个事物之间相互独立 一致性：事务操作前后，数据总量不变 4.3 事务的隔离级别 概念：多个事物之间是隔离、相互独立的。但是如果多个事务操作同一批数据，就会引发一些问题。设置不同 的隔离级别就可以解决这样的问题 问题 脏读：一个事务读取到另外一个事务中没有提交的数据 不可重复读：在同一个事务中，两次读取到的数据不一样 幻读：一个事务操作（DML）数据表中所有记录，另一个事务添加了一条数据，那么第一个事务查询不到自己的修改 隔离级别 read uncommited：读未提交的事务 产生的问题：脏读，不可重复读，幻读 read commited：读已提交（Oracle默认） 产生的问题：不可重复读，幻读 repeatable：可重复读（MySQL默认） 产生的问题：幻读 serializable：串行化 不会产生问题 ==隔离级别从小到大安全性越来越高，效率越来越低== 数据库查询隔离级别 1select @@tx_isolation; 数据库设置隔离级别 1set global transaction isolation level 隔离级别字符串; 5. DCL 管理用户 添加用户： 1CREATE USER &apos;用户名&apos;@&apos;主机名&apos; IDENTIFIED BY &apos;密码&apos;; ==主机名是 % 的时候代表可以在任意主机上进行登陆== 删除用户： 1DROP USER &apos;用户名&apos;@&apos;主机名&apos;; 修改用户密码： 12UPDATE USER SET PASSWORD = PASSWORD(&apos;新密码&apos;) WHERE USER = &apos;用户名&apos;;SET PASSWORD FOR &apos;用户名&apos;@&apos;主机名&apos; = PASSWORD(&apos;新密码&apos;); ==mysql中忘记了root的密码？== 1.cmd–&gt;net stop mysql(需要以管理员的身份运行) 2.使用无验证方式启动mysql服务 1mysqld --skip-grant-tables 3.然后直接mysql就可以登录成功，在进行修改用户密码操作。之后关闭两个cmd窗口 4.打开任务管理器，找到mysqld服务，手动结束 5.再次通过管理员的方式打开cmd，启动mysql服务 6.可以通过新密码进行登陆 查询用户： 12341.切换到mysql数据库 use mysql;2.查询user表 select * from user; 权限管理 查询权限： 1SHOW GRANTS FOR &apos;用户名&apos;@&apos;主机名&apos;; 授予权限： 123GRANT 权限列表 ON 数据库名.表名 TO &apos;用户名&apos;@&apos;主机名&apos;;GRANT ALL ON *.* TO &apos;用户名&apos;@&apos;主机名&apos;; 撤销权限： 1REVOKE 权限列表 ON 数据库名.表名 FROM &apos;用户名&apos;@&apos;主机名&apos;;","categories":[],"tags":[],"keywords":[]},{"title":"MySql知识浅析1","slug":"mysql1","date":"2019-06-30T12:15:14.006Z","updated":"2019-07-10T10:19:46.894Z","comments":true,"path":"2019/06/30/mysql1/","link":"","permalink":"http://yoursite.com/2019/06/30/mysql1/","excerpt":"","text":"[TOC] SQL1.什么是SQL？​ Structured Query Language：结构化查询语言​ 其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 2.SQL通用语法1. SQL 语句可以单行或多行书写，以分号结尾。 2. 可使用空格和缩进来增强语句的可读性。 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 4. 多种注释 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: / 注释 / 3.SQL分类1) DDL(Data Definition Language)数据定义语言 ​ 用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等 2) DML(Data Manipulation Language)数据操作语言 ​ 用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等 3) DQL(Data Query Language)数据查询语言 ​ 用来查询数据库中表的记录(数据)。关键字：select, where 等 4) DCL(Data Control Language)数据控制语言(了解) ​ 用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等 4.MySQL MySQL服务启动 123451. 手动。2. cmd--&gt; services.msc 打开服务的窗口3. 使用管理员打开cmd - net start mysql : 启动mysql的服务 - net stop mysql:关闭mysql服务 MySQL登录 1231. mysql -uroot -p密码2. mysql -hip -uroot -p连接目标的密码3. mysql --host=ip --user=root --password=连接目标的密码 MySQL退出 121. exit2. quit DDL:操作数据库、表1.操作数据库：CRUD1.1 C (Create):创建123create database 数据库名称;create database if not exists 数据库名称;create database 数据库名称 character set 字符集名称; 1.2 R (Retrieve):查询1234查询所有数据库名称 show databases; 查看某个数据库的创建语句 show create database 数据库名称; 1.3 U (Update):修改12修改数据库的字符集 alter database 数据库名称 character set 字符集名称; 1.4 D (Delete):删除1234删除数据库 drop database 数据库名称;判断数据库存在再删除 drop database if exists 数据库名称; 1.5 使用数据库1234查询当前正在使用的数据库名称 select database();使用数据库 use 数据库名称; 2.操作表：CRUD、复制表2.1 C (Create):创建123456create table 表名( 列名1 数据类型1, 列名2 数据类型2, ... 列名n 数据类型n); ==数据类型：== int：整数类型 double(m,n):小数类型。m：整数部分 n：小数部分 date:日期，只包含年月日，yyyy-MM-dd datetime:日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp:时间错类型 包含年月日时分秒 yyyy-MM-dd HH:mm:ss 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值 varchar:字符串 2.2 R (Retrieve):查询1234查询某个数据库中的所有表名称 show tables;查询表结构 desc 表名称; 2.3 U (Update):修改1234567891011修改表名 alter table 表名 rename to 新的表名;修改表的字符集 alter table 表名 character set 字符集名称;添加一列 alter table 表名 add 列名 数据类型;修改列名称、类型 alter table 表名 change 列名 新列名 新数据类型; alter table 表名 modify 列名 新数据类型;删除列 alter table 表名 drop 列名; 2.4 D (Delete):删除12drop table 表名;drop table if exists 表名; 2.5 复制表1create table 表名 like 要复制的表名; DML:增删改表数据1.添加数据1insert into 表名(列名1,列名2,...列名n) values (值1,值2,...值n) ==注意：== ​ 列名和值要一一对应 ​ 如果表名后不定义列名就默认给所有的列添加值 ​ 除了数字类型，其他类型需要使用引号（单双都可以） 2.删除数据1234删除数据 delete from 表名[where 条件]删除表中全部数据，并创建一个一模一样的空表（无法根据条件进行删除） truncate table 表名; ==注意：== ​ 如果不添加条件，就会删除表中所有记录 ​ 如果要删除所有记录 ​ delete from 表名; 不推荐使用。有多少条记录就会执行多少次删除操作。删除完一个元素后，如果有自动增长属性，数字不会复位 ​ truncate table 表名; 先删除表，再创建一个一模一样的空表，推荐使用，效率更高。 以后再工作的时候，发现id跳号了怎么办？ 不要去管他，因为这种现象很常见 建议：在后期维护的时候出现这种情况，不要去管他。如果第一次往里存放数据的时候，就出现该情况，建议检查一下代码是否有bug。 3.修改数据1update 表名 set 列名1=值1,列名2=值2,列名3=值3....[where 条件] ==注意：== ​ 如果不添加条件，所有记录都会被修改 DQL:查询表中的记录1.完整语法：1234567891011121314select 字段列表from 表名列表where 条件列表group by 分组字段having 分组之后的条件order by 排序规则limit 分页限定 2.基础查询2.1 多个字段的查询1select 字段名1,字段名2,字段名3... from 表名 ==注意：== ​ 如果查询所有字段，就可以用*来代替字段列表 2.2 去除重复12关键字：distinctselect distinct 字段名1,字段名2,字段名3... from 表名 2.3 计算列123456一般可以使用四则运算计算列的值（一般只会进行数值类型的计算）ifnull(表达式1，表达式2)：null参与运算，结果都是null 表达式1：哪个字段需要判断是否为null 表达式2：如果该字段是null之后需要替换的值 SELECT NAME,math,english,math+IFNULL(english,0) 总分 FROM person; 2.4 起别名123关键字：as(也可以省略，用空格代替)select distinct 字段名1 as 别名,字段名2 as 别名,字段名3 as 别名... from 表名SELECT DISTINCT address as 地址 FROM person; 3.条件查询3.1 where子句后面跟条件3.2 运算符123456789101112131415161718192021222324&gt;、&lt;、&lt;=、&gt;=、=、&lt;&gt; SELECT * FROM student WHERE english&gt;=60; BETWEEN...AND SELECT * FROM student WHERE age BETWEEN 20 AND 30; IN(集合) SELECT * FROM student WHERE math IN(66,98,99,76,56); LIKE SELECT * FROM student WHERE NAME LIKE &quot;马%&quot;; IS (NOT) NULL:查询某一列为null的值（不能写 =(!=)null） SELECT * FROM student WHERE english IS NULL; SELECT * FROM student WHERE english IS NOT NULL; and 或 &amp;&amp; SELECT * FROM student WHERE english&gt;=75 AND math IN(66,98,99,76,56); or 或 || SELECT * FROM student WHERE english&gt;=75 OR math IN(66,98,99,76,56); not 或 ! SELECT * FROM student WHERE english !=75 AND math IN(66,98,99,76,56); 4.模糊查询（LIKE） 占位符： _：单个任意字符 %：多个任意字符 12345LIKE SELECT * FROM student WHERE NAME LIKE &quot;%马%&quot;; SELECT * FROM student WHERE NAME LIKE &quot;马%&quot;; SELECT * FROM student WHERE NAME LIKE &quot;马_&quot;; SELECT * FROM student WHERE NAME LIKE &quot;_德&quot;; 5.排序查询(order by)12345order by 排序字段1 排序方式1,排序字段2 排序方式2... SELECT * FROM person ORDER BY math;/*默认升序*/ SELECT * FROM person ORDER BY math ASC;/*升序排序*/ SELECT * FROM person ORDER BY math DESC;/*降序排序*/ SELECT * FROM person ORDER BY math ASC,english ASC;/*多字段排序*/ ==注意：== ​ 第二排序条件只有当第一排序条件结果一样的时候才会执行 6.聚合函数：​ 将一列数据作为一个整体，进行纵向的计算 12345678910111213141516171819count：计算个数 SELECT COUNT(字段) FROM 表名; SELECT COUNT(english) FROM person; max：计算最大值 SELECT MAX(字段) FROM 表名; SELECT MAX(math) FROM person; min：计算最小值 SELECT MIN(字段) FROM 表名; SELECT MIN(math) FROM person; sum：计算和 SELECT SUM(字段) FROM 表名; SELECT SUM(math) FROM person; avg：计算平均值 SELECT AVG(字段) FROM 表名; SELECT AVG(math) FROM person; ==注意：== 聚合函数的计算排除了null值 如何解决？ ​ 1. IFNULL ​ SELECT COUNT(IFNULL(english,0)) FROM person; ​ 2. 选择不包含NULL的列(一般是主键)进行计算 7.分组查询(group by)123456789按照性别分组，查询数学平均成绩，并统计个数 SELECT sex,SUM(math),COUNT(id) FROM person GROUP BY sex; 按照性别分组，分别查询男女同学的数学平均分和人数，要求：分数低于70分的人不参与分组 SELECT sex,AVG(math),COUNT(id) FROM person WHERE math&gt;70 GROUP BY sex; 按照性别分组，分别查询男女同学的数学平均分和人数，要求：分数低于70分的人不参与分组，分组之后人数要大于两个人。 SELECT sex,AVG(math),COUNT(id) FROM person WHERE math&gt;70 GROUP BY sex HAVING COUNT(id)&gt;2; SELECT sex,AVG(math),COUNT(id) 人数 FROM person WHERE math&gt;70 GROUP BY sex HAVING 人数&gt;2; ==注意：== 1.分组之后查询的字段：分组字段、聚合函数 2.where和having的区别： where在分组之前进行限定，如果不满足条件，就不参与分组。后面不可以跟聚合函数。 having在分组之后进行限定，如果不满足条件，就不会被查询。后面可以加聚合函数。 ​ 8.分页查询(limit，mysql的方言)1234语法：limit 开始的索引 每页查询的条数 SELECT * FROM person LIMIT 0,3; --第一页查询3条语句 SELECT * FROM person LIMIT 3,3; --第二页查询3条语句 SELECT * FROM person LIMIT 6,3; --第三页查询3条语句 ==注意：== 开始的索引=（当前页码-1）*每页显示条数 约束1. 概念​ 对表中的数据进行限定，保证数据的正确性、有效性以及完整性。 2. 分类 ​ 主键约束：primary key ​ 非空约束：not null ​ 唯一约束：unique ​ 外键约束：foreign key 3.非空约束：not null特点：值不能为null 1.创建表的时候添加约束 1234CREATE TABLE stu( id INT, NAME VARCHAR(20) NOT NULL -- name非空); 2.创建表之后添加非空约束 1ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 3.删除非空约束 1ALTER TABLE stu MODIFY NAME VARCHAR(20); 4. 唯一约束：unique特点：值不能重复，可以为null 1.创建表的时候添加约束 1234CREATE TABLE stu( id INT, phoneNumber VARCHAR(20) UNIQUE); 2.创建表之后添加约束 1ALTER TABLE stu MODIFY phonenumber VARCHAR(20) UNIQUE; 3.删除约束 1ALTER TABLE stu DROP INDEX phonenumber; 5. 主键约束：primary key特点：非空且唯一，一张表只能由一个字段是主键 1.创建表的时候添加约束 1234CREATE TABLE stu( id INT PRIMARY KEY, phoneNumber VARCHAR(20)); 2.创建表之后添加约束 1ALTER TABLE stu MODIFY id INT PRIMARY KEY; 3.删除约束 1ALTER TABLE stu DROP PRIMARY KEY; 4.自动增长 ​ 如果某一列是数值类型的，使用auto_increment可以来完成值得自动增长。一般会和主键共同使用 ​ 4.1 创建表的时候添加 1234CREATE TABLE stu( id INT PRIMARY KEY AUTO_INCREMENT, phoneNumber VARCHAR(20)); ​ 4.2 创建表之后添加 1ALTER TABLE stu MODIFY id INT AUTO_INCREMENT; ​ 4.3 删除 1ALTER TABLE stu MODIFY id INT; 6. 外键约束：foreign key 创建表的时候添加 123456789101112131415161718192021222324CREATE TABLE 表名( ... 外键列, CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列名称));-- 创建部门表(id,dep_name,dep_location)-- 一方，主表 CREATE TABLE department( id INT PRIMARY KEY AUTO_INCREMENT, dep_name VARCHAR(20), dep_location VARCHAR(20) ); -- 创建员工表(id,name,age,dep_id)-- 多方，从表 CREATE TABLE employee( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(20), age INT, dep_id INT, -- 外键列/外键名称 CONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id) ); 删除外键 12ALTER TABLE 表名 DROP FOREIGN KEY 外键名称; ALTER TABLE employee DROP FOREIGN KEY emp_dept_id; 创建表之后添加 12ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列名称); ALTER TABLE employee ADD CONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id); 7. 外键约束–级联操作添加外键，设置级联更新(ON UPDATE CASCADE)(修改一张表的外键数据，其他关联的也会自动变化) 12ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE; ALTER TABLE employee ADD CONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id) ON UPDATE CASCADE; 级联删除(ON DELETE CASCADE)（把对应id的部门删除，那么相应部门id的员工也都会被删除） 12ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名称(主表列名称) ON DELETE CASCADE; ALTER TABLE employee ADD CONSTRAINT emp_dept_id FOREIGN KEY (dep_id) REFERENCES department(id) ON DELETE CASCADE;","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"复制多级文件夹","date":"2019-06-23T05:51:48.128Z","updated":"2019-06-23T06:05:54.670Z","comments":true,"path":"2019/06/23/复制多级文件夹/","link":"","permalink":"http://yoursite.com/2019/06/23/复制多级文件夹/","excerpt":"","text":"1title: 复制多级文件夹 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class CopyFiles &#123; public static void main(String[] args) throws IOException &#123; //首先进行源文件和目的文件路径的封装 File sourceFile=new File(\"D:\\\\a\"); //这里的目的路径也可以改成手动键盘录入的形式，很简单，不在赘述 File destinationFile=new File(\"E:\\\\\",sourceFile.getName()); //调用复制方法，第一个参数是源文件，第二个参数是目的地文件 copyFiles(sourceFile,destinationFile); &#125; private static void copyFiles(File sourceFile,File destinationFile) throws IOException &#123; //首先先将目的文件夹新建了再说，肯定不会出错 destinationFile.mkdir(); //其次列出源文件夹下的所有东西 File[] files = sourceFile.listFiles(); //遍历文件夹里面的每一项 for (File file:files) &#123; //判断便利的到的是不是目录 if (file.isDirectory())&#123; //如果是目录的话，就利用迭代循环遍历 copyFiles(file,new File(destinationFile,file.getName())); &#125;else &#123; //如果不是目录的话说明是文件，就直接进行文件内容的读写复制 //以遍历得到的文件为源文件进行复制 BufferedInputStream br=new BufferedInputStream(new FileInputStream(file)); //复制目的地。目的地文件的路径是源目的地和遍历的到的文件名称拼接而成的路径 BufferedOutputStream bw=new BufferedOutputStream(new FileOutputStream(new File(destinationFile,file.getName()))); //开始进行读写数据 int str; while ((str=br.read())!=-1)&#123; bw.write(str); &#125; br.close(); bw.close(); &#125; &#125; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"","slug":"递归和文件","date":"2019-06-20T01:54:45.356Z","updated":"2019-06-20T02:52:58.862Z","comments":true,"path":"2019/06/20/递归和文件/","link":"","permalink":"http://yoursite.com/2019/06/20/递归和文件/","excerpt":"","text":"1.递归1.1递归【应用】 递归的介绍 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算 递归的基本使用 1234567891011121314151617181920212223242526272829303132public class DiGuiDemo &#123; public static void main(String[] args) &#123; //回顾不死神兔问题，求第20个月兔子的对数 //每个月的兔子对数：1,1,2,3,5,8，... int[] arr = new int[20]; arr[0] = 1; arr[1] = 1; for (int i = 2; i &lt; arr.length; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; System.out.println(arr[19]); System.out.println(f(20)); &#125; /* 递归解决问题，首先就是要定义一个方法： 定义一个方法f(n)：表示第n个月的兔子对数 那么，第n-1个月的兔子对数该如何表示呢？f(n-1) 同理，第n-2个月的兔子对数该如何表示呢？f(n-2) StackOverflowError:当堆栈溢出发生时抛出一个应用程序递归太深 */ public static int f(int n) &#123; if(n==1 || n==2) &#123; return 1; &#125; else &#123; return f(n - 1) + f(n - 2); &#125; &#125;&#125; 递归的注意事项 递归一定要有出口。否则内存溢出 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出 1.2递归求阶乘【应用】 案例需求 ​ 用递归求5的阶乘，并把结果在控制台输出 代码实现 1234567891011121314151617181920public class DiGuiDemo01 &#123; public static void main(String[] args) &#123; //调用方法 int result = jc(5); //输出结果 System.out.println(\"5的阶乘是：\" + result); &#125; //定义一个方法，用于递归求阶乘，参数为一个int类型的变量 public static int jc(int n) &#123; //在方法内部判断该变量的值是否是1 if(n == 1) &#123; //是：返回1 return 1; &#125; else &#123; //不是：返回n*(n-1)! return n*jc(n-1); &#125; &#125;&#125; 1.3递归遍历目录【应用】 案例需求 ​ 给定一个路径(E:\\itcast)，通过递归完成遍历该目录下所有内容，并把所有文件的绝对路径输出在控制台 代码实现 1234567891011121314151617181920212223242526272829public class DiGuiDemo02 &#123; public static void main(String[] args) &#123; //根据给定的路径创建一个File对象// File srcFile = new File(\"E:\\\\itcast\"); File srcFile = new File(\"E:\\\\itheima\"); //调用方法 getAllFilePath(srcFile); &#125; //定义一个方法，用于获取给定目录下的所有内容，参数为第1步创建的File对象 public static void getAllFilePath(File srcFile) &#123; //获取给定的File目录下所有的文件或者目录的File数组 File[] fileArray = srcFile.listFiles(); //遍历该File数组，得到每一个File对象 if(fileArray != null) &#123; for(File file : fileArray) &#123; //判断该File对象是否是目录 if(file.isDirectory()) &#123; //是：递归调用 getAllFilePath(file); &#125; else &#123; //不是：获取绝对路径输出在控制台 System.out.println(file.getAbsolutePath()); &#125; &#125; &#125; &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"IO流--字节流","slug":"IO流","date":"2019-06-20T01:54:45.356Z","updated":"2019-06-22T03:27:51.639Z","comments":true,"path":"2019/06/20/IO流/","link":"","permalink":"http://yoursite.com/2019/06/20/IO流/","excerpt":"","text":"IO流IO流概述和分类【理解】 IO流介绍 IO：输入/输出(Input/Output) 流：是一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输称为流，流的本质是数据传输 IO流就是用来处理设备间数据传输问题的。常见的应用：文件复制；文件上传；文件下载 IO流的分类 按照数据的流向 输入流：读数据 输出流：写数据 按照数据类型来分 字节流 字节输入流 字节输出流 字符流 字符输入流 字符输出流 IO流的使用场景 如果操作的是纯文本文件，优先使用字符流 如果操作的是图片、视频、音频等二进制文件。优先使用字节流 如果不确定文件类型，优先使用字节流。字节流是万能的流 字节流 字节流抽象基类 InputStream：这个抽象类是表示字节输入流的所有类的超类 OutputStream：这个抽象类是表示字节输出流的所有类的超类 子类名特点：子类名称都是以其父类名作为子类名的后缀 字节输出流 FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 使用字节输出流写数据的步骤 创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件) 调用字节输出流对象的写数据方法 释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源) 示例代码 12345678910111213141516171819202122public class FileOutputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象 //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); /* 做了三件事情： A:调用系统功能创建了文件 B:创建了字节输出流对象 C:让字节输出流对象指向创建好的文件 */ //void write(int b)：将指定的字节写入此文件输出流 fos.write(97);// fos.write(57);// fos.write(55); //最后都要释放资源 //void close()：关闭此文件输出流并释放与此流相关联的任何系统资源。 fos.close(); &#125;&#125; 字节流写数据的三种方式【应用】 写数据的方法分类 | 方法名 | 说明 || —————————————- | ———————————————————— || void write(int b) | 将指定的字节写入此文件输出流 一次写一个字节数据 || void write(byte[] b) | 将 b.length字节从指定的字节数组写入此文件输出流 一次写一个字节数组数据 || void write(byte[] b, int off, int len) | 将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流 一次写一个字节数组的部分数据 | 示例代码 123456789101112131415161718192021222324252627282930313233public class FileOutputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //FileOutputStream(String name)：创建文件输出流以指定的名称写入文件 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); //new File(name)// FileOutputStream fos = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //FileOutputStream(File file)：创建文件输出流以写入由指定的 File对象表示的文件// File file = new File(\"myByteStream\\\\fos.txt\");// FileOutputStream fos2 = new FileOutputStream(file);// FileOutputStream fos2 = new FileOutputStream(new File(\"myByteStream\\\\fos.txt\")); //void write(int b)：将指定的字节写入此文件输出流// fos.write(97);// fos.write(98);// fos.write(99);// fos.write(100);// fos.write(101);// void write(byte[] b)：将 b.length字节从指定的字节数组写入此文件输出流// byte[] bys = &#123;97, 98, 99, 100, 101&#125;; //byte[] getBytes()：返回字符串对应的字节数组 byte[] bys = \"abcde\".getBytes();// fos.write(bys); //void write(byte[] b, int off, int len)：将 len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流// fos.write(bys,0,bys.length); fos.write(bys,1,3); //释放资源 fos.close(); &#125;&#125; 字节流写数据的两个小问题【应用】 字节流写数据如何实现换行 windows:\\r\\n linux:\\n mac:\\r 字节流写数据如何实现追加写入 public FileOutputStream(String name,boolean append) 创建文件输出流以指定的名称写入文件。如果第二个参数为true ，则字节将写入文件的末尾而不是开头 示例代码 12345678910111213141516public class FileOutputStreamDemo03 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输出流对象// FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\fos.txt\",true); //写数据 for (int i = 0; i &lt; 10; i++) &#123; fos.write(\"hello\".getBytes()); fos.write(\"\\r\\n\".getBytes()); &#125; //释放资源 fos.close(); &#125;&#125; 字节流写数据加异常处理【应用】 异常处理格式 try-catch-finally 1234567try&#123; 可能出现异常的代码;&#125;catch(异常类名 变量名)&#123; 异常的处理代码;&#125;finally&#123; 执行所有清除操作;&#125; finally特点 被finally控制的语句一定会执行，除非JVM退出 示例代码 1234567891011121314151617181920public class FileOutputStreamDemo04 &#123; public static void main(String[] args) &#123; //加入finally来实现释放资源 FileOutputStream fos = null; try &#123; fos = new FileOutputStream(\"myByteStream\\\\fos.txt\"); fos.write(\"hello\".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 字节流读数据(一次读一个字节数据)【应用】 字节输入流 FileInputStream(String name)：通过打开与实际文件的连接来创建一个FileInputStream ，该文件由文件系统中的路径名name命名 字节输入流读取数据的步骤 创建字节输入流对象 调用字节输入流对象的读数据方法 释放资源 原理图 示例代码 1234567891011121314151617181920public class FileInputStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 //FileInputStream(String name) FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); int by; /* fis.read()：读数据 by=fis.read()：把读取到的数据赋值给by by != -1：判断读取到的数据是否是-1 */ while ((by=fis.read())!=-1) &#123; System.out.print((char)by); &#125; //释放资源 fis.close(); &#125;&#125; 字节流复制文本文件【应用】 案例需求 ​ 把“E:\\itcast\\窗里窗外.txt”复制到模块目录下的“窗里窗外.txt” 实现步骤 复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地) 数据源： ​ E:\\itcast\\窗里窗外.txt — 读数据 — InputStream — FileInputStream 目的地： ​ myByteStream\\窗里窗外.txt — 写数据 — OutputStream — FileOutputStream 代码实现 123456789101112131415161718public class CopyTxtDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\窗里窗外.txt\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\窗里窗外.txt\"); //读写数据，复制文本文件(一次读取一个字节，一次写入一个字节) int by; while ((by=fis.read())!=-1) &#123; fos.write(by); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 字节流读数据(一次读一个字节数组数据)【应用】 一次读一个字节数组的方法 public int read(byte[] b)：从输入流读取最多b.length个字节的数据 返回的是读入缓冲区的总字节数,也就是实际的读取字节个数 原理图 示例代码 12345678910111213141516171819202122232425public class FileInputStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字节输入流对象 FileInputStream fis = new FileInputStream(\"myByteStream\\\\fos.txt\"); /* hello\\r\\n world\\r\\n 第一次：hello 第二次：\\r\\nwor 第三次：ld\\r\\nr */ byte[] bys = new byte[1024]; //1024及其整数倍 int len; while ((len=fis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 fis.close(); &#125;&#125; 字节流复制图片【应用】 案例需求 ​ 把“E:\\itcast\\mn.jpg”复制到模块目录下的“mn.jpg” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) 释放资源 代码实现 12345678910111213141516171819public class CopyJpgDemo &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字节输入流对象 FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\mn.jpg\"); //根据目的地创建字节输出流对象 FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\mn.jpg\"); //读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组) byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) &#123; fos.write(bys,0,len); &#125; //释放资源 fos.close(); fis.close(); &#125;&#125; 字节缓冲流 字节缓冲流介绍 lBufferOutputStream：该类实现缓冲输出流。 通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用 lBufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。 当从流中读取或跳过字节时，内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节 构造方法： | 方法名 | 说明 | | ————————————– | ———————- | | BufferedOutputStream(OutputStream out) | 创建字节缓冲输出流对象 | | BufferedInputStream(InputStream in) | 创建字节缓冲输入流对象 | 字节缓冲流一次读取一个字节流程图： 字节缓冲流一次读取一个字节数组流程图： 示例代码 1234567891011121314151617181920212223242526272829303132public class BufferStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //字节缓冲输出流：BufferedOutputStream(OutputStream out) BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\bos.txt\")); //写数据 bos.write(\"hello\\r\\n\".getBytes()); bos.write(\"world\\r\\n\".getBytes()); //释放资源 bos.close(); //字节缓冲输入流：BufferedInputStream(InputStream in) BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"myByteStream\\\\bos.txt\")); //一次读取一个字节数据// int by;// while ((by=bis.read())!=-1) &#123;// System.out.print((char)by);// &#125; //一次读取一个字节数组数据 byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; System.out.print(new String(bys,0,len)); &#125; //释放资源 bis.close(); &#125;&#125; 字节缓冲流复制视频【应用】 案例需求 把“E:\\itcast\\字节流复制图片.avi”复制到模块目录下的“字节流复制图片.avi” 实现步骤 根据数据源创建字节输入流对象 根据目的地创建字节输出流对象 读写数据，复制视频 释放资源 代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class CopyAviDemo &#123; public static void main(String[] args) throws IOException &#123; //记录开始时间 long startTime = System.currentTimeMillis(); //复制视频// method1();// method2();// method3(); method4(); //记录结束时间 long endTime = System.currentTimeMillis(); System.out.println(\"共耗时：\" + (endTime - startTime) + \"毫秒\"); &#125; //字节缓冲流一次读写一个字节数组 public static void method4() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); byte[] bys = new byte[1024]; int len; while ((len=bis.read(bys))!=-1) &#123; bos.write(bys,0,len); &#125; bos.close(); bis.close(); &#125; //字节缓冲流一次读写一个字节 public static void method3() throws IOException &#123; BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\")); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\")); int by; while ((by=bis.read())!=-1) &#123; bos.write(by); &#125; bos.close(); bis.close(); &#125; //基本字节流一次读写一个字节数组 public static void method2() throws IOException &#123; //E:\\\\itcast\\\\字节流复制图片.avi //模块目录下的 字节流复制图片.avi FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\"); byte[] bys = new byte[1024]; int len; while ((len=fis.read(bys))!=-1) &#123; fos.write(bys,0,len); &#125; fos.close(); fis.close(); &#125; //基本字节流一次读写一个字节 public static void method1() throws IOException &#123; //E:\\\\itcast\\\\字节流复制图片.avi //模块目录下的 字节流复制图片.avi FileInputStream fis = new FileInputStream(\"E:\\\\itcast\\\\字节流复制图片.avi\"); FileOutputStream fos = new FileOutputStream(\"myByteStream\\\\字节流复制图片.avi\"); int by; while ((by=fis.read())!=-1) &#123; fos.write(by); &#125; fos.close(); fis.close(); &#125;&#125; 字符流为什么会出现字符流【理解】 字符流的介绍 由于字节流操作中文不是特别的方便，所以Java就提供字符流 字符流 = 字节流 + 编码表 中文的字节存储方式 用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢？ 汉字在存储的时候，无论选择哪种编码存储，第一个字节都是负数 编码表【理解】 什么是字符集 是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 l计算机要准确的存储和识别各种字符集符号，就需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBXXX字符集、Unicode字符集等 常见的字符集 ASCII字符集： lASCII：是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显示字符(英文大小写字符、阿拉伯数字和西文符号) 基本的ASCII字符集，使用7位表示一个字符，共128字符。ASCII的扩展字符集使用8位表示一个字符，共256字符，方便支持欧洲常用字符。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等 GBXXX字符集： GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等 Unicode字符集： UTF-8编码：可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用 中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。它使用一至四个字节为每个字符编码 编码规则： 128个US-ASCII字符，只需一个字节编码 拉丁文等字符，需要二个字节编码 大部分常用字（含中文），使用三个字节编码 其他极少使用的Unicode辅助字符，使用四字节编码 字符串中的编码解码问题【应用】 相关方法 | 方法名 | 说明 | | —————————————- | ————————————————– | | byte[] getBytes() | 使用平台的默认字符集将该 String编码为一系列字节 | | byte[] getBytes(String charsetName) | 使用指定的字符集将该 String编码为一系列字节 | | String(byte[] bytes) | 使用平台的默认字符集解码指定的字节数组来创建字符串 | | String(byte[] bytes, String charsetName) | 通过指定的字符集解码指定的字节数组来创建字符串 | 代码演示 12345678910111213141516public class StringDemo &#123; public static void main(String[] args) throws UnsupportedEncodingException &#123; //定义一个字符串 String s = \"中国\"; //byte[] bys = s.getBytes(); //[-28, -72, -83, -27, -101, -67] //byte[] bys = s.getBytes(\"UTF-8\"); //[-28, -72, -83, -27, -101, -67] byte[] bys = s.getBytes(\"GBK\"); //[-42, -48, -71, -6] System.out.println(Arrays.toString(bys)); //String ss = new String(bys); //String ss = new String(bys,\"UTF-8\"); String ss = new String(bys,\"GBK\"); System.out.println(ss); &#125;&#125; 字符流中的编码解码问题【应用】 字符流中和编码解码问题相关的两个类 InputStreamReader：是从字节流到字符流的桥梁 ​ 它读取字节，并使用指定的编码将其解码为字符 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 OutputStreamWriter：是从字符流到字节流的桥梁 ​ 是从字符流到字节流的桥梁，使用指定的编码将写入的字符编码为字节 ​ 它使用的字符集可以由名称指定，也可以被明确指定，或者可以接受平台的默认字符集 构造方法 | 方法名 | 说明 | | ————————————————— | ——————————————– | | InputStreamReader(InputStream in) | 使用默认字符编码创建InputStreamReader对象 | | InputStreamReader(InputStream in,String chatset) | 使用指定的字符编码创建InputStreamReader对象 | | OutputStreamWriter(OutputStream out) | 使用默认字符编码创建OutputStreamWriter对象 | | OutputStreamWriter(OutputStream out,String charset) | 使用指定的字符编码创建OutputStreamWriter对象 | 代码演示 1234567891011121314151617public class ConversionStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); osw.write(\"中国\"); osw.close(); //InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\")); InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\osw.txt\"),\"GBK\"); //一次读取一个字符数据 int ch; while ((ch=isr.read())!=-1) &#123; System.out.print((char)ch); &#125; isr.close(); &#125;&#125; 字符流写数据的5种方式【应用】 方法介绍 | 方法名 | 说明 | | —————————————– | ——————– | | void write(int c) | 写一个字符 | | void write(char[] cbuf) | 写入一个字符数组 | | void write(char[] cbuf, int off, int len) | 写入字符数组的一部分 | | void write(String str) | 写一个字符串 | | void write(String str, int off, int len) | 写一个字符串的一部分 | 刷新和关闭的方法 | 方法名 | 说明 | | ——- | ———————————————————— | | flush() | 刷新流，之后还可以继续写数据 | | close() | 关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据 | 代码演示 12345678910111213141516171819202122232425262728public class OutputStreamWriterDemo &#123; public static void main(String[] args) throws IOException &#123; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\osw.txt\")); //void write(int c)：写一个字符// osw.write(97);// osw.write(98);// osw.write(99); //void writ(char[] cbuf)：写入一个字符数组 char[] chs = &#123;'a', 'b', 'c', 'd', 'e'&#125;;// osw.write(chs); //void write(char[] cbuf, int off, int len)：写入字符数组的一部分// osw.write(chs, 0, chs.length);// osw.write(chs, 1, 3); //void write(String str)：写一个字符串// osw.write(\"abcde\"); //void write(String str, int off, int len)：写一个字符串的一部分// osw.write(\"abcde\", 0, \"abcde\".length()); osw.write(\"abcde\", 1, 3); //释放资源 osw.close(); &#125;&#125; 字符流读数据的2种方式【应用】 方法介绍 | 方法名 | 说明 | | ——————— | ———————- | | int read() | 一次读一个字符数据 | | int read(char[] cbuf) | 一次读一个字符数组数据 | 代码演示 12345678910111213141516171819202122public class InputStreamReaderDemo &#123; public static void main(String[] args) throws IOException &#123; InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\ConversionStreamDemo.java\")); //int read()：一次读一个字符数据// int ch;// while ((ch=isr.read())!=-1) &#123;// System.out.print((char)ch);// &#125; //int read(char[] cbuf)：一次读一个字符数组数据 char[] chs = new char[1024]; int len; while ((len = isr.read(chs)) != -1) &#123; System.out.print(new String(chs, 0, len)); &#125; //释放资源 isr.close(); &#125;&#125; 字符流复制Java文件【应用】 案例需求 把模块目录下的“ConversionStreamDemo.java” 复制到模块目录下的“Copy.java” 实现步骤 根据数据源创建字符输入流对象 根据目的地创建字符输出流对象 读写数据，复制文件 释放资源 代码实现 1234567891011121314151617181920212223242526public class CopyJavaDemo01 &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字符输入流对象 InputStreamReader isr = new InputStreamReader(new FileInputStream(\"myCharStream\\\\ConversionStreamDemo.java\")); //根据目的地创建字符输出流对象 OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"myCharStream\\\\Copy.java\")); //读写数据，复制文件 //一次读写一个字符数据// int ch;// while ((ch=isr.read())!=-1) &#123;// osw.write(ch);// &#125; //一次读写一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=isr.read(chs))!=-1) &#123; osw.write(chs,0,len); &#125; //释放资源 osw.close(); isr.close(); &#125;&#125; 字符流复制Java文件改进版【应用】 案例需求 使用便捷流对象，把模块目录下的“ConversionStreamDemo.java” 复制到模块目录下的“Copy.java” 实现步骤 根据数据源创建字符输入流对象 根据目的地创建字符输出流对象 读写数据，复制文件 释放资源 代码实现 123456789101112131415161718192021222324public class CopyJavaDemo02 &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字符输入流对象 FileReader fr = new FileReader(\"myCharStream\\\\ConversionStreamDemo.java\"); //根据目的地创建字符输出流对象 FileWriter fw = new FileWriter(\"myCharStream\\\\Copy.java\"); //读写数据，复制文件// int ch;// while ((ch=fr.read())!=-1) &#123;// fw.write(ch);// &#125; char[] chs = new char[1024]; int len; while ((len=fr.read(chs))!=-1) &#123; fw.write(chs,0,len); &#125; //释放资源 fw.close(); fr.close(); &#125;&#125; 字符缓冲流 字符缓冲流介绍 BufferedWriter：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途 BufferedReader：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途 构造方法 | 方法名 | 说明 | | ————————– | ———————- | | BufferedWriter(Writer out) | 创建字符缓冲输出流对象 | | BufferedReader(Reader in) | 创建字符缓冲输入流对象 | 代码演示 123456789101112131415161718192021222324252627public class BufferedStreamDemo01 &#123; public static void main(String[] args) throws IOException &#123; //BufferedWriter(Writer out) BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); bw.write(\"hello\\r\\n\"); bw.write(\"world\\r\\n\"); bw.close(); //BufferedReader(Reader in) BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); //一次读取一个字符数据// int ch;// while ((ch=br.read())!=-1) &#123;// System.out.print((char)ch);// &#125; //一次读取一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) &#123; System.out.print(new String(chs,0,len)); &#125; br.close(); &#125;&#125; 字符缓冲流复制Java文件【应用】 案例需求 把模块目录下的ConversionStreamDemo.java 复制到模块目录下的 Copy.java 实现步骤 根据数据源创建字符缓冲输入流对象 根据目的地创建字符缓冲输出流对象 读写数据，复制文件，使用字符缓冲流特有功能实现 释放资源 代码实现 1234567891011121314151617181920212223242526public class CopyJavaDemo01 &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字符缓冲输入流对象 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\ConversionStreamDemo.java\")); //根据目的地创建字符缓冲输出流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\Copy.java\")); //读写数据，复制文件 //一次读写一个字符数据// int ch;// while ((ch=br.read())!=-1) &#123;// bw.write(ch);// &#125; //一次读写一个字符数组数据 char[] chs = new char[1024]; int len; while ((len=br.read(chs))!=-1) &#123; bw.write(chs,0,len); &#125; //释放资源 bw.close(); br.close(); &#125;&#125; 字符缓冲流特有功能【应用】 方法介绍 BufferedWriter： | 方法名 | 说明 | | ————– | ——————————————– | | void newLine() | 写一行行分隔符，行分隔符字符串由系统属性定义 | BufferedReader: | 方法名 | 说明 | | —————– | ———————————————————— | | String readLine() | 读一行文字。 结果包含行的内容的字符串，不包括任何行终止字符如果流的结尾已经到达，则为null | 代码演示 12345678910111213141516171819202122232425262728public class BufferedStreamDemo02 &#123; public static void main(String[] args) throws IOException &#123; //创建字符缓冲输出流 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\bw.txt\")); //写数据 for (int i = 0; i &lt; 10; i++) &#123; bw.write(\"hello\" + i); //bw.write(\"\\r\\n\"); bw.newLine(); bw.flush(); &#125; //释放资源 bw.close(); //创建字符缓冲输入流 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\bw.txt\")); String line; while ((line=br.readLine())!=null) &#123; System.out.println(line); &#125; br.close(); &#125;&#125; 字符缓冲流特有功能复制Java文件【应用】 案例需求 使用特有功能把模块目录下的ConversionStreamDemo.java 复制到模块目录下的 Copy.java 实现步骤 根据数据源创建字符缓冲输入流对象 根据目的地创建字符缓冲输出流对象 读写数据，复制文件，使用字符缓冲流特有功能实现 释放资源 代码实现 123456789101112131415161718192021public class CopyJavaDemo02 &#123; public static void main(String[] args) throws IOException &#123; //根据数据源创建字符缓冲输入流对象 BufferedReader br = new BufferedReader(new FileReader(\"myCharStream\\\\ConversionStreamDemo.java\")); //根据目的地创建字符缓冲输出流对象 BufferedWriter bw = new BufferedWriter(new FileWriter(\"myCharStream\\\\Copy.java\")); //读写数据，复制文件 //使用字符缓冲流特有功能实现 String line; while ((line=br.readLine())!=null) &#123; bw.write(line); bw.newLine(); bw.flush(); &#125; //释放资源 bw.close(); br.close(); &#125;&#125; IO流小结图 序列化流 对象序列化介绍 对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象 这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息 字节序列写到文件之后，相当于文件中持久保存了一个对象的信息 反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化 对象序列化流： ObjectOutputStream 将Java对象的原始数据类型和图形写入OutputStream。 可以使用ObjectInputStream读取（重构）对象。 可以通过使用流的文件来实现对象的持久存储。 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象 构造方法 | 方法名 | 说明 | | ———————————— | ————————————————– | | ObjectOutputStream(OutputStream out) | 创建一个写入指定的OutputStream的ObjectOutputStream | 序列化对象的方法 | 方法名 | 说明 | | —————————- | ———————————- | | void writeObject(Object obj) | 将指定的对象写入ObjectOutputStream | 示例代码 学生类 123456789101112131415161718192021222324252627282930313233343536public class Student implements Serializable &#123; private String name; private int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return \"Student&#123;\" + \"name='\" + name + '\\'' + \", age=\" + age + '&#125;'; &#125;&#125; 测试类 123456789101112131415public class ObjectOutputStreamDemo &#123; public static void main(String[] args) throws IOException &#123; //ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); //创建对象 Student s = new Student(\"林青霞\",30); //void writeObject(Object obj)：将指定的对象写入ObjectOutputStream oos.writeObject(s); //释放资源 oos.close(); &#125;&#125; 注意事项 一个对象要想被序列化，该对象所属的类必须必须实现Serializable 接口 Serializable是一个标记接口，实现该接口，不需要重写任何方法 反序列化流 对象反序列化流： ObjectInputStream ObjectInputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象 构造方法 | 方法名 | 说明 | | ——————————— | ———————————————- | | ObjectInputStream(InputStream in) | 创建从指定的InputStream读取的ObjectInputStream | 反序列化对象的方法 | 方法名 | 说明 | | ——————- | ——————————- | | Object readObject() | 从ObjectInputStream读取一个对象 | 示例代码 1234567891011121314public class ObjectInputStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //ObjectInputStream(InputStream in)：创建从指定的InputStream读取的ObjectInputStream ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); //Object readObject()：从ObjectInputStream读取一个对象 Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); &#125;&#125; serialVersionUID&amp;transient serialVersionUID 用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出问题呢？ 会出问题，会抛出InvalidClassException异常 如果出问题了，如何解决呢？ 重新序列化 给对象所属的类加一个serialVersionUID private static final long serialVersionUID = 42L; transient 如果一个对象中的某个成员变量的值不想被序列化，又该如何实现呢？ 给该成员变量加transient关键字修饰，该关键字标记的成员变量不参与序列化过程 示例代码 学生类 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Serializable &#123; private static final long serialVersionUID = 42L; private String name;// private int age; private transient int age; public Student() &#123; &#125; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;// @Override// public String toString() &#123;// return \"Student&#123;\" +// \"name='\" + name + '\\'' +// \", age=\" + age +// '&#125;';// &#125;&#125; 测试类 1234567891011121314151617181920212223public class ObjectStreamDemo &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123;// write(); read(); &#125; //反序列化 private static void read() throws IOException, ClassNotFoundException &#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"myOtherStream\\\\oos.txt\")); Object obj = ois.readObject(); Student s = (Student) obj; System.out.println(s.getName() + \",\" + s.getAge()); ois.close(); &#125; //序列化 private static void write() throws IOException &#123; ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"myOtherStream\\\\oos.txt\")); Student s = new Student(\"林青霞\", 30); oos.writeObject(s); oos.close(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"File","slug":"文件","date":"2019-06-20T01:54:45.356Z","updated":"2019-06-20T02:48:22.587Z","comments":true,"path":"2019/06/20/文件/","link":"","permalink":"http://yoursite.com/2019/06/20/文件/","excerpt":"","text":"1.File(文件)1.1File类概述和构造方法【应用】 File类介绍 它是文件和目录路径名的抽象表示 文件和目录是可以通过File封装成对象的 对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的 File类的构造方法 | 方法名 | 说明 || ———————————– | ———————————————————– || File(String pathname) | 通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例 || File(String parent, String child) | 从父路径名字符串和子路径名字符串创建新的 File实例 || File(File parent, String child) | 从父抽象路径名和子路径名字符串创建新的 File实例 | 示例代码 12345678910111213141516public class FileDemo01 &#123; public static void main(String[] args) &#123; //File(String pathname)：通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例。 File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1); //File(String parent, String child)：从父路径名字符串和子路径名字符串创建新的 File实例。 File f2 = new File(\"E:\\\\itcast\",\"java.txt\"); System.out.println(f2); //File(File parent, String child)：从父抽象路径名和子路径名字符串创建新的 File实例。 File f3 = new File(\"E:\\\\itcast\"); File f4 = new File(f3,\"java.txt\"); System.out.println(f4); &#125;&#125; 1.2File类创建功能【应用】 方法分类 | 方法名 | 说明 || —————————— | ———————————————————— || public boolean createNewFile() | 当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 || public boolean mkdir() | 创建由此抽象路径名命名的目录 || public boolean mkdirs() | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 | 示例代码 123456789101112131415161718192021222324public class FileDemo02 &#123; public static void main(String[] args) throws IOException &#123; //需求1：我要在E:\\\\itcast目录下创建一个文件java.txt File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); System.out.println(f1.createNewFile()); System.out.println(\"--------\"); //需求2：我要在E:\\\\itcast目录下创建一个目录JavaSE File f2 = new File(\"E:\\\\itcast\\\\JavaSE\"); System.out.println(f2.mkdir()); System.out.println(\"--------\"); //需求3：我要在E:\\\\itcast目录下创建一个多级目录JavaWEB\\\\HTML File f3 = new File(\"E:\\\\itcast\\\\JavaWEB\\\\HTML\");// System.out.println(f3.mkdir()); System.out.println(f3.mkdirs()); System.out.println(\"--------\"); //需求4：我要在E:\\\\itcast目录下创建一个文件javase.txt File f4 = new File(\"E:\\\\itcast\\\\javase.txt\");// System.out.println(f4.mkdir()); System.out.println(f4.createNewFile()); &#125;&#125; 1.3File类判断和获取功能【应用】 判断功能 | 方法名 | 说明 || —————————— | ———————————— || public boolean isDirectory() | 测试此抽象路径名表示的File是否为目录 || public boolean isFile() | 测试此抽象路径名表示的File是否为文件 || public boolean exists() | 测试此抽象路径名表示的File是否存在 | 获取功能 | 方法名 | 说明 || ——————————— | ——————————————————– || public String getAbsolutePath() | 返回此抽象路径名的绝对路径名字符串 || public String getPath() | 将此抽象路径名转换为路径名字符串 || public String getName() | 返回由此抽象路径名表示的文件或目录的名称 || public String[] list() | 返回此抽象路径名表示的目录中的文件和目录的名称字符串数组 || public File[] listFiles() | 返回此抽象路径名表示的目录中的文件和目录的File对象数组 | 示例代码 12345678910111213141516171819202122232425262728293031323334353637383940public class FileDemo04 &#123; public static void main(String[] args) &#123; //创建一个File对象 File f = new File(\"myFile\\\\java.txt\");// public boolean isDirectory()：测试此抽象路径名表示的File是否为目录// public boolean isFile()：测试此抽象路径名表示的File是否为文件// public boolean exists()：测试此抽象路径名表示的File是否存在 System.out.println(f.isDirectory()); System.out.println(f.isFile()); System.out.println(f.exists());// public String getAbsolutePath()：返回此抽象路径名的绝对路径名字符串// public String getPath()：将此抽象路径名转换为路径名字符串// public String getName()：返回由此抽象路径名表示的文件或目录的名称 System.out.println(f.getAbsolutePath()); System.out.println(f.getPath()); System.out.println(f.getName()); System.out.println(\"--------\");// public String[] list()：返回此抽象路径名表示的目录中的文件和目录的名称字符串数组// public File[] listFiles()：返回此抽象路径名表示的目录中的文件和目录的File对象数组 File f2 = new File(\"E:\\\\itcast\"); String[] strArray = f2.list(); for(String str : strArray) &#123; System.out.println(str); &#125; System.out.println(\"--------\"); File[] fileArray = f2.listFiles(); for(File file : fileArray) &#123;// System.out.println(file);// System.out.println(file.getName()); if(file.isFile()) &#123; System.out.println(file.getName()); &#125; &#125; &#125;&#125; 1.4File类删除功能【应用】 方法分类 | 方法名 | 说明 || ————————- | ———————————- || public boolean delete() | 删除由此抽象路径名表示的文件或目录 | 示例代码 123456789101112131415161718192021222324252627282930public class FileDemo03 &#123; public static void main(String[] args) throws IOException &#123;// File f1 = new File(\"E:\\\\itcast\\\\java.txt\"); //需求1：在当前模块目录下创建java.txt文件 File f1 = new File(\"myFile\\\\java.txt\");// System.out.println(f1.createNewFile()); //需求2：删除当前模块目录下的java.txt文件 System.out.println(f1.delete()); System.out.println(\"--------\"); //需求3：在当前模块目录下创建itcast目录 File f2 = new File(\"myFile\\\\itcast\");// System.out.println(f2.mkdir()); //需求4：删除当前模块目录下的itcast目录 System.out.println(f2.delete()); System.out.println(\"--------\"); //需求5：在当前模块下创建一个目录itcast,然后在该目录下创建一个文件java.txt File f3 = new File(\"myFile\\\\itcast\");// System.out.println(f3.mkdir()); File f4 = new File(\"myFile\\\\itcast\\\\java.txt\");// System.out.println(f4.createNewFile()); //需求6：删除当前模块下的目录itcast System.out.println(f4.delete()); System.out.println(f3.delete()); &#125;&#125; 1.5获取文件常规信息 方法名 说明 long lastModified() 返回文件的最后修改时间 long length() 返回文件内容的长度 绝对路径和相对路径的区别 绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如：E:\\itcast\\java.txt 相对路径：必须使用取自其他路径名的信息进行解释。例如：myFile\\java.txt 2.文件过滤器​ 通过文件过滤器可以有选择性的列出特定文件，方便对特定文件进行操作。这也是文件过滤器的最大作用。可以通过以下两个方法实现对文件的过滤效果。 File[] listFiles(FileFilter filter) java.io.FileFilter接口：用于抽象路径名的过滤器 作用：用来过滤文件 抽象方法：用来过滤文件的方法 boolean accept(File pathname): 参数： File pathname:使用ListFiles方法遍历目录之后得到的每一个文件对象 File[] listFiles(FilenameFilter filter) java.io.FilenameFilter接口：实现此接口的类可以用于过滤文件名称作用：用于过滤文件名称 抽象方法： boolean accept(File dir,String name):测试指定文件是否应该包含在某一文件列表中 参数： File dir:构造方法中传递的被遍历的目录 String name:使用ListFiles方法遍历目录获取的每一个文件/文件夹的名称 ==注意==： 两个过滤器接口是没有实现类的，需要自己写实现类，重写过滤的方法，在方法中自己定义过滤的规则 示例代码1:（通过实现类的方式–仅实现第一种方式，第二种方式类似）： 123456789101112//创建过滤器FileFilter的实现类，重写过滤方法accept，定义过滤规则public class FileFilterImpl implements FileFilter &#123; @Override public boolean accept(File pathname) &#123; //如果pathname是一个文件夹，返回true，继续遍历这个文件夹 if (pathname.isDirectory())&#123; return true; &#125; return pathname.getName().endsWith(\".java\"); &#125;&#125; 1234567891011121314151617181920212223public class Filter1 &#123; public static void main(String[] args) &#123; File file=new File(\"D:\\\\a\"); getAllFile(file); &#125; public static void getAllFile(File file)&#123; //传递了过滤器对象 File[] files = file.listFiles(new FileFilterImpl()); if (files!=null)&#123; for (File f:files) &#123; if (f.isDirectory())&#123; getAllFile(f); &#125;else &#123; String s = f.toString(); System.out.println(f); &#125; &#125; &#125; &#125;&#125; 示例代码2（匿名内部类–第一种方式） 1234567891011121314151617181920212223242526272829303132333435363738394041public class Filter2 &#123; public static void main(String[] args) &#123; File file=new File(\"D:\\\\a\"); getAllFile(file); &#125; public static void getAllFile(File file)&#123; //使用匿名内部类利用第一种方式进行过滤 /*File[] files = file.listFiles(new FileFilter()&#123; @Override public boolean accept(File pathname) &#123; //如果pathname是一个文件夹，返回true，继续遍历这个文件夹 //如果是.java结尾的就返回true return pathname.isDirectory()||pathname.getName().endsWith(\".java\"); &#125; &#125;);*/ //Lambda优化 /*File[] files = file.listFiles((pathname) -&gt;&#123; return pathname.isDirectory()||pathname.getName().endsWith(\".java\"); &#125;);*/ //继续优化 File[] files = file.listFiles(pathname -&gt; pathname.isDirectory()||pathname.getName().endsWith(\".java\") ); for (File f:files) &#123; if (f.isDirectory())&#123; getAllFile(f); &#125;else &#123; String s = f.toString(); System.out.println(f); &#125; &#125; &#125;&#125; 示例代码3（匿名内部类–第三种方式） 1234567891011121314151617181920212223242526272829303132333435363738public class Filter3 &#123; public static void main(String[] args) &#123; File file=new File(\"D:\\\\a\"); getAllFile(file); &#125; public static void getAllFile(File file)&#123; //使用匿名内部类利用第二种方式进行过滤 /*File[] files=file.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File dir, String name) &#123; return new File(dir,name).isDirectory()||name.endsWith(\".java\"); &#125; &#125;);*/ //使用Lambda表达式进行简化 /*File[] files=file.listFiles((dir,name)-&gt;&#123; return new File(dir,name).isDirectory()||name.endsWith(\".java\"); &#125;);*/ //继续Lambda优化 File[] files=file.listFiles((dir,name)-&gt; new File(dir,name).isDirectory()||name.endsWith(\".java\") ); for (File f:files) &#123; if (f.isDirectory())&#123; getAllFile(f); &#125;else &#123; String s = f.toString(); System.out.println(f); &#125; &#125; &#125;&#125; 两种方式实际上几乎完全一模一样，其中一种弄懂了，另外一种自然就明白了","categories":[],"tags":[],"keywords":[]},{"title":"并发修改异常","slug":"集合知识浅析（四）并发修改异常","date":"2019-06-13T10:12:43.646Z","updated":"2019-06-17T06:50:30.073Z","comments":true,"path":"2019/06/13/集合知识浅析（四）并发修改异常/","link":"","permalink":"http://yoursite.com/2019/06/13/集合知识浅析（四）并发修改异常/","excerpt":"","text":"首先来看一段代码： 1234567891011121314151617181920212223242526import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.Iterator;import java.util.List;public class x&#123; public static void main(String[] args) &#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add(\"hello\"); list.add(\"world\"); list.add(\"java\"); //遍历集合，如果集合中有个某个符合要求的值，就添加一个新的元素 Iterator&lt;String&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; String next = iterator.next(); if (next.equals(\"java\"))&#123; list.add(\"这是新添加的元素\"); &#125; &#125; System.out.println(list); &#125;&#125; 上述代码主要功能是如果集合中有特定元素就向集合中添加一个新的元素。来看运行结果： 然而运行结果和我们期望的并不一样，思路没错，但是结果却令人大跌眼镜。 下面来分析一下原因： 首先运行中出现了异常：==ConcurrentModificationException==，这是啥？不知道！那就去API看看呗 1ConcurrentModificationException extends RuntimeException 这个异常继承自RuntimeException，表明这是个运行时异常。 ​ 在API文档中有这样一句话：当不允许这样的修改时，可以通过检测到对象的并发修改的方法来抛出此异常。 ​ 从异常信息可以看出问题出现在代码第19行，也就是==String next = iterator.next();== next() 方法这个位置，而在异常信息中又知道next()方法中又调用了==checkForComodification()==，也就是说问题最终出现在这个地方。 现在去源码（完整源码的一部分）中看看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface List&lt;E&gt;&#123; Iterator&lt;E&gt; iterator(); boolean add(E e);&#125;public abstract class AbstractList&lt;E&gt;&#123; protected transient int modCount = 0;&#125;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;&#123; public boolean add(E e) &#123; modCount++; add(e, elementData, size); return true; &#125; public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123; int expectedModCount = modCount; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125;&#125; 来看一下出错的代码位置： 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; modCount：修改集合的次数 expectedModCount：预期修改集合的次数 ​ 从错的代码可以知道，之所以出错，是因为修改集合的次数和预期修改集合的次数不一样导致的。modCount是ArrayList的父类AbstractList继承下来的，因此expectedModCount初始值也是0，和modCount初始值一样。 ​ 集合每次在使用next()方法的时候都会首先调用checkForComodification()方法进行判断两者的值是否一致。正常遍历情况下两者的一定相等。但是在add()方法中首先就会对modCount进行加1操作，而不会对expectedModCount有任何修改。如果在使用迭代器遍历的时候使用了add()方法就会导致expectedModCount和modCount两者的值不相等，最终在next()**方法里面调用checkForComodification()方法的时候判断两者不想等，进而抛出==ConcurrentModificationException==异常。 上面啰嗦了那么一大堆，其实出错原因就是那么简单。 那有什么方法能够避免这种异常呢？下面来介绍一下。 首先是治标不治本的方法：for循环遍历 ​ 在for循环里面进行集合的操作不会出现这种异常，可以达到遍历的同时对集合进行修改。但是，并不是所有的集合都能够使用for循环进行遍历啊比如说Set，因为使用for循环进行遍历必须有一个前提条件：能够对该集合使用索引（就是数组下标的那种索引）。 其次就是治本的方法：使用迭代器本身的添加/删除方法 ​ 在Iterator接口中有remove()方法，在ListIterator接口中有add()方法","categories":[],"tags":[],"keywords":[]},{"title":"内部类浅析","slug":"内部类","date":"2019-06-10T02:13:43.888Z","updated":"2019-07-31T02:09:18.575Z","comments":true,"path":"2019/06/10/内部类/","link":"","permalink":"http://yoursite.com/2019/06/10/内部类/","excerpt":"","text":"内部类​ 定义在其他类内部的类叫做内部类。 内部类作用： 提供了更好的封装性，可以将内部类隐藏在外部类之中，不允许同一个包中的其他类访问 内部类可以直接访问外部类的私有数据，但是外部类不能访问内部类的实现细节，比如内部类的成员变量 匿名内部类适合创建仅需使用一次的类 内部类和外部类的一些区别： 内部类可以比外部类多使用三个修饰符：private protected static 非静态内部类不能拥有静态成员 （一）非静态内部类​ 格式： 123public class 外部类&#123; //定义内部类&#125; 如果外部类、内部类以及内部类的函数中存在同名变量的话，如何区分访问这些变量呢？ 通过this、外部类名.this来区分内部类变量以及外部类变量。 ​ 非静态内部类可以访问外部类的私有成员，但是外部类不能直接访问内部类的成员，因为非静态内部类的成员只在非静态内部类范围内是可知的。如果外部类需要访问非静态内部类的成员，必须显式创建非静态内部类的对象来点用访问其实例成员 ​ ==注意：==非静态内部类不可以有静态初始化块，但是可以有普通初始化块。 （二）静态内部类​ 使用static修饰的内部类就是静态内部类。这个类就属于外部类本身，而不是属于外部类的某个对象。 ​ ==注意：==静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的类成员，即使是静态内部类的实例方法也不能访问外部类的实例成员，只能访问外部类的静态成员。 ​ 静态内部类是外部类的静态成员，因此外部类的所有方法、所有初始化块都可以使用静态内部类来定义变量，创建对象。 ​ 外部类不能直接访问静态内部类的成员，但是可以使用静态内部类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类的类对象作为调用者来访问静态内部类的实例成员。 （三）局部内部类​ 如果将一个类放在方法中定义，那这个类就是局部内部类。局部内部类仅仅在该方法体内有效且由于局部内部类不能再外部类的方法以外其他地方使用，所以不能使用访问控制符和static修饰。若需要在局部内部类中定义变量，创建实例或者派生子类只能在局部内部类所在的方法内进行。 （四）匿名内部类​ 匿名内部类本质是一个对象，是一个继承了该类或实现了该接口的子类匿名对象。 ​ 定义格式： 123new 实现接口() | 父类构造器&#123; //匿名内部类类体&#125; ​ 从定义格式可以看出来，匿名内部类必须继承一个父类或者实现一个接口，但最多只能继承一个父类或者实现一个接口 ==注意：== 匿名内部类不能是抽象类。因为系统在创建匿名内部类的时候会立即创建匿名内部类的对象，因此不允许将匿名内部类定义成抽象类 匿名内部类不能定义构造器。因为匿名内部类没有类名，但是匿名内部类可以定义初始化块。 以下通过一段代码来观察匿名内部类的使用： 12345678910111213141516171819202122//首先定义一个接口interface A&#123; public void a();&#125;//测试类public class B&#123; public static void main(String[] args)&#123; B b=new B(); b.test(new y() &#123; @Override public void a() &#123; System.out.println(\"你好\"); &#125; &#125;); &#125; public void test(A a)&#123; //执行语句 &#125;&#125; 上述是使用了匿名内部类的形式，那么常规方法是什么样子的呢？ ​ 首先需要一个类是实现这个接口，并且重写接口里面的方法 123456public class C implements A&#123; @Override public void a() &#123; System.out.println(\"你好\"); &#125;&#125; 然后得到一个实现类的对象，并作为test()方法的参数 12C c=new C();b.test(c); ​ 这样可以看出来匿名内部类的好处了吧？如果有多个类都实现了这个接口的话，就要实现多个实现类。太麻烦！！！ （五）内部类的使用1.在外部类内部使用内部类​ 在外部类内部使用内部类的时候，与平常使用普通类没有太大区别。一样可以直接通过内部类类名定义变量，通过new关键字调用内部类构造器创建实例。在外部类内部定义内部类的子类与平常定义子类也没有区别。 ​ 唯一区别：不要再外部类的静态成员（静态方法/静态初始化块）中使用非静态内部类 2.在外部类以外使用非静态内部类​ 如果希望在外部类以外的地方访问内部类（静态和非静态），那么内部类不能使用private修饰。private修饰的内部类只能在外部类的内部使用。对于其他访问控制符修饰的内部类在外部类意外的地方访问按照访问权限使用： 省略修饰符：只能被与外部类处于同一个包中的其他类使用 protected：可以被与外部类处于同一包中的其他类和外部类的子类访问 public：任何地方都可以使用 在外部类以外的地方定义内部类（静态/非静态）变量以及内部类（非静态）实例的语法格式： 12外部类名.内部类名 变量名 new 外部类名().new 内部类构造器() 3.在外部类以外的地方使用静态内部类​ 因为静态内部类是和外部类类相关的，所以创建静态内部类对象的时候无需创建外部类对象。具体语法格式如下： 1new 外部类名.内部类构造器();","categories":[],"tags":[],"keywords":[]},{"title":"多线程浅析（二）--线程通信","slug":"多线程浅析（二）","date":"2019-06-09T13:15:49.487Z","updated":"2019-07-23T04:28:50.060Z","comments":true,"path":"2019/06/09/多线程浅析（二）/","link":"","permalink":"http://yoursite.com/2019/06/09/多线程浅析（二）/","excerpt":"","text":"传统的线程通信​ Object类中有三个方法：wait()、notify()、notifyAll()，这三个方法并不属于Thread类，而是属于Object类。但是这三个方法必须由同步监视器对象来调用，主要可以分成以下两种情况： 对于使用synchronized修饰的同步方法，因为该类的默认实例（this）就是同步监视器，所以可以直接在同步方法中直接调用这三个方法 对于使用synchronized修饰的同步代码块，同步监视器是synchronized后括号里面的对象，所以必须使用该对象调用这三个方法。 接下来来看这三个方法的相关大致解释： wait():致使当前线程等待，直到其他线程调用该同步监视器的notify()或者notifyAll()方法来唤醒该线程。 notify():唤醒此同步监视器上等待的单个线程。如果有多个线程在该同步监视器上等待，将会随机唤醒其中一个。 notifyAll():唤醒等待在该同步监视器上的所有线程。 接下来通过一段代码来看具体的操作（老板顾客案例）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package thread.watiandnotify;/** * @Author: 小青年XQP * * 等待唤醒案例： * 创建一个顾客线程（消费者）：告知老板要的包子的种类和数量，调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待） * 创建一个老板线程（生产者）：花了5秒做好包子，调用notify()方法唤醒顾客吃包子 * 注意： * 顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行 * 同步使用的锁对象必须保证是唯一的 * 只有锁对象才能调用wait()和notify()方法 * * Object类中的方法： * void wait() * 在其他线程调用此对象的notify()或notifyAll()方法钱，导致当前线程等待 * void notify() * 唤醒在此对象监视器上等待的单个线程 * 会继续执行wait后面的代码 * */public class Demo1 &#123; public static void main(String[] args) &#123; //创建锁对象,保证唯一 Object obj=new Object(); //创建一个顾客线程 new Thread()&#123; @Override public void run() &#123; //保证等待和唤醒的线程只有一个在执行，需要使用同步技术 synchronized (obj)&#123; System.out.println(\"告知老板要的包子的种类和数量\"); //调用wait方法，放弃cpu的执行，进入到WAITING状态（无线等待） try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"正在吃包子！！！\"); &#125; &#125; &#125;.start(); //创建一个老板线程 new Thread()&#123; @Override public void run() &#123; try &#123; Thread.sleep(5000);//花费5秒做包子 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj)&#123; System.out.println(\"老板5秒中之后做好包子，喊顾客吃包子\"); //唤醒顾客吃包子 obj.notify(); &#125; &#125; &#125;.start(); &#125;&#125; 使用Condition控制线程通信​ 如果程序不实用synchronized关键字来保证同步，而是直接使用Lock锁来保证同步，那么系统中就不存在隐式的同步监视器，也就不能使用wait()、notify()、notifyAll()。同时，Condition类提供了如下相应的方法： await():类似于隐式同步监视器上的wait()方法，致使当前线程等待，直到其他线程调用该Condition的signal()或者signalAll()方法来唤醒该线程 signal():唤醒在此Lock对象上等待的单个线程。如果所有的线程都在该Lock对象上等待，就会随机唤醒其中一个线程。 signalAll():唤醒在此Lock对象上等待的所有线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Demo1 &#123; public static void main(String[] args) &#123; //显式定义Lock锁对象 private final Lock lock=new ReentrantLock(); //获取锁对象对应的Condition private final Condition cond=lock.newCondition(); //创建一个顾客线程 new Thread()&#123; @Override public void run() &#123; //保证等待和唤醒的线程只有一个在执行，需要使用同步技术 lock.lock(); System.out.println(\"告知老板要的包子的种类和数量\"); //调用wait方法，放弃cpu的执行，进入到WAITING状态（无线等待） try &#123; cond.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.unlock(); System.out.println(\"正在吃包子！！！\"); &#125; &#125;.start(); //创建一个老板线程 new Thread()&#123; @Override public void run() &#123; lock.lock(); try &#123; Thread.sleep(5000);//花费5秒做包子 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"老板5秒中之后做好包子，喊顾客吃包子\"); //唤醒顾客吃包子 cond.notify(); lock.unlock(); &#125; &#125;.start(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Cookie 报错500无效字符","slug":"Cookie出现500错误（无效字符）","date":"2019-06-08T09:15:30.185Z","updated":"2019-06-08T10:13:47.327Z","comments":true,"path":"2019/06/08/Cookie出现500错误（无效字符）/","link":"","permalink":"http://yoursite.com/2019/06/08/Cookie出现500错误（无效字符）/","excerpt":"","text":"废话不多说，直接上源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@WebServlet(\"/CookieRecordTime\")public class CookieRecordTime extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应消息体的数据格式 response.setContentType(\"text/html;charset=utf-8\"); //获取所有的Cookie Cookie[] cookies = request.getCookies(); //是否存在指定名称的Cookie的标记 boolean flag=false; //判断是否存在对应名称的Cookie if (cookies!=null &amp;&amp; cookies.length&gt;0)&#123; for (Cookie cookie : cookies) &#123; String name=cookie.getName(); if (\"lastTime\".equals(name))&#123; flag=true; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); //设置时间 cookie.setValue(currentTime); //设置Cookie的存活时间 cookie.setMaxAge(60*60*24*30); //写回最新时间 response.addCookie(cookie); //返回上次访问时间 String value=cookie.getValue(); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间是：\"+value+\"&lt;h1&gt;\"); break; &#125; &#125; &#125; if (cookies==null || cookies.length==0 || flag==false)&#123; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); Cookie cookie=new Cookie(\"lastTime\",currentTime); cookie.setMaxAge(60*60*24*30); response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;欢迎您首次访问&lt;h1&gt;\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 部署运行之后如下： 从以上报错可以得知出错原因是因为Cookie的value值里面有个空格特殊字符，32就是空格的ASCII码。 具体出错点： 1SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd HH:mm:ss&quot;); 其实解决方法很简单，把dd和HH之间的空格去掉就行了。 但是这里着重介绍另外一种方法。 ​ 首先先说一个URL编码，在tomcat8之前，Cookie中不支持中文，所有的中文数据都要先转换成URL编码的形式进行传输，当然想要读取的话还需要进行解码。虽然在tomcat8之后Cookie支持中文，但是依然不支持特殊字符，因此建议使用URL编码进行存储，使用URL编码进行解析。 修改后的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@WebServlet(\"/CookieRecordTime\")public class CookieRecordTime extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应消息体的数据格式 response.setContentType(\"text/html;charset=utf-8\"); //获取所有的Cookie Cookie[] cookies = request.getCookies(); //是否存在指定名称的Cookie的标记 boolean flag=false; //判断是否存在对应名称的Cookie if (cookies!=null &amp;&amp; cookies.length&gt;0)&#123; for (Cookie cookie : cookies) &#123; String name=cookie.getName(); if (\"lastTime\".equals(name))&#123; flag=true; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); System.out.println(\"编码前：\"+currentTime); //进行URL编码，否则特殊字符会报错 currentTime = URLEncoder.encode(currentTime, \"utf-8\"); System.out.println(\"编码前：\"+currentTime); //设置时间 cookie.setValue(currentTime); //设置Cookie的存活时间 cookie.setMaxAge(60*60*24*30); //写回最新时间 response.addCookie(cookie); //返回上次访问时间 String value=cookie.getValue(); System.out.println(\"解码前：\"+value); //进行URL解码 value=URLDecoder.decode(value,\"utf-8\"); System.out.println(\"解码后：\"+value); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间是：\"+value+\"&lt;h1&gt;\"); break; &#125; &#125; &#125; if (cookies==null || cookies.length==0 || flag==false)&#123; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); //进行URL编码，否则特殊字符会报错 currentTime = URLEncoder.encode(currentTime, \"utf-8\"); Cookie cookie=new Cookie(\"lastTime\",currentTime); cookie.setMaxAge(60*60*24*30); response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;欢迎您首次访问&lt;h1&gt;\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 修改之后问题完美解决","categories":[],"tags":[],"keywords":[]},{"title":"多线程浅析（一）--创建线程/线程安全（同步）/生命周期","slug":"多线程浅析（一）","date":"2019-06-06T11:27:29.716Z","updated":"2019-07-23T06:00:26.271Z","comments":true,"path":"2019/06/06/多线程浅析（一）/","link":"","permalink":"http://yoursite.com/2019/06/06/多线程浅析（一）/","excerpt":"","text":"在介绍多线程之前首先要明确两个很重要的概念：线程/进程。 什么是进程和线程呢？​ 先来大概看一下看书上的定义：进程是处于运行过程中的程序，具有一定的独立功能，是系统进行资源分配和调度的一个独立功能。线程是进程的组成部分，在程序中是独立的、并发的执行流,是进程的执行单元。是否容易理解？其实可以理解为电脑上的扫雷游戏。而线程就是扫雷游戏上的那个计时器。 ​ 归纳起来可以这样说：操作系统可以同时执行多个任务（QQ聊天、看电影、写博客等），每个任务其实就是进程；进程又可以同时执行多个任务（看电影的时候不仅仅能够观看电影还能够发弹幕），对应的每个任务就是线程。 线程和进程的关系？​ 线程是进程的组成部分，一个进程可以有多个线程。一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器以及自己的局部变量，但是不拥有系统资源，他与父进程的其他线程共享改进成所拥有的全部资源。不过也就是因为这样，在进行多线程编程的时候要防止线程冲突。 多线程编程优点 进程之间不能共享内存，但是线程之间共享内存就很容易 系统创建进程的时候需要为该进程分配系统资源，但是创建线程代价就小的多，因此使用多线程实现多任务并发行要比多进程效率高 Java语言内置了多线程功能的支持，而不是单纯的作为底层操作系统的调度方式，从而简化了java的多线程编程。 多线程的创建和启动（一）.继承Thread类创建线程 定义Thread的子类，并重写该类的run方法，该run方法的方法体就是线程所要完成的任务表，因此run()也叫做线程执行体 123456789101112131415161718public class myThread1 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"继承Thread类创建线程\"); &#125; &#125; //定义带参构造方法 public myThread1(String name) &#123; super(name); &#125; //定义无参构造方法 public myThread1() &#123; &#125;&#125; 创建Thread子类的实例，也就是创建线程对象 调用线程对象的start()方法开启动该线程 12345678910111213141516171819public class ThreadDemo1 &#123; public static void main(String[] args) &#123; //无参构造方法创建线程（默认） myThread1 mt=new myThread1(); mt.start(); //无参构造方法创建线程（设置线程名称） myThread1 mt1=new myThread1(); mt1.setName(\"哈咯\"); mt1.start(); //带参构造方法创建线程 myThread1 mt2=new myThread1(\"宝贝\"); mt2.start(); &#125;&#125; （二）.实现Runnable接口创建线程 定义Runnable接口的实现类，并重写run方法，该run()方法的方法题同样是该线程的线程执行体 123456789public class myThread2 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+i); &#125; &#125;&#125; 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象 调用线程对象的start()方法来启动该线程 123456789101112public class ThreadDemo2 &#123; public static void main(String[] args) &#123; //创建一个Runnable接口的实现类对象 myThread2 myThread2=new myThread2(); //创建Thread类对象，构造方法中传递Runnable接口的实现类对象 Thread t=new Thread(myThread2); //调用Thread里面的start方法开启多线程 t.start(); &#125;&#125; （三）.二者创建线程的对比​ 采用实现Runnable接口的方式创建多线程的优缺点 线程只是实现了接口，还能够继承其他的类 多个线程可以共享同一个target对象，所以非常适合多个线程处理同一份资源的情况。 编程稍微复杂一些。如果需要访问当前线程，必须使用Thread.currentThread()方法。 ​ 采用继承Thread类创建线程的优缺点 编写较为简单，如果要访问当前线程，无需使用Thread.currentThread()方法，只需使用this就可以获取当前线程 因为已经继承了Thread类，就无法再次继承其他类了。 线程的生命周期​ 当线程被创建并且启动之后，并非一启动就立刻进入了执行状态，也不会一直处于执行状态（除非线程执行体够短），在线程的生命周期中，一个线程要经过 新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、以及死亡（Dead），尤其是线程在启动之后不会一直霸占CPU，因此线程状态也会多次在运行、就绪之间进行切换。 （一）. 新建和就绪状态​ 当程序使用了new关键字创建了一个线程之后，该线程就处于了新建状态，这个时候的线程对象就如同其他普通的java对象一样，仅仅由java虚拟机为其分配内存并初始化其成员变量的值。但是不会表现出来任何线程的动态特征，程序也不会执行线程的线程执行体。 ​ 当线程对象调用了start()方法之后，线程进入就绪状态，java虚拟机会为其创建方法调用栈和程序计数器，不过出于这个状态中的线程并没有开始运行，只是表明该线程可以运行了，拥有了运行资格。至于呵是运行，要取决于JVM的线程调度。 （二）.运行和阻塞状态​ 如果处于新建状态的线程获取了CPU，开始执行run()方法的方法体，则该线程进入运行状态。 ​ 发生以下情况的时候线程会进入阻塞状态： 线程调用sleep()方法主动放弃处理器所占用的处理器（CPU）资源 线程调用了阻塞式的IO方法，在该方法返回之前，该线程被阻塞。 线程试图获得一个同步监视器，但是该监视器正在被其他线程占用。 线程在等待某个通知（notify） 程序调用了线程的suspend()方法将该线程挂起。（该方法容易导致死锁，所以应该尽量避免） 当线程进入阻塞状态之后，其他线程就会获得执行的机会。被阻塞的线程会在适当的时候重新进入就绪状态而非运行状态。 ​ 进入阻塞状态之后的线程发生如下特定情况的时候会解除阻塞状态： 调用sleep()方法的线程已经过了指定时间 线程调用的阻塞式IO方法已经返回 线程成功取得同步监视器 其他线程发出了一个通知（notify） 处于挂起状态的线程调用了resume()方法 （三）.线程死亡​ 线程会以如下方式结束，并进入死亡状态 run()或call()方法执行完成，线程正常结束 线程抛出一个未捕获的Exception或Error 直接调用该线程的stop()方法来结束该线程—-容易导致死锁，不建议使用 ==注意：主线程结束的时候不会对其他线程造成影响。一旦子线程启动之后就会和主线程拥有相同的地位== 线程同步​ 说到线程同步就不得不先引入另外一个话题了：线程安全。 ​ 先来看一段代码，以便更好的理解线程安全这个问题 12345678910111213141516public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket=100; //设置线程任务：卖票。 @Override public void run() &#123; while (true)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125; &#125;&#125; ​ 测试代码： 1234567891011121314151617public class TicketDemo1 &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类 RunnableImpl ri=new RunnableImpl(); //创建Thread类对象，构造方法中传递Runnable接口的实现类对象 Thread t0=new Thread(ri); Thread t1=new Thread(ri); Thread t2=new Thread(ri); //调用start方法开启多线程 t0.start(); t1.start(); t2.start(); &#125;&#125; 运行上面程序部分结果如下： 从运行结果可以看出，第100百张票被卖出多次，这显然不符合实际要求。这就是因为多个线程在公用同一份信息的时候由于线程调度不当导致的问题。 为了解决这类线程安全问题，java便引入了线程同步。通常用来解决线程安全问题可以通过以下三个方法来进行： （一）.同步代码块​ 语法格式： 1234synchronized(锁对象)&#123; 可能会出现线程安全问题的代码（访问了共享数据的代码）&#125; 锁对象：把同步代码块锁住，只让一个线程在同步代码块中执行 1.锁对象可以是任意的对象，但是建议将可能被并发访问的共享资源当成锁对象（本例中是ticket对象） 2.但是必须保证多个线程使用的锁对象是同一个 ==注意：== 任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程就会释放对该同步监视器的锁定。 synchronized关键字可以修饰方法、代码块，但是不能修饰构造器和成员变量等。 先来看一下同步代码块的具体使用（将上述代码改成如下）： 1234567891011121314151617181920212223public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket=100; //创建锁对象（可以是任意对象） Object obj=new Object(); //设置线程任务：卖票。 @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125; &#125; &#125;&#125; 测试之后，之前的线程问题不会再出现。这就代表同步代码块对线程安全问题起到了控制作用。 （二）.同步方法​ 和同步代码块相对应，同步方法是使用synchronized关键字来修饰某个方法静态和非静态，则该方法成为同步方法。 ​ 下面通过一段简单的代码来展示同步方法的使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private static int ticket=100; //创建所对象（可以是任意对象） Object obj=new Object(); //设置线程任务：卖票。 //不在run方法里直接实现卖票操作而是定义一个sellTicketStatic()函数更符合面向对象 //的设计规则 @Override public void run() &#123; System.out.println(\"this:\"+this); while (true)&#123; sellTicketStatic(); &#125; &#125; /** * 静态同步方法的锁对象是谁呢？ * this是创建对象之后产生的，静态方法优先于对象。 * 静态方法的锁对象是本类的class属性--&gt;class文件对象（反射） */ public static synchronized void sellTicketStatic()&#123; //synchronized (RunnableImpl.class)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; //&#125; &#125; /** * 定义一个同步方法 * 同步方法也会把方法内部的代码锁住 * 只让一个线程执行 * 同步方法的对象是谁？ * 就是实现类对象，new RunnableImpl() * 也就是this */ public synchronized void sellTicket()&#123; //synchronized (this)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; // &#125; &#125;&#125; ​ 从上诉代码24,25行以及41,42行中可以看出来，==静态方法的锁对象是本类的class属性–&gt;class文件对象；非静态方法的锁对象就是实现类对象：new RunnableImpl()，也就是this。== 释放同步监视器的锁定​ 任何线程在进入同步代码块或者同步方法之前必须先获得对同步监视器的锁定，既然获得了锁定，就肯定会有释放锁定的时间，那么什么时候会释放对同步监视器的锁定呢？程序无法显示释放对同步监视器的锁定，线程会在如下情况释放对同步监视器的锁定 当前线程在同步方法、同步代码块执行结束，当前线程就会释放锁定 当前线程在同步方法、同步代码块中遇到break return终止了该代码块或者方法的执行 当前线程在同步方法、同步代码块中遇到未处理的Error或者Exception,导致该代码块或方法异常结束 当前线程在执行同步方法、同步代码块时候，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器 在下列情况发生的时候不会释放锁定 线程执行同步代码块或者同步方法的时候，程序调用了Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器的锁定 线程执行同步代码块或者同步方法的时候，其他线程调用了该线程的suspend()方法将线程挂起，当前线程不会释放当前同步监视器的锁定。 （三）.同步锁（Lock）​ Lock锁是从java5开始出现的一种同步机制，它提供了比synchronized方法以及synchronized代码块更广泛的锁定操作。java为Lock提供了实现类：ReentrantLock（可重入锁）。 使用步骤： 1.在成员位置创建一个Reentrantlock对象 2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 ​ 接下来用一段代码展示Lock锁的具体使用。 123456789101112131415161718192021222324252627282930public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket=100; //1.在成员为之创建一个Reentrantlock对象 Lock l=new ReentrantLock(); //设置线程任务：卖票。 @Override public void run() &#123; while (true)&#123; //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 l.lock(); try&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125;finally &#123; //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 //为了保证锁一定会被释放，将释放锁放在finally语句中 l.unlock(); &#125; &#125; &#125;&#125; Lock本身是一个接口，无法进行实例化，只能通过其实现类来实例化。 123Lock l=new ReentrantLock();或者ReentrantLock l=new ReentrantLock(); 为了确保锁一定会被释放，应该将l.unlock();放入到finally语句中","categories":[],"tags":[],"keywords":[]},{"title":"final修饰符浅析","slug":"final修饰符","date":"2019-06-02T12:09:25.650Z","updated":"2019-07-31T01:53:27.121Z","comments":true,"path":"2019/06/02/final修饰符/","link":"","permalink":"http://yoursite.com/2019/06/02/final修饰符/","excerpt":"","text":"​ final修饰符可以用来修饰类、变量和方法。 对于一个final变量来说，无论是类变量、实例变量还是局部变量，只要满足以下三个条件就能认为final变量是一个直接量（宏）： 使用final修饰符修饰 定义改final的时候指定了初始值 该初始值可以在编译的时候就被确定下来 1.1 final成员变量成员变量随着类或者对象的初始化而初始化的。 当类初始化的时候，系统会为该类的类变量（static修饰的成员变量）分配内存，并且分配默认值。也就是说当执行静态初始化块的时候可以对类变量赋初始值。对于类变量而言必须在静态初始化块中指定初始值==或者==在声明该变量的时候指定初始值 当创建对象的时候，系统会为该对象的实例变量（没有static 修饰的成员变量）分配内存，并且分配默认值。也就是说当执行普通初始化块或者构造器的时候可以对实例变量赋初始值。对于实例变量而言必须在非静态初始化块、声明该实例变量或构造器中指定初始值，而且只能在三个地方中的一个地方指定。 ​ 对于final修饰的成员变量而言，一旦初始值确定了，那么就不能在被重新赋值了。而且成员变量的初始值必须显示的指定。 ==注意：== ​ ① 不能再静态初始化块中为实例变量指定初始值，因为静态初始化块只能访问静态成员，而实例变量是 非静态成员。 ​ ② 类变量不能在普通初始化块中指定初始值，因为类变量在类初始化的时候就已经被初始化了。 ​ 如果在构造器或者初始化块中对final修饰的成员变量进行初始化，一定不要再初始化之前直接访final成员变量，但是java允许通过方法访问final成员变量。（可以看成是设计缺陷，建议避免在初始化之前访问这一类型的变量） 1.2 final 局部变量​ 系统自身并不会对局部变量进行初始化，必须显示初始化。因此使用final修饰的局部变量的时候既可以在定义的时候进行初始化（后续代码中不能再次赋值），也可以不指定而可以在后续代码中为其赋值，但是只能进行一次赋值 1.2.1 final 修饰基本类型变量​ 不能够对基本类型变量进行重新赋值。 1.2.2 final 修饰引用类型变量​ 对于引用类型变量而言，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，也就是一直引用一个对象，但是这个对象可以发生改变。 1.3 final方法​ 被final修饰的方法不能够被重写 1.4 final 类​ final修饰的类不能够被继承。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（三）","slug":"集合知识浅析（三）","date":"2019-06-01T00:30:34.238Z","updated":"2019-06-16T08:04:04.945Z","comments":true,"path":"2019/06/01/集合知识浅析（三）/","link":"","permalink":"http://yoursite.com/2019/06/01/集合知识浅析（三）/","excerpt":"","text":"Map体系首先来一张Map体系图： 1.1 Map​ Map用于保存具有映射关系的数据，因此Map集合里面保存着两组值：key 和 value，key value可以是任何引用类型的数据，同时key不允许重复，value可以重复。key和value之间存在单向一对一的关系，通过key总是能找到唯一的确定的value。 ​ 如果将Map集合中所有的key放在一起来看的话，这些key就相当于一个Set集合（所有的key无序且不可重复），在Map接口里面的确包含了一个keySet()方法,可以用来获取这个key组成的“集合”。 ​ Map和Set之间的关系相当密切。虽然Map里面存储的是键值对，Set里面存放的是单个对象，但是由于Map集合键值对的映射关系是单向一对一，因此如果将value看成key的附属的话，那么这个Map就可以当成Set来看待。事实上，在Map中还真的有一个方法：entrySet()。这个方法可以用来将Map的每一个键值对封装在一起形成一个整体（Set）。 ​ 如果将Map集合中所有的value放在一起来看，这些value就相当于一个List集合：元素和元素之间可以重复，元素可以根据索引值来查找，只不过Map中查找value用的索引值是key值。 ==强调：==Java源码就是先实现了Map的一系列集合，然后通过包装一个value都等于null的Map集合实 现了Set集合类。 Map接口中定义了如下常用方法： 12345678910111213141516void clear():删除所有的键值对boolean containsKey(Object key):查询是否包含指定的键boolean containsValue(Object value):查询是否包含指定的键Object get(Object key):返回指定key所对应的的value。没有这个key就返回nullboolean isEmpty():判断集合是否为空Set entrySet():返回Map集合中所有键值对所组成的Set集合，集合元素都是Map.Entry对象Set keySet():返回Map中所有key组成的Set集合Collection values():返回Map中所有value组成的Collection集合Object put(Object key,Object value):向集合中添加一个键值对，如果集合中已经有了相同的key，那么就会覆盖掉原本的键值对并返回被覆盖掉的valuevoid putAll(Map m):将制定Map中的键值对添加到本Map中Object remove(Object key):删除指定key对应的键值对，返回对应的value；如果key不存在，就返回nullboolean remove(Object key,Object value):Java 8新增方法。成功删除返回true,否则返回falseboolean replace(K key,V oldValue,V new newValue):用新的value替换旧的valueint size():返回集合元素个数 Map中包括了一个内部类Entry，这个类封装了一个键值对。Entry包含如下三个方法：、 123Object getKey():返回该Entry里面包含的keyObject getValue():返回该Entry里面包含的valueObject setValue(V value):设置Entry里面包含的value值，并返回这个值 Map系列都重写了toString()方法。 1.2 HashMap / Hashtable​ HashMap和Hashtable都是Map接口的典型实现类，他们的关系完全类似于ArrayList和Vector的关系。 HashMap和Hashtable的典型区别： Hashtable是一个线程安全的Map实现类，而HashMap是县城不安全的实现。所以HashMap比HashTable的性能高一些。但是再多线程条件下，使用Hashtable会更安全。 Hashtable的key和value不能为null,否则抛出NullPointerException异常。但是HashMap的key和value可以为null ​ 和HashSet一样的是HashMap / Hashtable不能保证其中的键值对的顺序，而且判断key相等的标准也是通过equals()方法比较返回true,两个key的hashCode相等。 为了能够在HashMap / Hashtable中进行存储、获取对象，用作key的对象所属的类必须实现hashCode()和equals()方法。同时两个方法的判断标准应该一致：当两个key通过equals方法返回true时候，两个key的hashCode的值也应该相等。 1.3 LinkedHashMap​ 同HashSet有一个子类LinkedHashSet一样，HashMap也有一个LinkedHashMap子类。这个类可以保证键值对的顺序（添加顺序和取出顺序），在迭代访问Map集合的全部元素时有比较好的性能 1.4 Properties​ Properties时Hashtable的一个子类，相当于一个key和value都是String类型的Map集合。经常用于从外部文件进行读写操作。 123456String getProperty(String key):获取Properties中指定属性名对应的属性值String getProperty(String key,String defaultValue):与上一个方法基本相似，但是集合中没有key值的情况下会返回指定的默认值Object setProperty(String key,String value):设置属性void load(InputStream inStream):从属性文件中（以输入流的形式）加载键值对。把加载到的键值对追加到Properties里面。void store(OutPutStream out,String comments):将Properties中的键值对输出到指定的属性文件中（输出流的表示形式） 1.5 SortedMap / TreeMap​ SortedMap是Map的子接口，而TreeMap是SortedMap的实现类。TreeMap是一个红黑树的数据结构，每个键值对作为数的一个节点。TreeMap存储元素的时候会根据key值对节点进行排序。TreeMap可以保证所有的键值对处于排序状态，同样TreeMap也有两种排序方式： 自然排序：TreeMap的key必须实现Comparable接口，而且所有的key必须是同一个类的对象，否则会抛出ClassCastException异常 定制排序：创建TreeMap的时候，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不要求Map的key实现Comparable接口。 注意： TreeMap判断两个key是否相同的标准和TreeSet判断两个元素相等的标准（也是唯一标准）是一样的：两个key通过compareTo()方法返回0，就认为两个key相等。 如果使用自定义类作为key，那么自定义类需要重写equals()和compareTo()方法，且应该保持一致的返回结果。（和TreeSet一模一样）。 TreeMap中根据key顺序访问键值对的(部分)方法： 12345678910111213Map.Entry first/lastEntry():返回Map里面最小/大key对应的键值对，如果Map为空就返回nullObject first/lastKey():返回Map中最小/大的key值。Map为空就返回nullMap.Entry higher/lowerEntry():返回指定key后面一个为对应的键值对，如果Map为空就返回nullObject higher/lowerKey():返回指定key后面一位的key值。Map为空就返回nullSortedMap subMap(Object fromKey,Object toKey):截取，不包括右SortedMap tailMap(Object fromKey):返回该Map的子Map,key的范围是大于fromKey的所有keySortedMap headMap(Object toKey):和上面一样，key的范围是小于toKey的所有keyNevigableMap subMap(Object fromKey,boolean from,Object toKey,boolean to):截取，是否包含取决于具体参数NevigableMap tailMap(Object fromKey,boolean from):返回该Map的子Map,是否包含取决于第二个参数NevigableMap headMap(Object toKey,boolean inclusive):是否包括取决于第二个参数 1.6 IndetityHashMap​ 这个Map的实现机制和HashMap很相似，但是它在处理两个相等的key不一样。 ​ 在IdentityHashMap中，当且仅当两个key严格相等（key1==key2）的时候,IdentityHashMap才认为两个key相等。而对于普通的HashMap来说，只要key1和key2通过equals()方法返回true，并且他们的hashCode值相等即可。允许使用Null作为key和value。 1.7 WeakHashMap​ 与HashMap用法基本相似。只不过HashMap的key保留了对实际对象的强引用，这意味着只要HashMap的对象不被销毁，那么该HashMap的所有key所引用的对象就不会被垃圾回收机制回收，HashMap也不会自动删除这些key所对应的的键值对；而WeakHashMap的key只保留了对实际对象的弱引用，当垃圾回收机制回收了key所对应的的实际对象之后，WeakHashMap就会自动删除该key所对应的的键值对。 1.8 EnumMap EnumMap在内部以数组的形式保存，因此这种实现形式相当高效 根据key的自然排序（枚举值在枚举类中定义的顺序）来维护键值对的顺序 不允许使用null作为key。 创建EnumMap的时候必须指定一个枚举类吗，从而将该EnumMap集合和枚举类关联起来 各个Map实现类的性能分析： 对于Map常用的实现类而言，HshMap和Hashtable几乎一样，但是Hashtable是一个古老的、线程安全的实现类，因此性能不如HashMap。 TreeMap通常比HashMap / Hashtable要慢，特别是在插入和删除键值对的时候更慢。因为TreeMap底层采用红黑树来管理键值对。但是TreeMap有一个好处：键值对总是处于有序状态，不需要专门进行排序操作。想要获取TreeMap的元素，只需要调用keySet()，得到key组成的Set集合，然后使用toArray()方法来转换成数组，接下来使用Arrays的binarySearch()方法在已排序的数组中进行快速的查询既可。 对于一般的应用场景，应当多考虑使用HashMap,但是程序要求一个总是排序好的Map的时候就应该使用TreeMap. LinkedHashMap比HashMap要慢一些，因为需要维护两边保持键值对的添加顺序。 IdentityHashMap没有出色之处，只不过使用的是“==”来判断元素是否相等 EnumMap的性能最好，但是只能使用同一个枚举类的枚举值作为key。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（二）","slug":"集合知识浅析（二）","date":"2019-05-31T09:03:27.458Z","updated":"2019-07-31T02:24:35.507Z","comments":true,"path":"2019/05/31/集合知识浅析（二）/","link":"","permalink":"http://yoursite.com/2019/05/31/集合知识浅析（二）/","excerpt":"","text":"Collection体系先来一张Collection体系图： 1.1 Collection​ Collection是单列集合的根接口，提供了所有单列集合的共性方法。在这个接口下有两个很重要的子接口：java.util.List和java.util.Set。 ​ 其中List中元素有序，可重复，有索引因此可以使用普通的for循环进行遍历，Set中的元素无序，不可重复，没有索引因此不能够使用普通for循环进行遍历，那Collection当中提供了和索引相关的方法吗？答案是否定的。 注意：由于Collection List Set是接口，因此不能进行实例化,只能使用实现类来进行实现。 Collection常用方法 1234567891011boolean add(Object o):添加元素boolean addAll(Collection c):将集c里面的元素全部添加进指定集合void clear():清空集合boolean contains(Object o):返回集合里面是否包含指定元素boolean isEmpty():判断集合是否为空Iterator iterator():返回一个迭代器，用于遍历集合内容boolean remove():删除指定元素（删除第一个）boolean removeAll():删除指定元素（全部）boolean retain():从集合中删除集合c里面不包含的元素int size():返回集合里面元素的个数Object[] toArray():把集合转换成一个数组，所有的集合元素会变成相应的数组元素 ​ 在传统的模式下，当把一个对象放到集合里面之后，集合就会将该对象的类型当成Object类型。如果要进行集合元素的其他一些操作的话需要进行向下转型操作。但是在JDK 1.5之后，可以使用来泛型进行改进。 1.2 Set​ Set和Collection没有多大的差别。只不过在Set中不允许重复的元素且元素无序。在Collection中定义的方法，在Set中都可以使用。 1.2.1 HashSet​ HashSet是Set的典型实现类，HashSet按照Hash算法进行集合元素的存储，因此在存取和查找方面具有很好的性能。底层依赖HashMap。 特点： HashSet不保证元素的排列顺序，也就是说取出来的顺序和放进去的顺序有可能不一致 HashSet不是同步的，也即是线程不安全。 元素可以为NULL 底层是Hash表 为什么HashSet中不允许有重复元素呢？ ​ 这主要依赖于两个方法：hashCode和equals。 在介绍具体原理之前，先介绍一些相关其他知识： ​ 哈希值：是一个十进制的整数，由系统随机给出（也就是对象的地址值，是一个逻辑地址而非实际存储的物理地址），是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值，在Object类中可以使用hashCode返回对象的哈希值。 问： ​ 何时根据地址计算哈希值？（没有重写Object的hashCode()方法）何时根据属性值计算哈希值？（重写Object的hashCode()方法） ​ HashSet集合存储数据的结构(哈希表): ​ 哈希表： ​ 在JDK 1.8之前，哈希表底层采用 数组+链表 来实现。即使用链表处理冲突，具有相同Hash值的对象都存储在一个链表里面。但是当相同哈希值的元素很多的时候进行查找的效率就很低，因此在JDK1.8开始，哈希表采用了 数组+链表+红黑树 实现。当链表长度超过阈值（8）的时候，就会将链表转换成红黑树，从来减少了查找时间，提高效率。 下面来看一段代码： 12345678HashSet&lt;String&gt; set=new HashSet&lt;&gt;();String s1=new String(\"abc\");String s2=new String(\"abc\");set.add(s1);set.add(s2);set.add(\"通话\");set.add(\"重地\");set.add(\"abc\"); Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法来判断元素是否相同。 set.add(s1): add方法会调用s1的hashCode方法，计算字符串”abc”的哈希值得出结果为96354，在集合中查找有没有这个哈希值的元素，没有有的话就把s1存入集合中 set.add(s2): add方法会调用s2的hashCaaode方法，计算字符串”abc”的哈希值为96354，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较s2.equals(s1),返回true。两个元素的哈希值相同，而且equals方法返回true，可以认定两个元素相同。就不会把s2存储到集合中。 set.add(&quot;通话&quot;)： add方法会调用hashCode方法，计算字符串“重地”的哈希值为1179395，在集合中没有找到相同哈希值的元素，就会将这个元素添加到集合中 set.add(&quot;重地&quot;): add方法会调用 “通话” 的hashCode方法，计算字符串”abc”的哈希值为1179395，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较&quot;通话&quot;.equals(&quot;重地&quot;),返回false。两个元素的哈希值相同，equals方法返回false，可以认定两个元素不相同。就会把s2存储到集合中。 1.2.2 LinkedHashSet​ LinkedHashSet是HashSet的一个子类，不过他与HashSet不同的是，LinkedHashSet底层多了一个链表，这样能够保证LinkedHashSet的元素是有序的 1.2.3 TreeSet​ TreeSet是SortedSet接口的实现类,正如名字所示TreeSet可以确保集合元素处于排序状态。和HashSet相比,还额外提供了如下方法： 12345678Comparator comparator():如果TreeSet采用了定制排序，那么该方法会返回定制排序所使用的Comoparator，如果采用的是自然排序就返回nullObject first():返回集合中的第一个元素Object last():返回集合中的最后一个元素Object lower(Object e):返回集合中位于指定元素之前的元素Object higher(Object e):返回集合中位于指定元素之后的元素SortedSet subSet(Object fromElement,Object toElement):返回此Set的子集合，包左不包右SortedSet headSet(Object toElement):返回此Set子集，由小于toElement的元素组成SortedSet tailSet(Object fromElement):返回此Set子集，由大于等于toElement的元素组成 ​ TreeSet支持的的排序分为两种：自然排序（默认情况）/定制排序 自然排序：​ TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小，然后将集合元素按照升序排列，这种方式就是自然排序。 ​ 如果试图想TreeSet集合添加一个对象，在自然排序条件下该对象所属的类必须实现Comparable接口，否则程序会出现运行时期异常：ClassCastException。并且由于大部分类在实现compareTo(Object obj)方法的时候，都需要将被比较对象obj抢之类型转换成相同类型（因为只有相同类的两个实例才会比较大小），这也就要求了TreeSet集合里面的对象都属于一个类。 实现了Comparable接口的常用类： 1BigDecimal、BigInteger / Character / Boolean / String /Date、Time ​ 注意： 和HashSet判断对象是否相同不一样的是TreeSet判断两个对象是否相同的唯一标准就是通过调用该对象的compareTo(Object obj)方法和容器中的其他对象比较大小，如果返回值是 0 ，那么TreeSet就会认为他们相等，否则就认为他们不相等。 HashSet根据哈希值来找到元素在集合中的存储位置，TreeSet则是根据红黑树的结构来确定元素在集合中的位置。虽然往TreeSet集合中添加自定义对象的时候可以添加多种类型的对象（自定义类必须实现Comparable接口并且实现compareTo方法没有进行强制类型转换），但是当试图取出集合元素的时候，不同类型的元素依然会发生ClassCastExcepion异常。所以！如果希望TreeSet能够正常运行，TreeSet只能添加同一种类型的对象。 当需要把一个对象放入TreeSet集合中的时候，重写该对象对应类的equals方法时候应该保证该方法与compareTo(Object obj)有一样的结果。规则如下：如果两个对象通过equals方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较应该返回 0 。因为如果compareTo(Object obj)返回0，TreeSet就不会让元素进入集合内（因为compareTo(Object obj)的返回结果是作为TreeSet元素是否相等的唯一标准），但是equals方法返回false时候代表两个元素不相等，结果TreeSet和Set规则冲突。 #####定制排序： ​ TreeSet的自然排序是根据集合元素的大小进行升序排序。如果需要实现定制排序（比如降序排序），则需要在创建TreeSet的时候传入Comparator对象。这个接口里面包含了一个int compare(T t1,T t2)方法。根据返回值和0的关系来判断大小。 1.2.4 EnumSet​ EnumSet是一个专门为枚举设计的类，其中的元素必须是指定枚举类型的枚举值。该枚举类型在创建EnumSet的时候现实或者隐含的指定。也是有序的，不允许空值，否则会抛出NullPointerException异常。 ​ EnumSet没有暴露任何构造器来创建该类的实例，也就是说无法像其他集合一样new一个对象出来。但是它提供了如下方法来创建EnumSet对象： 1234567EnumSet allOf(Class elementType):创建一个包含指定枚举类里面所有枚举值的EnumSet集合EnumSet copyOf(Collection c):使用普通集合来创建EnumSet集合EnumSet copyOf(EnumSet e)EnumSet noneOf(Class elementType):使用指定元素类型来新建一个空的EnumSet集合EnumSet of(E first，E...rest):创建一个包含一个或多个枚举值得EnumSet集合。传入的枚举值必须属于同一个值EnumSet range(E from,E to):创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合EnumSet complementOf(EnumSet s):创建一个其元素类型与指定EnumSet里元素类型相同的集合，新的集合包含原来那个集合不包含的，此枚举类剩下的枚举值 1.2.5 各个Set实现类的性能分析HashSet和TreeSet是Set的两个典型实现。那么在应用中应该如何选择呢？ 记住一句话：只有需要一个保持排序的Set集合的时候再选择TreeSet,否则就选择HashSet。此外HashSet有一个子类：LinkedHashSet,对于普通的插入删除操作，性能要比HashSet稍微差一些，因为维护链表会造成额外的开销，但是由于有了链表的存在，使得LinkedHashSet在遍历方面会更快。 EnumSet是所有Set实现类中性能最好的，但是它只能保存同一个枚举类的枚举值作为集合元素。 HashSet TreeSet EnumSet 都是线程不安全的，如果有多个线程同时访问Set集合并且超过一个线程对Set集合进行了修改，那么必须使用Collections工具类的synchronizedSortedSet方法来包装Set集合,代码如下： ==SortedSet s=Collections.synchronizedSortedSet(new TreeSet(…));== 1.3 List（线性表接口）​ List作为Collection接口的子接口，元素有序，可重复，能够使用collection里面所有的方法。而且因为List是有序的，因此List里面还有针对于索引进行操作的方法。 12345678void add(int index,Object element):将元素插入到指定的索引位置boolean addAll(int index,Collection c):将集合c中的所有元素插入到List集合的index索引位置Object get(int index):返回集合index索引位置处的元素int indexOf(Object o):返回对象在List集合中第一次出现的位置int LastIndexOf(Object o):返回对象在List集合中最后一次出现的位置Object remove(int index):删除并返回指定位置的元素Object set(int index,Object element):将index索引处的元素设置成element，同时返回被替换的对象List subList(int fromIndex,int toIndex):返回指定范围的集合，包左 不包右 ​ 所有的List实现类都可以使用以上方法。 1.3.1 ArrayList / Vector​ ArrayList和vector是List的典型实现，完全支持List接口的全部功能。 ​ ArrayList和Vector都是基于数组实现的List类，他们封装了一个动态的、允许被再次分配的Object数组。可以使用initialCapacity来设置该数组的长度，当添加的元素超过数组的长度之后，这个initialCapacity会自动增加。不过在实际开发中，可以使用ensureCapacity(int minCapacity)方法一次性的增加initialCapacity.如果在创建对象的时候不指定初始化长度，那默认长度就是 10。 ​ 重新分配Object数组的两个方法： 12void ensureCapacity(int minCapacity)：将ArrayList或Vector数组增加至大于或等于minCapacity值void trimToSize():调整ArrayList或Vector数组长度为当前元素个数 ​ ArrayList和Vector的一个显著区别就是：ArrayList是线程不安全的，当多个线程访问同一个ArrayList集合并且有超过一个线程修改了ArrayList集合，那么程序必须手动保证该集合的同步性。Vector是线程安全的，无需保证集合的同步性，但也就是因为这样使得Vector的性能要比ArrayList性能要低。 ​ 总结：推荐选择ArrayList集合使用，线程安全的问题使用Collections工具类来保证。 1.3.2 Stack​ Stack是Vector的一个子类，名为“栈”，特点是“先进后出”、线程安全但是性能较差。 ​ Stack里面有如下几个方法： 123Object peek():返回栈的第一个元素，但是不出栈Object pop():返回栈的第一个元素，出栈void push():向栈中压入元素 ​ 由于Stack是Vector的子类，同样建议少用Stack,如果需要使用“栈”这种数据结构的话，可以考虑ArrayDequeue(之后介绍) 1.3.3 固定长度的ArrayList​ 在介绍数组的时候提到过一个操作数组的工具类：Arrays ，这个类中提供了asList(Object...a)方法，这个方法可以将数组或者指定个数的对象转换成一个List集合，这个集合就不再是ArrayList或者Vector实现类的实例了，而是Arrays的内部类ArrayList的实例。 ​ Arrays.ArrayList是一个固定长度的List集合，程序只能对其进行遍历访问，而不能进行任何改变集合的操作。 1.3.4 LinkedList​ LinedList是List的一个实现类，说明他是一个List集合，可以根据索引来随机访问元素值。底层是一个双向链表，查询慢，增删快。同时也实现了Deque接口,因此也可以被当做双端队列来使用，同时还能被当成“栈”来使用。 来通过一些代码示范LinkedList作为 List集合、双端队列、栈的用法 123456789101112131415161718192021222324252627LinkedList books=new LinkedList();//将元素加入“队列”尾部 books.offer(\"123\");//将元素加入“栈”的顶部books.push(\"456\");//将元素加入“队列”的头部，相当于“栈”的顶部books.offerFirst(\"789\");//输出集合System.out.println(books);System.out.println(\"=====================\");//遍历“集合”元素for (int i = 0; i &lt; books.size(); i++) &#123; System.out.println(books.get(i));&#125;System.out.println(\"=====================\");System.out.println(books.peekFirst());//访问栈顶元素System.out.println(books.peekLast());//访问栈底元素System.out.println(books.pop());//弹出栈顶元素System.out.println(books);System.out.println(\"=====================\");System.out.println(books.pollLast());//删除队列最后一个元素 输出结果如下： 123456789101112[789, 456, 123]=====================789456123=====================789123789[456, 123]=====================123 1.3.5 各种线性表性能分析​ 一般来说，由于数组以一块连续内存区域来保存所有的数组元素，因此数组在随机访问时候性能最好，所以所有内部以数组作为底层实现的集合在随机访问的时候性能都很好；而内部用链表作为底层实现的集合在进行插入、删除操作的时候性能比较好。总体来说ArrayList的性能要比LinkedList的性能要好,因此大多数情况下建议使用ArrayList ​ 使用List集合的建议： 如果需要遍历集合元素，对于ArrayList / Vector,应该使用随机访问方法get()来遍历集合元素，这样性能更好；对于LinkedList应该使用迭代器（Iteator）来遍历集合。 如果需要经常执行插入、删除操作对集合进行改变，可以考虑使用LinkedList集合，因为使用ArrayList / Vector的话可能需要经常重新分配底层的数组大小，性能会受到影响。 如果有多个线程访问同一个List集合，应该考虑利用Collections将集合包装成线程安全的集合。 1.4 Queue(队列)Queue用来模拟队列这种数据结构。 在Queue接口中定义了如下方法： 123456void add(Object o):将元素添加到队列尾部void offer(Object o):将元素加入队列的尾部，在队列容量有限的时候，这种方法更好。Object element():获取队列头部元素，但是不删除Object remove():获取队列头部元素并删除Object peek():获取队列头部元素，不删除，如果队列为空，返回 nullObject poll():获取队列头部元素，删除。队列为空的话返回null 1.4.1 Deque(上图名称错误)​ Deque是Queue接口的子接口，代表一个双端队列，Deque接口里面定义了一些操作双端队列的方法。多数方法只需要在Queue接口提供的方法后加上First / Last即可。这里只介绍一些额外的方法： 12Iterator descendingIterator():返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。（反向迭代器）和常用迭代器迭代的结果是相反的。Object removeFirst/LastOccurrence(Object o):删除双端队列第一次/最后一次出现的元素 ​ Queue方法和Deque方法以及Stack比较 Queue的方法 Deque的方法 Stack add(e) / offer(e) addLast(e) / offerLast(e) push(e) remove() / poll() removeFirst() / pollFirst() pop element() / peek() getFirst() / peekFirst() peek 1.4.2 ArrayQueue​ ArrayQueue是Deque的一个典型实现类。这是一个基于数组的双端队列。创建Deque的时候同样可以指定一个numElements参数,用于指定底层的Object[] 数组的长度，不指定的话就是默认长度：16。和ArrayList两个集合类的实现机制基本相似，当集合元素超过数组长度的时候，系统会自动在底层重新分配一个数组。 ​ 前面说到了当程序中需要使用栈这种数据结构的时候应该尽量避免使用Stack,因为性能较差。在这里推荐使用ArrayQueue。 ​ ArrayQueue既可以当做队列使用，也可以当做栈使用。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（一）","slug":"集合知识浅析（一）","date":"2019-05-30T09:17:17.601Z","updated":"2019-06-13T04:25:28.676Z","comments":true,"path":"2019/05/30/集合知识浅析（一）/","link":"","permalink":"http://yoursite.com/2019/05/30/集合知识浅析（一）/","excerpt":"","text":"集合知识浅析（一）1.1集合概述 Java是面向对象的语言，面向对象语言对事物的描述是通过对象体现的，为了方便对多个对象 进行操作，就必须把这个对象进行存储，但是想要存储多个对象，就不能是一个基本数据类型 而应该是一个容器类型。 为什么不选择数组或者字符缓冲区来存储多个对象呢？ ​ 数组和StringBuffer就是容器，但是StringBuffer的结果是一个字符串，不一定能够满足要求。 因此只能选择数组作为容器，即对象数组，但是对象数组无法适应变化的需求，因为数组长度固定。因此Java提供了相应的集合类用来使用 数组和集合的区别: 1）数组长度固定，集合长度可变； 2）数组用来存储同一类型数据，集合可以存储不同类型 3）数组可以用来存储基本数据类型，也可以用来存储引用类型集合只能存 储引用类型 集合可以存储多个元素的，但是，存储多个元素也是有不同需求的，比如说，多个元素中不能有相同 元素，针对不同的需求，Java提供了不同的集合类，多个集合类的数据结构不同，但是绝对有共性。通过不断提取共性，就可以得到所有集合类的一个总集合：Collection，Map 数据结构:数据的存储方式 1.2继承关系Java的集合类主要由Collection和Map两个接口派生出来。也即： Map的继承关系： Collection的继承关系：","categories":[],"tags":[],"keywords":[]},{"title":"泛型浅析","slug":"泛型浅析","date":"2019-05-30T02:37:42.560Z","updated":"2019-06-16T06:45:34.606Z","comments":true,"path":"2019/05/30/泛型浅析/","link":"","permalink":"http://yoursite.com/2019/05/30/泛型浅析/","excerpt":"","text":"泛型首先来看一下什么叫做泛型​ 泛型是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊类型。也叫做参数化类型，把类型当作参数一样传递。 ​ 其实说白了，可以将泛型看成对集合里面元素的一种限制手段 ​ 简而言之就是使用集合那种结构的时候会出现黄色警告线，但是往往我们会忽略这样的警告，进而导致类型不匹配等不可预知的错误。但是采用泛型的话会在创建对象或者调用方法的时候如果出现参数类型不匹配的结果会直接报错，而不是仅仅给出警告。 格式： 12&lt;数据类型&gt; 此处的数据类型只能是引用类型。 使用位置： 1看API文档，如果类，接口，抽象类后面跟有&lt;E&gt;就说明要使用泛型。一般来说就是在集合中使用(如果集合不使用泛型的话，默认就是Object类型，可以存储任意类型的数据。 泛型应用： 1234567891011121314151617181920212223泛型类： 把泛型定义在类上 格式：public class 类名&lt;泛型类型1....&gt; 注意：泛型类型必须是引用类型 举例： public class Test&lt;E&gt;&#123; private E name; public void setName(E name)&#123; this.name=name; &#125; &#125;泛型方法： 把泛型定义在方法上 格式：public &lt;泛型类型&gt; 返回类型 方法名(泛型类型) 举例： public &lt;E&gt; void method(E e)&#123; ... &#125;泛型接口： 把泛型定义在接口上 格式：public interface 接口名&lt;泛型类型1....&gt; 举例： public interface myInterface&lt;E&gt;&#123;&#125; 注意：泛型是没有继承概念的 泛型通配符​ 当使用泛型类或者接口的时候，在传递的数据中如果泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符之后，只能使用Object类中的共性方法，集合中元素自身的方法无法使用。不能创建对象使用，只能作为方法的参数使用 高级使用 —-受限泛型​ 设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以设置一个上限或者下限。 泛型的上限：​ 格式：类型名称&lt;? extends 类&gt; 对象名称 ​ 意义：只能接受该类型以及其子类 ​ 举例：public static void getElement(Collection&lt;? extends XXX&gt; coll){} 泛型的下限​ 格式：类型名称&lt;? super 类&gt; 对象名称 ​ 意义：只能接受该类型以及其父类 ​ 举例：public static void getElement(Collection&lt;? super XXX&gt; coll){}","categories":[],"tags":[],"keywords":[]},{"title":"String , String Builder , String Buffer的区别浅析","slug":"String , String Builder , String Buffer的区别","date":"2019-05-29T13:14:53.886Z","updated":"2019-07-16T10:28:10.712Z","comments":true,"path":"2019/05/29/String , String Builder , String Buffer的区别/","link":"","permalink":"http://yoursite.com/2019/05/29/String , String Builder , String Buffer的区别/","excerpt":"","text":"String , String Builder , String Buffer的区别首先来看这三个类分别代表什么什么意思​ String类代表字符串 ，但是它是代表一个常量，底层是一个被final修饰的数组，它的值在创建之后不能够被更改。 ​ StringBuilder（字符串缓冲区）与StringBuffer（字符串缓冲区）虽然也是代表字符串并且底层也是数组，但是这个数组没有被final修饰，他们都是可变量，他们在创建对象实例并且赋值之后可以重新更改值得内容。 ​ 这三者的区别主要存在与两点：运行速度和线程安全 运行速度:​ 三者的运行速度大小如下：StringBuilder &gt; StringBuffer &gt; String ​ 原因： ​ 先来看一段代码: 123456String s=&quot;Hello&quot;;System.out.println(s);//HelloSystem.out.println(s.getBytes());//[B@3f99bd52s=s+&quot;World&quot;；System.out.println(s);//HelloWorldSystem.out.println(s.getBytes());//[B@119d7047 ​ 上述代码输出的结果是Hello [B@3f99bd52 和HelloWorld [B@119d7047,这段代码在虚拟机上的执行过程实际是这样的：首先，在创建了一个对象s之后，将Hello赋值给了s，然后又创建了一个同名对象s，并且将之前的s对象的值和World进行拼接之后赋值给了这个新的s。那么第一次创建的对象s去哪了呢？答案是被虚拟机的垃圾回收机制回收掉了（连同对象s 的值）。因此，在对String类型的对象进行操作的时候实际上就是一个不断创建同名新对象的删除旧对象的一个过程，这期间需要不断的消耗虚拟机的资源，因此执行速度很慢。 ​ 但是StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 线程安全:​ StringBuilder是线程不安全的，StringBuffer是线程安全的 总结： String：适用于少量的字符串操作的情况 String Builder：适用于单线程下在字符缓冲区进行大量操作的情况 String Buffer：适用多线程下在字符缓冲区进行大量操作的情况 StringBuilder/StringBuilder - - &gt; String ​ 可以使用StringBuilder的构造方法：StringBuilder(String str) String - - &gt;StringBuilder/StringBuilder ​ 可以使用StringBuilder的toString方法 String常用构造方法： 123456public String()：空构造public String(byte[] bytes)：把字节数组转换成字符串public String(byte[] bytes,int offset,int length)：把字节数组一部分转换成字符串public String(char[] value)：把字节数组转换成字符串public String(byte[] bytes,int offset,int count)：把字符数组一部分转换成字符串public String(String original)：把字符串常量值转成字符串,换句话说新创建的字符串是参数字符串的副本。 常用函数： 123456789101112131415161718192021222324252627282930313233343536String类的获取功能 int length();获取长度 char charAt(int index);返回指定索引位置的字符 int indexOf(int ch);返回指定字符在此字符串第一次出现的索引 int indexOf(String str);返回指定字符串（首字母）在此字符串第一次出现的索引 int indexOf(int ch,int fromIndex);返回指定字符在此字符串从指定位置之后第一次出现的索引 String substring(int start);截取字符串，默认到末尾。返回被截取的子串。 String substring(int start,int end); String类的转换功能 byte[] getBytes();把字符串转换成字节数组 char[] toCharArray();把字符串转换成字符数组 static String valueOf(char[] chs);把字符数组转换成字串，其他类型数组用不了此方法 static String valueOf(int i);把某种类型数据转换成字符串(四类八种除了byte/short,外加) String类的valueOf方法可以把任意类型的数据转换成字符串 toCharArray():可以将字符串转化成数组 String toLoweCase(); String toUpperCase(); String concat(String str):进行字符串的拼接 toCharArray(): 将此字符串转换为新的字符数组。 String类的其他功能 替换功能 String replace(char old,char new); String replace(String old,String new); String replaceFirst(String regex, String replacement)用给定的序列替换调用者的第一个子字符串 去除字符串两端空格 String trim(); 按照字典顺序比较字符串 int compareTo(String str); int compareToIgnoreCse(String str); 判断功能： boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开头。 boolean startsWith(String prefix, int toffset) 测试在指定索引处开始的此字符串的子字符串是否以指定的前缀开头。 拆封功能 String[] split(String regex)：根据给定的表达式拆分此字符串 注意：1.String s=new String(&quot;hello&quot;);String s=&quot;hello&quot;区别： ​ 前者创建两个对象（常量池中没有这个hello对象的时候）或一个对象（常量池中有这个hello对象的时候），后者创建一个对象（常量池中没有这个hello对象的时候）或不创建对象（常量池中有这个hello对象的时候） 2.字符串如果是变量相加，先开空间，在拼接。 12String s1=\"Hello\",s2=\"World\";s1+s2 3.字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1\"Hello\"+\"World\" String Builder和String Buffer常用构造方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 1234StringBuilder() 构造一个没有字符的字符串构建器，初始容量为16个字符。 StringBuilder(int capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。 StringBuilder(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。 StringBuilder(String str) 构造一个初始化为指定字符串内容的字符串构建器。 常用方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 123456789101112131415StringBuilder append(参数) 将指定参数的字符串表示附加到序列中。除了byte/short StringBuilder append(char[] str) 将 char数组参数的字符串表示追加到此序列。 StringBuilder append(char[] str, int offset, int len) 将 char数组参数的子阵列的字符串表示追加到此序列。 StringBuilder append(String str) 将指定的字符串附加到此字符序列。 StringBuilder append(StringBuffer sb) 追加指定的 StringBuffer到这个序列。 int capacity() 返回当前容量。 char charAt(int index) 返回指定索引位置的值void setCharAt(int index, char ch) 设置指定位置的值为ch StringBuilder reverse() 导致该字符序列被序列的相反代替。StringBuilder replace(int start, int end, String str) 用指定的 String的字符替换此序列的子字符串中的字符 int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 int indexOf(String str, int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串的最后一次出现的字符串中的索引，从指定索引开始向后搜索。 String toString() 返回表示此顺序中的数据的字符串。","categories":[],"tags":[],"keywords":[]},{"title":"接口的知识浅析","slug":"接口的知识浅析","date":"2019-05-26T15:58:29.816Z","updated":"2019-07-19T05:58:54.308Z","comments":true,"path":"2019/05/26/接口的知识浅析/","link":"","permalink":"http://yoursite.com/2019/05/26/接口的知识浅析/","excerpt":"","text":"接口什么是接口？​ 接口是多个类的一种公共规范，它是一种引用数据类型。接口中最重要的内容是接口中的抽象方法。 接口如何定义？格式：​ 1public interface 接口名称&#123;...&#125; 如何使用接口呢？1.接口不能直接使用，必须有一个“实现类”来实现接口格式： 1public class 实现类名称 implements 接口名称1,接口名称2...&#123;...&#125; 2.接口的实现类必须重写接口中的所有抽象方法3.创建实现类的对象，进行使用如果是Java 7,那么接口中可以包含的内容有：常量/抽象方法 如果是Java 8,还可以额外包含：默认方法/静态方法 如果是Java 9,还可以额外包含：私有方法 接口中的抽象方法（最重要的）格式： 1public abstract 返回值类型 方法名称(参数列表) 注意： ​ public abstract这两个关键字修饰符是固定格式，但是可以选择性的省略 接口中的default（默认）方法格式： 1public default 返回值类型 方法名称(参数列表)&#123;...&#125; 这个默认方法有什么用？​ 作用：默认方法会被实现类自动继承，因此可以用于接口升级。 什么叫做接口升级？​ 比如有一个接口A，并且B,C实现该接口，但是如果接口A中进行了抽象方法的修改，那么相应的就要去修改B,C 但是现实开发中这种并无法理想实现（比如实现了A接口的某个方法已经投入了大规模使用），因此这个时候进行接口的升级操作就需要用到这个默认的方法。 ​ 高级吗？一点都不高级。就是只需要把需要接口中新增的方法声明称默认方法就可以了。😂 接口中的静态方法（Java 8开始）格式： 1public static 返回值类型 方法名称(参数列表)&#123;...&#125; 接口中静态方法的使用​ 通过接口名称直接调用： 1接口名称.静态方法名(参数) ​ 注意： ​ 不能通过接口实现类的对象去调用接口中的静态方法 ​ 例如： 1234567891011121314public interface A&#123; public static void test()&#123; System.out.println(\"你好\"); &#125;&#125;public class B implements A&#123; public static void main(String[] args)&#123; A.test();//正确 new B().test();//错误 &#125;&#125; 接口中的私有方法（Java 9开始）1.普通私有方法​ 作用：解决多个默认方法之间重复代码问题 ​ 格式： 1private 返回值类型 方法名称(参数列表)&#123;...&#125; 2.静态私有方法​ 作用：解决多个静态方法之间重复代码问题 ​ 格式： 1private static 返回值类型 方法名称(参数列表)&#123;...&#125; 私有方法有啥用啊？来看一段代码(以普通私有方法为例)： 12345public interface A&#123; public default void methodDefault1&#123;...&#125; public default void methodDefault2&#123;...&#125;&#125; 假设methodDefault1方法和methodDefault2方法中有大量重复的代码的话,可以将这部分重复代码抽离出来形成一个新的方法。但是！抽离出来的这部分方法应当只能由methodDefault1和methodDefault2来使用，而不能由实现类来使用 将公共代码抽离出来，这样一来，便无法在实现类中访问到methodCommon(),如下： 12345678910111213public interface A&#123; public default void methodDefault1&#123; ... methodCommon(); &#125; public default void methodDefault2&#123; ... methodCommon(); &#125; private void methodCommon()&#123; 公共方法 &#125;&#125; 接口中的常量​ 接口中也可以定义”成员变量”，但是必修使用 public static final 三个关键字修饰。从效果上看，相当于接口的常量。这三个关键之可以省略，但是即使省略之后，也默认还是这三个修饰。而且必须赋值。 格式： 1public static final 数据类型 常量名称 = 数据值 如何访问呢？ ​ 这样理解：修饰符里面由static关键字，那么自然只能通过接口名进行访问：接口名.常量名 接口使用注意事项​ 1.接口内没有静态代码块或者构造方法（有了构造方法就可以直接new了） ​ 2.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要重写一次就行，而且必须重写。 ​ 3.如果实现类没有完全重写接口的抽象方法，那么实现类同样是一个抽象类 ​ 4.接口与接口之间是多继承的（类和类之间单继承，类和接口之间多实现） ​ 5.多个父接口当中的抽象方法重复没事，但是默认方法重复的话，那么子接口必须进行默认方法的重写并且要带有default关键字","categories":[],"tags":[],"keywords":[]}]}