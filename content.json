{"meta":{"title":"向阳成长","subtitle":"个人博客","description":"几乎所有的事情都具有多面性","author":"小青年","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"内部类浅析","slug":"内部类","date":"2019-06-10T02:13:43.888Z","updated":"2019-06-10T07:35:10.572Z","comments":true,"path":"2019/06/10/内部类/","link":"","permalink":"http://yoursite.com/2019/06/10/内部类/","excerpt":"","text":"内部类​ 定义在其他类内部的类叫做内部类。 内部类作用： * 提供了更好的封装性，可以将内部类隐藏在外部类之中，不允许同一个包中的其他类访问 * 内部类可以直接访问外部类的私有数据，但是外部类不能访问内部类的实现细节，比如内部类的成员变量 * 匿名内部类适合创建仅需使用一次的类 内部类和外部类的一些区别： * 内部类可以比外部类多使用三个修饰符：private protected static * 非静态内部类不能拥有静态成员 （一）非静态内部类​ 格式： 123public class 外部类&#123; //定义内部类&#125; 如果外部类、内部类以及内部类的函数中存在同名变量的话，如何区分访问这些变量呢？ 通过this、外部类名.this来区分内部类变量以及外部类变量。 ​ 非静态内部类可以访问外部类的私有成员，但是外部类不能直接访问内部类的成员，因为非静态内部类的成员只在非静态内部类范围内是可知的。如果外部类需要访问非静态内部类的成员，必须显式创建非静态内部类的对象来点用访问其实例成员 ​ ==注意：==非静态内部类不可以有静态初始化块，但是可以有普通初始化块。 （二）静态内部类​ 使用static修饰的内部类就是静态内部类。这个类就属于外部类本身，而不是属于外部类的某个对象。 ​ ==注意：==静态内部类可以包含静态成员，也可以包含非静态成员。静态内部类不能访问外部类的实例成员，只能访问外部类的类成员，即使是静态内部类的实例方法也不能访问外部类的势力成员，只能访问外部类的静态成员。 ​ 静态内部类是外部类的静态成员，因此外部类的所有方法、所有初始化块都可以使用静态内部类来定义变量，创建对象。 ​ 外部类不能直接访问静态内部类的成员，但是可以使用静态内部类名作为调用者来访问静态内部类的类成员，也可以使用静态内部类的类对象作为调用者来访问静态内部类的实例成员。 （三）局部内部类​ 如果将一个类放在方法中定义，那这个类就是局部内部类。局部内部类仅仅在该方法体内有效且由于局部内部类不能再外部类的方法以外其他地方使用，所以不能使用访问控制符和static修饰。若需要在局部内部类中定义变量，创建实例或者派生子类只能在局部内部类所在的方法内进行。 （四）匿名内部类​ 匿名内部类本质是一个对象，是一个继承了该类或实现了该接口的子类匿名对象。 ​ 定义格式： 123new 实现接口() | 父类构造器&#123; //匿名内部类类体&#125; ​ 从定义格式可以看出来，匿名内部类必须继承一个父类或者实现一个接口，但最多只能继承一个父类或者实现一个接口 ==注意：== * 匿名内部类不能是抽象类。因为系统在创建匿名内部类的时候会立即创建匿名内部类的对象，因此不允许将匿名内部类定义成抽象类 * 匿名内部类不能定义构造器。因为匿名内部类没有类名，但是匿名内部类可以定义初始化块。 以下通过一段代码来观察匿名内部类的使用： 12345678910111213141516171819202122//首先定义一个接口interface A&#123; public void a();&#125;//测试类public class B&#123; public static void main(String[] args)&#123; B b=new B(); b.test(new y() &#123; @Override public void a() &#123; System.out.println(\"你好\"); &#125; &#125;); &#125; public void test(A a)&#123; //执行语句 &#125;&#125; 上述是使用了匿名内部类的形式，那么常规方法是什么样子的呢？ ​ 首先需要一个类是实现这个接口，并且重写接口里面的方法 123456public class C implements A&#123; @Override public void a() &#123; System.out.println(\"你好\"); &#125;&#125; 然后得到一个实现类的对象，并作为test()方法的参数 12C c=new C();b.test(c); ​ 这样可以看出来匿名内部类的好处了吧？如果有多个类都实现了这个接口的话，就要实现多个实现类。太麻烦！！！ （五）内部类的使用1.在外部类内部使用内部类​ 在外部类内部使用内部类的时候，与平常使用普通类没有太大区别。一样可以直接通过内部类类名定义变量，通过new关键字调用内部类构造器创建实例。在外部类内部定义内部类的子类与平常定义子类也没有区别。 ​ 唯一区别：不要再外部类的静态成员（静态方法/静态初始化块）中使用非静态内部类 2.在外部类以外使用非静态内部类​ 如果希望在外部类意外的地方访问内部类（静态和非静态），那么内部类不能使用private修饰。private修饰的内部类只能在外部类的内部使用。对于其他访问控制符修饰的内部类在外部类意外的地方访问按照访问权限使用： * 省略修饰符：只能被与外部类处于**同一个包中的其他类**使用 * protected：可以被与外部类处于**同一包中的其他类**和**外部类的子类**访问 * public：任何地方都可以使用 在外部类以外的地方定义内部类（静态/非静态）变量以及内部类（非静态）实例的语法格式： 12外部类名.内部类名 变量名 new 外部类名().new 内部类构造器() 3.在外部类以外的地方使用静态内部类​ 因为静态内部类是和外部类类相关的，所以创建静态内部类对象的时候无需创建外部类对象。具体语法格式如下： 1new 外部类名.内部类构造器();","categories":[],"tags":[],"keywords":[]},{"title":"多线程浅析（二）--线程通信","slug":"多线程浅析（二）","date":"2019-06-09T13:15:49.487Z","updated":"2019-06-11T09:17:25.941Z","comments":true,"path":"2019/06/09/多线程浅析（二）/","link":"","permalink":"http://yoursite.com/2019/06/09/多线程浅析（二）/","excerpt":"","text":"传统的线程通信​ Object类中有三个方法：wait()、notify()、notifyAll()，这三个方法并不属于Thread类，而是属于Object类。但是这三个方法必须由同步监视器对象来调用，主要可以分成以下两种情况： * 对于使用synchronized修饰的同步方法，因为该类的默认实例（this）就是同步监视器，所以可以直接在同步方法中直接调用这三个方法 * 对于使用synchronized修饰的同步代码块，同步监视器是synchronized后括号里面的对象，所以必须使用该对象调用这三个方法。 接下来来看这三个方法的相关大致解释： wait():致使当前线程等待，直到其他线程调用该同步监视器的notify()或者notifyAll()方法来唤醒该线程。 notify():唤醒此同步监视器上等待的单个线程。如果有多个线程在该同步监视器上等待，将会随机唤醒其中一个。 notifyAll():唤醒等待在该同步监视器上的所有线程。 接下来通过一段代码来看具体的操作（老板顾客案例）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package thread.watiandnotify;/** * @Author: 小青年XQP * * 等待唤醒案例： * 创建一个顾客线程（消费者）：告知老板要的包子的种类和数量，调用wait方法，放弃cpu的执行，进入到WAITING状态（无限等待） * 创建一个老板线程（生产者）：花了5秒做好包子，调用notify()方法唤醒顾客吃包子 * 注意： * 顾客和老板线程必须使用同步代码块包裹起来，保证等待和唤醒只能有一个在执行 * 同步使用的锁对象必须保证是唯一的 * 只有锁对象才能调用wait()和notify()方法 * * Object类中的方法： * void wait() * 在其他线程调用此对象的notify()或notifyAll()方法钱，导致当前线程等待 * void notify() * 唤醒在此对象监视器上等待的单个线程 * 会继续执行wait后面的代码 * */public class Demo1 &#123; public static void main(String[] args) &#123; //创建锁对象,保证唯一 Object obj=new Object(); //创建一个顾客线程 new Thread()&#123; @Override public void run() &#123; //保证等待和唤醒的线程只有一个在执行，需要使用同步技术 synchronized (obj)&#123; System.out.println(\"告知老板要的包子的种类和数量\"); //调用wait方法，放弃cpu的执行，进入到WAITING状态（无线等待） try &#123; obj.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"正在吃包子！！！\"); &#125; &#125; &#125;.start(); //创建一个老板线程 new Thread()&#123; @Override public void run() &#123; try &#123; Thread.sleep(5000);//花费5秒做包子 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (obj)&#123; System.out.println(\"老板5秒中之后做好包子，喊顾客吃包子\"); //唤醒顾客吃包子 obj.notify(); &#125; &#125; &#125;.start(); &#125;&#125; 使用Condition控制线程通信​ 如果程序不实用synchronized关键字来保证同步，而是直接使用Lock锁来保证同步，那么系统中就不存在隐式的同步监视器，也就不能使用wait()、notify()、notifyAll()。同时，Condition类提供了如下相应的方法： await():类似于隐式同步监视器上的wait()方法，致使当前线程等待，直到其他线程调用该Condition的signal()或者signalAll()方法来唤醒该线程 signal():唤醒在此Lock对象上等待的单个线程。如果所有的线程都在该Lock对象上等待，就会随机唤醒其中一个线程。 signalAll():唤醒在此Lock对象上等待的所有线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Demo1 &#123; public static void main(String[] args) &#123; //显式定义Lock锁对象 private final Lock lock=new ReentrantLock(); //获取锁对象对应的Condition private final Condition cond=lock.newCondition(); //创建一个顾客线程 new Thread()&#123; @Override public void run() &#123; //保证等待和唤醒的线程只有一个在执行，需要使用同步技术 lock.lock(); System.out.println(\"告知老板要的包子的种类和数量\"); //调用wait方法，放弃cpu的执行，进入到WAITING状态（无线等待） try &#123; cond.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock.unlock(); System.out.println(\"正在吃包子！！！\"); &#125; &#125;.start(); //创建一个老板线程 new Thread()&#123; @Override public void run() &#123; lock.lock(); try &#123; Thread.sleep(5000);//花费5秒做包子 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"老板5秒中之后做好包子，喊顾客吃包子\"); //唤醒顾客吃包子 cond.notify(); lock.unlock(); &#125; &#125;.start(); &#125;&#125;","categories":[],"tags":[],"keywords":[]},{"title":"Cookie 报错500无效字符","slug":"Cookie出现500错误（无效字符）","date":"2019-06-08T09:15:30.185Z","updated":"2019-06-08T10:13:47.327Z","comments":true,"path":"2019/06/08/Cookie出现500错误（无效字符）/","link":"","permalink":"http://yoursite.com/2019/06/08/Cookie出现500错误（无效字符）/","excerpt":"","text":"废话不多说，直接上源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@WebServlet(\"/CookieRecordTime\")public class CookieRecordTime extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应消息体的数据格式 response.setContentType(\"text/html;charset=utf-8\"); //获取所有的Cookie Cookie[] cookies = request.getCookies(); //是否存在指定名称的Cookie的标记 boolean flag=false; //判断是否存在对应名称的Cookie if (cookies!=null &amp;&amp; cookies.length&gt;0)&#123; for (Cookie cookie : cookies) &#123; String name=cookie.getName(); if (\"lastTime\".equals(name))&#123; flag=true; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); //设置时间 cookie.setValue(currentTime); //设置Cookie的存活时间 cookie.setMaxAge(60*60*24*30); //写回最新时间 response.addCookie(cookie); //返回上次访问时间 String value=cookie.getValue(); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间是：\"+value+\"&lt;h1&gt;\"); break; &#125; &#125; &#125; if (cookies==null || cookies.length==0 || flag==false)&#123; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); Cookie cookie=new Cookie(\"lastTime\",currentTime); cookie.setMaxAge(60*60*24*30); response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;欢迎您首次访问&lt;h1&gt;\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 部署运行之后如下： 从以上报错可以得知出错原因是因为Cookie的value值里面有个空格特殊字符，32就是空格的ASCII码。 具体出错点： 1SimpleDateFormat sdf=new SimpleDateFormat(&quot;yyyy年MM月dd HH:mm:ss&quot;); 其实解决方法很简单，把dd和HH之间的空格去掉就行了。 但是这里着重介绍另外一种方法。 ​ 首先先说一个URL编码，在tomcat8之前，Cookie中不支持中文，所有的中文数据都要先转换成URL编码的形式进行传输，当然想要读取的话还需要进行解码。虽然在tomcat8之后Cookie支持中文，但是依然不支持特殊字符，因此建议使用URL编码进行存储，使用URL编码进行解析。 修改后的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@WebServlet(\"/CookieRecordTime\")public class CookieRecordTime extends HttpServlet &#123; protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; //设置响应消息体的数据格式 response.setContentType(\"text/html;charset=utf-8\"); //获取所有的Cookie Cookie[] cookies = request.getCookies(); //是否存在指定名称的Cookie的标记 boolean flag=false; //判断是否存在对应名称的Cookie if (cookies!=null &amp;&amp; cookies.length&gt;0)&#123; for (Cookie cookie : cookies) &#123; String name=cookie.getName(); if (\"lastTime\".equals(name))&#123; flag=true; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); System.out.println(\"编码前：\"+currentTime); //进行URL编码，否则特殊字符会报错 currentTime = URLEncoder.encode(currentTime, \"utf-8\"); System.out.println(\"编码前：\"+currentTime); //设置时间 cookie.setValue(currentTime); //设置Cookie的存活时间 cookie.setMaxAge(60*60*24*30); //写回最新时间 response.addCookie(cookie); //返回上次访问时间 String value=cookie.getValue(); System.out.println(\"解码前：\"+value); //进行URL解码 value=URLDecoder.decode(value,\"utf-8\"); System.out.println(\"解码后：\"+value); response.getWriter().write(\"&lt;h1&gt;欢迎回来，您上次访问时间是：\"+value+\"&lt;h1&gt;\"); break; &#125; &#125; &#125; if (cookies==null || cookies.length==0 || flag==false)&#123; //以指定格式获取最新时间 Date date=new Date(); SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy年MM月dd HH:mm:ss\"); String currentTime = sdf.format(date); //进行URL编码，否则特殊字符会报错 currentTime = URLEncoder.encode(currentTime, \"utf-8\"); Cookie cookie=new Cookie(\"lastTime\",currentTime); cookie.setMaxAge(60*60*24*30); response.addCookie(cookie); response.getWriter().write(\"&lt;h1&gt;欢迎您首次访问&lt;h1&gt;\"); &#125; &#125; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; this.doPost(request, response); &#125;&#125; 修改之后问题完美解决","categories":[],"tags":[],"keywords":[]},{"title":"多线程浅析（一）--创建线程/线程安全（同步）/生命周期","slug":"多线程浅析（一）","date":"2019-06-06T11:27:29.716Z","updated":"2019-06-10T13:03:30.901Z","comments":true,"path":"2019/06/06/多线程浅析（一）/","link":"","permalink":"http://yoursite.com/2019/06/06/多线程浅析（一）/","excerpt":"","text":"在介绍多线程之前首先要明确两个很重要的概念：线程/进程。 什么是进程和线程呢？​ 先来大概看一下看书上的定义：进程是处于运行过程中的程序，具有一定的独立功能，是系统进行资源分配和调度的一个独立功能。线程是进程的组成部分，在程序中是独立的、并发的执行流,是进程的执行单元。是否容易理解？其实可以理解为电脑上的扫雷游戏。而线程就是扫雷游戏上的那个计时器。 ​ 归纳起来可以这样说：操作系统可以同时执行多个任务（QQ聊天、看电影、写博客等），每个任务其实就是进程；进程又可以同时执行多个任务（看电影的时候不仅仅能够观看电影还能够发弹幕），对应的每个任务就是线程。 线程和进程的关系？​ 线程是进程的组成部分，一个进程可以有多个线程。一个线程必须有一个父进程。线程可以拥有自己的堆栈、自己的程序计数器以及自己的局部变量，但是不拥有系统资源，他与父进程的其他线程共享改进成所拥有的全部资源。不过也就是因为这样，在进行多线程编程的时候要防止线程冲突。 多线程编程优点 进程之间不能共享内存，但是线程之间共享内存就很容易 系统创建进程的时候需要为该进程分配系统资源，但是创建线程代价就小的多，因此使用多线程实现多任务并发行要比多进程效率高 Java语言内置了多线程功能的支持，而不是单纯的作为底层操作系统的调度方式，从而简化了java的多线程编程。 多线程的创建和启动（一）.继承Thread类创建线程* 定义Thread的子类，并重写该类的run方法，该run方法的方法体就是线程所要完成的任务表，因此run()也叫做线程执行体 123456789101112131415161718public class myThread1 extends Thread&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(\"继承Thread类创建线程\"); &#125; &#125; //定义带参构造方法 public myThread1(String name) &#123; super(name); &#125; //定义无参构造方法 public myThread1() &#123; &#125;&#125; 创建Thread子类的实例，也就是创建线程对象 调用线程对象的start()方法开启动该线程 12345678910111213141516171819public class ThreadDemo1 &#123; public static void main(String[] args) &#123; //无参构造方法创建线程（默认） myThread1 mt=new myThread1(); mt.start(); //无参构造方法创建线程（设置线程名称） myThread1 mt1=new myThread1(); mt1.setName(\"哈咯\"); mt1.start(); //带参构造方法创建线程 myThread1 mt2=new myThread1(\"宝贝\"); mt2.start(); &#125;&#125; （二）.实现Runnable接口创建线程 定义Runnable接口的实现类，并重写run方法，该run()方法的方法题同样是该线程的线程执行体 123456789public class myThread2 implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+\"--&gt;\"+i); &#125; &#125;&#125; 创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象 调用线程对象的start()方法来启动该线程 123456789101112public class ThreadDemo2 &#123; public static void main(String[] args) &#123; //创建一个Runnable接口的实现类对象 myThread2 myThread2=new myThread2(); //创建Thread类对象，构造方法中传递Runnable接口的实现类对象 Thread t=new Thread(myThread2); //调用Thread里面的start方法开启多线程 t.start(); &#125;&#125; （三）.二者创建线程的对比​ 采用实现Runnable接口的方式创建多线程的优缺点 线程只是实现了接口，还能够继承其他的类 多个线程可以共享同一个target对象，所以非常适合多个线程处理同一份资源的情况。 编程稍微复杂一些。如果需要访问当前线程，必须使用Thread.currentThread()方法。 ​ 采用继承Thread类创建线程的优缺点 编写较为简单，如果要访问当前线程，无需使用Thread.currentThread()方法，只需使用this就可以获取当前线程 因为已经继承了Thread类，就无法再次继承其他类了。 线程的生命周期​ 当线程被创建并且启动之后，并非一启动就立刻进入了执行状态，也不会一直处于执行状态（除非线程执行体够短），在线程的生命周期中，一个线程要经过 新建（New）、就绪（Ready）、运行（Running）、阻塞（Blocked）、以及死亡（Dead），尤其是线程在启动之后不会一直霸占CPU，因此线程状态也会多次在运行、就绪之间进行切换。 （一）. 新建和就绪状态​ 当程序使用了new关键字创建了一个线程之后，该线程就处于了新建状态，这个时候的线程对象就如同其他普通的java对象一样，仅仅由java虚拟机为其分配内存并初始化其成员变量的值。但是不会表现出来任何线程的动态特征，程序也不会执行线程的线程执行体。 ​ 当线程对象调用了start()方法之后，线程进入就绪状态，java虚拟机会为其创建方法调用栈和程序计数器，不过出于这个状态中的线程并没有开始运行，只是表明该线程可以运行了，拥有了运行资格。至于呵是运行，要取决于JVM的线程调度。 （二）.运行和阻塞状态​ 如果处于新建状态的线程获取了CPU，开始执行run()方法的方法体，则该线程进入运行状态。 ​ 发生以下情况的时候线程会进入阻塞状态： 线程调用sleep()方法主动放弃处理器所占用的处理器（CPU）资源 线程调用了阻塞式的IO方法，在该方法返回之前，该线程被阻塞。 线程试图获得一个同步监视器，但是该监视器正在被其他线程占用。 线程在等待某个通知（notify） 程序调用了线程的suspend()方法将该线程挂起。（该方法容易导致死锁，所以应该尽量避免） 当线程进入阻塞状态之后，其他线程就会获得执行的机会。被阻塞的线程会在适当的时候重新进入就绪状态而非运行状态。 ​ 进入阻塞状态之后的线程发生如下特定情况的时候会解除阻塞状态： 调用sleep()方法的线程已经过了指定时间 线程调用的阻塞式IO方法已经返回 线程成功取得同步监视器 其他线程发出了一个通知（notify） 处于挂起状态的线程调用了resume()方法 （三）.线程死亡​ 线程会以如下方式结束，并进入死亡状态 run()或call()方法执行完成，线程正常结束 线程抛出一个未捕获的Exception或Error 直接调用该线程的stop()方法来结束该线程—-容易导致死锁，不建议使用 ==注意：主线程结束的时候不会对其他线程造成影响。一旦子线程启动之后就会和主线程拥有相同的地位== 线程同步​ 说到线程同步就不得不先引入另外一个话题了：线程安全。 ​ 先来看一段代码，以便更好的理解线程安全这个问题 12345678910111213141516public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket=100; //设置线程任务：卖票。 @Override public void run() &#123; while (true)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125; &#125;&#125; ​ 测试代码： 1234567891011121314151617public class TicketDemo1 &#123; public static void main(String[] args) &#123; //创建Runnable接口实现类 RunnableImpl ri=new RunnableImpl(); //创建Thread类对象，构造方法中传递Runnable接口的实现类对象 Thread t0=new Thread(ri); Thread t1=new Thread(ri); Thread t2=new Thread(ri); //调用start方法开启多线程 t0.start(); t1.start(); t2.start(); &#125;&#125; 运行上面程序部分结果如下： 从运行结果可以看出，第100百张票被卖出多次，这显然不符合实际要求。这就是因为多个线程在公用同一份信息的时候由于线程调度不当导致的问题。 为了解决这类线程安全问题，java便引入了线程同步。通常用来解决线程安全问题可以通过以下三个方法来进行： （一）.同步代码块​ 语法格式： 1234synchronized(锁对象)&#123; 可能会出现线程安全问题的代码（访问了共享数据的代码）&#125; 锁对象：把同步代码块锁住，只让一个线程在同步代码块中执行 1.锁对象可以是任意的对象，但是建议将可能被并发访问的共享资源当成锁对象（本例中是ticket对象） 2.但是必须保证多个线程使用的锁对象是同一个 ==注意：== * 任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程就会释放对该同步监视器的锁定。 * synchronized关键字可以修饰**方法、代码块**，但是不能修饰**构造器**和**成员变量**等。 先来看一下同步代码块的具体使用（将上述代码改成如下）： 1234567891011121314151617181920212223public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket=100; //创建所对象（可以是任意对象） Object obj=new Object(); //设置线程任务：卖票。 @Override public void run() &#123; while (true)&#123; synchronized (obj)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125; &#125; &#125;&#125; 测试之后，之前的线程问题不会再出现。这就代表同步代码块对线程安全问题起到了控制作用。 （二）.同步方法​ 和同步代码块相对应，同步方法是使用synchronized关键字来修饰某个方法静态和非静态，则该方法成为同步方法。 ​ 下面通过一段简单的代码来展示同步方法的使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private static int ticket=100; //创建所对象（可以是任意对象） Object obj=new Object(); //设置线程任务：卖票。 //不在run方法里直接实现卖票操作而是定义一个sellTicketStatic()函数更符合面向对象 //的设计规则 @Override public void run() &#123; System.out.println(\"this:\"+this); while (true)&#123; sellTicketStatic(); &#125; &#125; /** * 静态同步方法的锁对象是谁呢？ * this是创建对象之后产生的，静态方法优先于对象。 * 静态方法的锁对象是本类的class属性--&gt;class文件对象（反射） */ public static synchronized void sellTicketStatic()&#123; //synchronized (RunnableImpl.class)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; //&#125; &#125; /** * 定义一个同步方法 * 同步方法也会把方法内部的代码锁住 * 只让一个线程执行 * 同步方法的对象是谁？ * 就是实现类对象，new RunnableImpl() * 也就是this */ public synchronized void sellTicket()&#123; //synchronized (this)&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; // &#125; &#125;&#125; ​ 从上诉代码24,25行以及41,42行中可以看出来，==静态方法的锁对象是本类的class属性–&gt;class文件对象；非静态方法的锁对象就是实现类对象：new RunnableImpl()，也就是this。== 释放同步监视器的锁定​ 任何线程在进入同步代码块或者同步方法之前必须先获得对同步监视器的锁定，既然获得了锁定，就肯定会有释放锁定的时间，那么什么时候会释放对同步监视器的锁定呢？程序无法显示释放对同步监视器的锁定，线程会在如下情况释放对同步监视器的锁定 当前线程在同步方法、同步代码块执行结束，当前线程就会释放锁定 当前线程在同步方法、同步代码块中遇到break return终止了该代码块或者方法的执行 当前线程在同步方法、同步代码块中遇到未处理的Error或者Exception,导致该代码块或方法异常结束 当前线程在执行同步方法、同步代码块时候，程序执行了同步监视器对象的wait()方法，则当前线程暂停，并释放同步监视器 在下列情况发生的时候不会释放锁定 线程执行同步代码块或者同步方法的时候，程序调用了Thread.sleep()、Thread.yield()方法来暂停当前线程的执行，当前线程不会释放同步监视器的锁定 线程执行同步代码块或者同步方法的时候，其他线程调用了该线程的suspend()方法将线程挂起，当前线程不会释放当前同步监视器的锁定。 （三）.同步锁（Lock）​ Lock锁是从java5开始出现的一种同步机制，它提供了比synchronized方法以及synchronized代码块更广泛的锁定操作。java为Lock提供了实现类：ReentrantLock（可重入锁）。 使用步骤： 1.在成员位置创建一个Reentrantlock对象 2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 ​ 接下来用一段代码展示Lock锁的具体使用。 123456789101112131415161718192021222324252627282930public class RunnableImpl implements Runnable&#123; //定义一个多个线程共享的票源 private int ticket=100; //1.在成员为之创建一个Reentrantlock对象 Lock l=new ReentrantLock(); //设置线程任务：卖票。 @Override public void run() &#123; while (true)&#123; //2.在可能会出现安全问题的代码前调用Lock接口中的方法lock获取锁 l.lock(); try&#123; if (ticket&gt;0)&#123; System.out.println(Thread.currentThread().getName()+\"--&gt;正在卖第\"+ticket+\"张票\"); ticket--; &#125; &#125;finally &#123; //3.在可能会出现安全问题的代码后调用Lock接口中的方法unlock释放锁 //为了保证锁一定会被释放，将释放锁放在finally语句中 l.unlock(); &#125; &#125; &#125;&#125; Lock本身是一个接口，无法进行实例化，只能通过其实现类来实例化。 123Lock l=new ReentrantLock();或者ReentrantLock l=new ReentrantLock(); 为了确保锁一定会被释放，应该将l.unlock();放入到finally语句中","categories":[],"tags":[],"keywords":[]},{"title":"final修饰符浅析","slug":"final修饰符","date":"2019-06-02T12:09:25.650Z","updated":"2019-06-02T12:57:08.261Z","comments":true,"path":"2019/06/02/final修饰符/","link":"","permalink":"http://yoursite.com/2019/06/02/final修饰符/","excerpt":"","text":"​ final修饰符可以用来修饰类、变量和方法。 对于一个final变量来说，无论是类变量、实例变量还是局部变量，只要满足以下三个条件就能认为final变量是一个直接量（宏）： 使用final修饰符修饰 定义改final的时候指定了初始值 该初始值可以在编译的时候就被确定下来 1.1 final成员变量成员变量随着类或者对象的初始化而初始化的。 当类初始化的时候，系统会为该类的类变量（static修饰的成员变量）分配内存，并且分配默认值。也就是说当执行静态初始化块的时候可以对类变量赋初始值。对于类变量而言必须在静态初始化块中指定初始值==或者==在声明该变量的时候指定初始值 当创建对象的时候，系统会为该对象的实例变量（没有static 修饰的成员变量）分配内存，并且分配默认值。也就是说当执行普通初始化块或者构造器的时候可以对实例变量赋初始值。对于实例变量而言必须在非静态初始化块、声明该实例变量或构造器中指定初始值，而且只能在三个地方中的一个地方指定。 ​ 对于final修饰的成员变量而言，一旦初始值确定了，那么就不能在被重新赋值了。而且成员变量的初始值必须显示的指定。 ==注意：== ​ ① 不能再静态初始化块中为实例变量指定初始值，因为静态初始化块只能访问静态成员，二实例变量是 非静态成员。 ​ ② 类变量不能在普通初始化块中指定初始值，因为类变量在类初始化的时候就已经被初始化了。 ​ 如果在构造器或者初始化块中对final修饰的成员变量进行初始化，一定不要再初始化之前直接访final成员变量，但是java允许通过方法访问final成员变量。（可以看成是设计缺陷，建议避免在初始化之前访问这一类型的变量） 1.2 final 局部变量​ 系统自身并不会对局部变量进行初始化，必须显示初始化。因此使用final修饰的局部变量的时候既可以在定义的时候进行初始化（后续代码中不能再次赋值），也可以不指定而可以在后续代码中为其赋值，但是只能进行一次赋值 1.2.1 final 修饰基本类型变量​ 不能够对基本类型变量进行重新赋值。 1.2.2 final 修饰引用类型变量​ 对于引用类型变量而言，它保存的仅仅是一个引用，final只保证这个引用类型变量所引用的地址不会改变，也就是一直引用一个对象，但是这个对象可以发生改变。 1.3 final方法​ 被final修饰的方法不能够被重写 1.4 final 类​ final修饰的类不能够被继承。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（三）","slug":"集合知识浅析（三）","date":"2019-06-01T00:30:34.238Z","updated":"2019-06-01T13:53:48.928Z","comments":true,"path":"2019/06/01/集合知识浅析（三）/","link":"","permalink":"http://yoursite.com/2019/06/01/集合知识浅析（三）/","excerpt":"","text":"Map体系首先来一张Map体系图： 1.1 Map​ Map用于保存具有映射关系的数据，因此Map集合里面保存着两组值：key 和 value，key value可以是任何引用类型的数据，同时key不允许重复，value可以重复。key和value之间存在单向一对一的关系，通过key总是能找到唯一的确定的value。 ​ 如果将Map集合中所有的key放在一起来看的话，这些key就相当于一个Set集合（所有的key无序且不可重复），在Map接口里面的确包含了一个keySet()方法,可以用来获取这个key组成的“集合”。 ​ Map和Set之间的关系相当密切。虽然Map里面存储的是键值对，Set里面存放的是单个对象，但是由于Map集合键值对的映射关系是单向一对一，因此如果将value看成key的附属的话，那么这个Map就可以当成Set来看待。事实上，在Map中还真的有一个方法：entrySet()。这个方法可以用来将Map的每一个键值对封装在一起形成一个整体（Set）。 ​ 如果将Map集合中所有的value放在一起来看，这些value就相当于一个List集合：元素和元素之间可以重复，元素可以根据索引值来查找，只不过Map中查找value用的索引值是key值。 ==强调：==Java源码就是先实现了Map的一系列集合，然后通过包装一个value都等于null的Map集合实现了Set集合类。 Map接口中定义了如下常用方法： 12345678910111213141516void clear():删除所有的键值对boolean containsKey(Object key):查询是否包含指定的键boolean containsValue(Object value):查询是否包含指定的键Object get(Object key):返回指定key所对应的的value。没有这个key就返回nullboolean isEmpty():判断集合是否为空Set entrySet():返回Map集合中所有键值对所组成的Set集合，集合元素都是Map.Entry对象Set keySet():返回Map中所有key组成的Set集合Collection values():返回Map中所有value组成的Collection集合Object put(Object key,Object value):向集合中添加一个键值对，如果集合中已经有了相同的key，那么就会覆盖掉原本的键值对并返回被覆盖掉的valuevoid putAll(Map m):将制定Map中的键值对添加到本Map中Object remove(Object key):删除指定key对应的键值对，返回对应的value；如果key不存在，就返回nullboolean remove(Object key,Object value):Java 8新增方法。成功删除返回true,否则返回falseboolean replace(K key,V oldValue,V new newValue):用新的value替换旧的valueint size():返回集合元素个数 Map中包括了一个内部类Entry，这个类封装了一个键值对。Entry包含如下三个方法：、 123Object getKey():返回该Entry里面包含的keyObject getValue():返回该Entry里面包含的valueObject setValue(V value):设置Entry里面包含的value值，并返回这个值 Map系列都重写了toString()方法。 1.2 HashMap / Hashtable​ HashMap和Hashtable都是Map接口的典型实现类，他们的关系完全类似于ArrayList和Vector的关系。 HashMap和Hashtable的典型区别： Hashtable是一个线程安全的Map实现类，而HashMap是县城不安全的实现。所以HashMap比HashTable的性能高一些。但是再多线程条件下，使用Hashtable会更安全。 Hashtable的key和value不能为null,否则抛出NullPointerException异常。但是HashMap的key和value可以为null ​ 和HashSet一样的是HashMap / Hashtable不能保证其中的键值对的顺序，而且判断key相等的标准也是通过equals()方法比较返回true,两个key的hashCode相等。 为了能够在HashMap / Hashtable中进行存储、获取对象，用作key的对象所属的类必须实现hashCode()和equals()方法。同时两个方法的判断标准应该一致：当两个key通过equals方法返回true时候，两个key的hashCode的值也应该相等。 1.3 LinkedHashMap​ 同HashSet有一个子类LinkedHashSet一样，HashMap也有一个LinkedHashMap子类。这个类可以保证键值对的顺序（添加顺序和取出顺序），在迭代访问Map集合的全部元素时有比较好的性能 1.4 Properties​ Properties时Hashtable的一个子类，相当于一个key和value都是String类型的Map集合。经常用于从外部文件进行读写操作。 123456String getProperty(String key):获取Properties中指定属性名对应的属性值String getProperty(String key,String defaultValue):与上一个方法基本相似，但是集合中没有key值的情况下会返回指定的默认值Object setProperty(String key,String value):设置属性void load(InputStream inStream):从属性文件中（以输入流的形式）加载键值对。把加载到的键值对追加到Properties里面。void store(OutPutStream out,String comments):将Properties中的键值对输出到指定的属性文件中（输出流的表示形式） ## 1.5 SortedMap / TreeMap​ SortedMap是Map的子接口，而TreeMap是SortedMap的实现类。TreeMap是一个红黑树的数据结构，每个键值对作为数的一个节点。TreeMap存储元素的时候会根据key值对节点进行排序。TreeMap可以保证所有的键值对处于排序状态，同样TreeMap也有两种排序方式： 自然排序：TreeMap的key必须实现Comparable接口，而且所有的key必须是同一个类的对象，否则会抛出ClassCastException异常 定制排序：创建TreeMap的时候，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不要求Map的key实现Comparable接口。 注意： TreeMap判断两个key是否相同的标准和TreeSet判断两个元素相等的标准（也是唯一标准）是一样的：两个key通过compareTo()方法返回0，就认为两个key相等。 如果使用自定义类作为key，那么自定义类需要重写equals()和compareTo()方法，且应该保持一致的返回结果。（和TreeSet一模一样）。 TreeMap中根据key顺序访问键值对的(部分)方法： 12345678910111213Map.Entry first/lastEntry():返回Map里面最小/大key对应的键值对，如果Map为空就返回nullObject first/lastKey():返回Map中最小/大的key值。Map为空就返回nullMap.Entry higher/lowerEntry():返回指定key后面一个为对应的键值对，如果Map为空就返回nullObject higher/lowerKey():返回指定key后面一位的key值。Map为空就返回nullSortedMap subMap(Object fromKey,Object toKey):截取，不包括右SortedMap tailMap(Object fromKey):返回该Map的子Map,key的范围是大于fromKey的所有keySortedMap headMap(Object toKey):和上面一样，key的范围是小于toKey的所有keyNevigableMap subMap(Object fromKey,boolean from,Object toKey,boolean to):截取，是否包含取决于具体参数NevigableMap tailMap(Object fromKey,boolean from):返回该Map的子Map,是否包含取决于第二个参数NevigableMap headMap(Object toKey,boolean inclusive):是否包括取决于第二个参数 1.6 IndetityHashMap​ 这个Map的实现机制和HashMap很相似，但是它在处理两个相等的key不一样。 ​ 在IdentityHashMap中，当且仅当两个key严格相等（key1==key2）的时候,IdentityHashMap才认为两个key相等。而对于普通的HashMap来说，只要key1和key2通过equals()方法返回true，并且他们的hashCode值相等即可。允许使用Null作为key和value。 1.7 WeakHashMap​ 与HashMap用法基本相似。只不过HashMap的key保留了对实际对象的强引用，这意味着只要HashMap的对象不被销毁，那么该HashMap的所有key所引用的对象就不会被垃圾回收机制回收，HashMap也不会自动删除这些key所对应的的键值对；而WeakHashMap的key只保留了对实际对象的弱引用，当垃圾回收机制回收了key所对应的的实际对象之后，WeakHashMap就会自动删除该key所对应的的键值对。 1.8 EnumMap EnumMap在内部以数组的形式保存，因此这种实现形式相当高效 根据key的自然排序（枚举值在枚举类中定义的顺序）来维护键值对的顺序 不允许使用null作为key。 创建EnumMap的时候必须指定一个枚举类吗，从而将该EnumMap集合和枚举类关联起来 各个Map实现类的性能分析：* 对于Map常用的实现类而言，HshMap和Hashtable几乎一样，但是Hashtable是一个古老的、线程安全的实现类，因此性能不如HashMap。 * TreeMap通常比HashMap / Hashtable要慢，特别是在插入和删除键值对的时候更慢。因为TreeMap底层采用红黑树来管理键值对。但是TreeMap有一个好处：键值对总是处于有序状态，不需要专门进行排序操作。想要获取TreeMap的元素，只需要调用keySet()，得到key组成的Set集合，然后使用toArray()方法来转换成数组，接下来使用Arrays的binarySearch()方法在已排序的数组中进行快速的查询既可。 * 对于一般的应用场景，应当多考虑使用HashMap,但是程序要求一个总是排序好的Map的时候就应该使用TreeMap. * LinkedHashMap比HashMap要慢一些，因为需要维护两边保持键值对的添加顺序。 * IdentityHashMap没有出色之处，只不过使用的是“==”来判断元素是否相等 * EnumMap的性能最好，但是只能使用同一个枚举类的枚举值作为key。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（二）","slug":"集合知识浅析（二）","date":"2019-05-31T09:03:27.458Z","updated":"2019-06-08T03:28:41.940Z","comments":true,"path":"2019/05/31/集合知识浅析（二）/","link":"","permalink":"http://yoursite.com/2019/05/31/集合知识浅析（二）/","excerpt":"","text":"Collection体系先来一张Collection体系图： 1.1 Collection​ Collection是单列集合的根接口，提供了所有单列集合的共性方法。在这个接口下有两个很重要的子接口：java.util.List和java.util.Set。 ​ 其中List中元素有序，可重复，有索引因此可以使用普通的for循环进行遍历，Set中的元素无序，不可重复，没有索引因此不能够使用普通for循环进行遍历，那Collection当中提供了和索引相关的方法吗？答案是否定的。 注意：由于Collection List Set是接口，因此不能进行实例化,只能使用期实现类来进行实现。 Collection常用方法 1234567891011boolean add(Object o):添加元素boolean addAll(Collection c):将集c里面的元素全部添加进指定集合void clear():清空集合boolean contains(Object o):返回集合里面是否包含指定元素boolean isEmpty():判断集合是否为空Iterator iterator():返回一个迭代器，用于遍历集合内容boolean remove():删除指定元素（删除第一个）boolean removeAll():删除指定元素（全部）boolean retain():从集合中删除集合c里面不包含的元素int size():返回集合里面元素的个数Object[] toArray():把集合转换成一个数组，所有的集合元素会变成相应的数组元素 ​ 在传统的模式下，当把一个对象放到集合里面之后，集合就会将该对象的类型当成Object类型。如果要进行集合元素的其他一些操作的话需要进行向下转型操作。但是在JDK 1.5之后，可以使用来泛型进行改进。 1.2 Set​ Set和Collection没有多大的差别。只不过在Set中不允许有重复的元素且元素无序。在Collection中定义的方法，在Set中都可以使用。 1.2.1 HashSet​ HashSet是Set的典型实现类，HashSet按照Hash算法进行集合元素的存储，因此在存取和查找方面具有很好的性能。 特点： 1234* HashSet不保证元素的排列顺序，也就是说取出来的顺序和放进去的顺序有可能不一致* HashSet不是同步的，也即是线程不安全。* 元素可以为NULL* 底层是Hash表 为什么HashSet中不允许有重复元素呢？ ​ 这主要依赖于两个方法：hashCode和equals。 在介绍具体原理之前，先介绍一些相关其他知识： ​ 哈希值：是一个十进制的整数，由系统随机给出（也就是对象的地址值，是一个逻辑地址而非实际存储的物理地址），在Object类中可以使用hashCode返回对象的哈希值。 ​ HashSet集合存储数据的结构(哈希表): ​ 哈希表： ​ 在JDK 1.8之前，哈希表底层采用 数组+链表 来实现。即使用链表处理冲突，具有相同Hash值的对象都存储在一个链表里面。但是当相同哈希值的元素很多的时候进行查找的效率就很低，因此在JDK1.8开始，哈希表采用了 数组+链表+红黑树 实现。当链表长度超过阈值（8）的时候，就会将链表转换成红黑树，从来减少了查找时间，提高效率。 下面来看一段代码： 12345678HashSet&lt;String&gt; set=new HashSet&lt;&gt;();String s1=new String(\"abc\");String s2=new String(\"abc\");set.add(s1);set.add(s2);set.add(\"通话\");set.add(\"重地\");set.add(\"abc\"); Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法来判断元素是否相同。 set.add(s1): add方法会调用s1的hashCode方法，计算字符串”abc”的哈希值得出结果为96354，在集合中查找有没有这个哈希值的元素，没有有的话就把s1存入集合中 set.add(s2): add方法会调用s2的hashCode方法，计算字符串”abc”的哈希值为96354，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较s2.equals(s1),返回true。两个元素的哈希值相同，而且equals方法返回true，可以认定两个元素相同。就不会把s2存储到集合中。 set.add(&quot;通话&quot;)： add方法会调用hashCode方法，计算字符串“重地”的哈希值为1179395，在集合中没有找到相同哈希值的元素，就会将这个元素添加到集合中 set.add(&quot;重地&quot;): add方法会调用 “通话” 的hashCode方法，计算字符串”abc”的哈希值为1179395，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较&quot;通话&quot;.equals(&quot;重地&quot;),返回false。两个元素的哈希值相同，equals方法返回false，可以认定两个元素不相同。就会把s2存储到集合中。 1.2.2 LinkedHashSet​ LinkedHashSet是HashSet的一个子类，不过他与HashSet不同的是，LinkedHashSet底层多了一个链表，这样能够保证LinkedHashSet的元素是有序的 1.2.3 TreeSet​ TreeSet是SortedSet接口的实现类,正如名字所示TreeSet可以确保集合元素处于排序状态。和HashSet相比,还额外提供了如下方法： 12345678Comparator comparator():如果TreeSet采用了定制排序，那么该方法会返回定制排序所使用的Comoparator，如果采用的是自然排序就返回nullObject first():返回集合中的第一个元素Object last():返回集合中的最后一个元素Object lower(Object e):返回集合中位于指定元素之前的元素Object higher(Object e):返回集合中位于指定元素之后的元素SortedSet subSet(Object fromElement,Object toElement):返回此Set的子集合，包左不包右SortedSet headSet(Object toElement):返回此Set子集，由小于toElement的元素组成SortedSet tailSet(Object fromElement):返回此Set子集，由大于等于toElement的元素组成 ​ TreeSet支持的的排序分为两种：自然排序（默认情况）/定制排序 自然排序：​ TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小，然后将集合元素按照升序排列，这种方式就是自然排序。 ​ 如果试图想TreeSet集合添加一个对象，在自然排序条件下该对象所属的类必须实现Comparable接口，否则程序会出现运行时期异常：ClassCastException。并且由于大部分类在实现compareTo(Object obj)方法的时候，都需要将被比较对象obj抢之类型转换成相同类型（因为只有相同类的两个实例才会比较大小），这也就要求了TreeSet集合里面的对象都属于一个类。 实现了Comparable接口的常用类： 1BigDecimal、BigInteger / Character / Boolean / String /Date、Time ​ 注意： 和HashSet判断对象是否相同不一样的是TreeSet判断两个对象是否相同的唯一标准就是通过调用该对象的compareTo(Object obj)方法和容器中的其他对象比较大小，如果返回值是 0 ，那么TreeSet就会认为他们相等，否则就认为他们不相等。 HashSet根据哈希值来找到元素在集合中的存储位置，TreeSet则是根据红黑树的结构来确定元素在集合中的位置。虽然往TreeSet集合中添加自定义对象的时候可以添加多种类型的对象（自定义类必须实现Comparable接口并且实现compareTo方法没有进行强制类型转换），但是当试图取出集合元素的时候，不同类型的元素依然会发生ClassCastExcepion异常。所以！如果希望TreeSet能够正常运行，TreeSet只能添加同一种类型的对象。 当需要把一个对象放入TreeSet集合中的时候，重写该对象对应类的equals方法时候应该保证该方法与compareTo(Object obj)有一样的结果。规则如下：如果两个对象通过equals方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较应该返回 0 。因为如果compareTo(Object obj)返回0，TreeSet就不会让元素进入集合内（因为compareTo(Object obj)的返回结果是作为TreeSet元素是否相等的唯一标准），但是equals方法返回false时候代表两个元素不相等，结果TreeSet和Set规则冲突。 #####定制排序： ​ TreeSet的自然排序是根据集合元素的大小进行升序排序。如果需要实现定制排序（比如降序排序），则需要在创建TreeSet的时候传入Comparator对象。这个接口里面包含了一个int compare(T t1,T t2)方法。根据返回值和0的关系来判断大小。 1.2.4 EnumSet​ EnumSet是一个专门为枚举设计的类，其中的元素必须是指定枚举类型的枚举值。该枚举类型在创建EnumSet的时候现实或者隐含的指定。也是有序的，不允许空值，否则会抛出NullPointerException异常。 ​ EnumSet没有暴露任何构造器来创建该类的实例，也就是说无法像其他集合一样new一个对象出来。但是它提供了如下方法来创建EnumSet对象： 1234567EnumSet allOf(Class elementType):创建一个包含指定枚举类里面所有枚举值的EnumSet集合EnumSet copyOf(Collection c):使用普通集合来创建EnumSet集合EnumSet copyOf(EnumSet e)EnumSet noneOf(Class elementType):使用指定元素类型来新建一个空的EnumSet集合EnumSet of(E first，E...rest):创建一个包含一个或多个枚举值得EnumSet集合。传入的枚举值必须属于同一个值EnumSet range(E from,E to):创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合EnumSet complementOf(EnumSet s):创建一个其元素类型与指定EnumSet里元素类型相同的集合，新的集合包含原来那个集合不包含的，此枚举类剩下的枚举值 1.2.5 各个Set实现类的性能分析HashSet和TreeSet是Set的两个典型实现。那么在应用中应该如何选择呢？ 123456* 记住一句话：只有需要一个保持排序的Set集合的时候再选择TreeSet,否则就选择HashSet。此外HashSet有一个子类：LinkedHashSet,对于普通的插入删除操作，性能要比HashSet稍微差一些，因为维护链表会造成额外的开销，但是由于有了链表的存在，使得`LinkedHashSet`在遍历方面会更快。* EnumSet是所有Set实现类中性能最好的，但是它只能保存同一个枚举类的枚举值作为集合元素。* HashSet TreeSet EnumSet 都是**线程不安全的**，如果有多个线程同时访问Set集合并且超过一个线程对Set集合进行了修改，那么必须使用`Collections`工具类的`synchronizedSortedSet`方法来包装Set集合,代码如下： SortedSet s=Collections.synchronizedSortedSet(new TreeSet(...)); 1.3 List（线性表接口）​ List作为Collection接口的子接口，元素有序，可重复，能够使用collection里面所有的方法。而且因为List是有序的，因此List里面还有针对于索引进行操作的方法。 12345678void add(int index,Object element):将元素插入到指定的索引位置boolean addAll(int index,Collection c):将集合c中的所有元素插入到List集合的index索引位置Object get(int index):返回集合index索引位置处的元素int indexOf(Object o):返回对象在List集合中第一次出现的位置int LastIndexOf(Object o):返回对象在List集合中最后一次出现的位置Object remove(int index):删除并返回指定位置的元素Object set(int index,Object element):将index索引处的元素设置成element，同时返回被替换的对象List subList(int fromIndex,int toIndex):返回指定范围的集合，包左 不包右 ​ 所有的List实现类都可以使用以上方法。 1.3.1 ArrayList / Vector​ ArrayList和vector是List的典型实现，完全支持List接口的全部功能。 ​ ArrayList和Vector都是基于数组实现的List类，他们封装了一个动态的、允许被再次分配的Object数组。可以使用initialCapacity来设置该数组的长度，当添加的元素超过数组的长度之后，这个initialCapacity会自动增加。不过在实际开发中，可以使用ensureCapacity(int minCapacity)方法一次性的增加initialCapacity.如果在创建对象的时候不指定初始化长度，那默认长度就是 10。 ​ 重新分配Object数组的两个方法： 12void ensureCapacity(int minCapacity)：将ArrayList或Vector数组增加至大于或等于minCapacity值void trimToSize():调整ArrayList或Vector数组长度为当前元素个数 ​ ArrayList和Vector的一个显著区别就是：ArrayList是线程不安全的，当多个线程访问同一个ArrayList集合并且有超过一个线程修改了ArrayList集合，那么程序必须手动保证该集合的同步性。Vector是线程安全的，无需保证集合的同步性，但也就是因为这样使得Vector的性能要比ArrayList性能要低。 ​ 总结：推荐选择ArrayList集合使用，线程安全的问题使用Collections工具类来保证。 1.3.2 Stack​ Stack是Vector的一个子类，名为“栈”，特点是“先进后出”、线程安全但是性能较差。 ​ Stack里面有如下几个方法： 123Object peek():返回栈的第一个元素，但是不出栈Object pop():返回栈的第一个元素，出栈void push():向栈中压入元素 ​ 由于Stack是Vector的子类，同样建议少用Stack,如果需要使用“栈”这种数据结构的话，可以考虑ArrayDequeue(之后介绍) 1.3.3 固定长度的ArrayList​ 在介绍数组的时候提到过一个操作数组的工具类：Arrays ，这个类中提供了asList(Object...a)方法，这个方法可以将数组或者指定个数的对象转换成一个List集合，这个集合就不再是ArrayList或者Vector实现类的实例了，而是Arrays的内部类ArrayList的实例。 ​ Arrays.ArrayList是一个固定长度的List集合，程序只能对其进行遍历访问，而不能进行任何改变集合的操作。 1.3.4 LinkedList​ LinedList是List的一个实现类，说明他是一个List集合，可以根据索引来随机访问元素值。同时也实现了Deque接口,因此也可以被当做双端队列来使用，同时还能被当成“栈”来使用。 来通过一些代码示范LinkedList作为 List集合、双端队列、栈的用法 123456789101112131415161718192021222324252627LinkedList books=new LinkedList();//将元素加入“队列”尾部 books.offer(\"123\");//将元素加入“栈”的顶部books.push(\"456\");//将元素加入“队列”的头部，相当于“栈”的顶部books.offerFirst(\"789\");//输出集合System.out.println(books);System.out.println(\"=====================\");//遍历“集合”元素for (int i = 0; i &lt; books.size(); i++) &#123; System.out.println(books.get(i));&#125;System.out.println(\"=====================\");System.out.println(books.peekFirst());//访问栈顶元素System.out.println(books.peekLast());//访问栈底元素System.out.println(books.pop());//弹出栈顶元素System.out.println(books);System.out.println(\"=====================\");System.out.println(books.pollLast());//删除队列最后一个元素 输出结果如下： 123456789101112[789, 456, 123]=====================789456123=====================789123789[456, 123]=====================123 1.3.5 各种线性表性能分析​ 一般来说，由于数组以一块连续内存区域来保存所有的数组元素，因此数组在随机访问时候性能最好，所以所有内部以数组作为底层实现的集合在随机访问的时候性能都很好；而内部用链表作为底层实现的集合在进行插入、删除操作的时候性能比较好。总体来说ArrayList的性能要比LinkedList的性能要好,因此大多数情况下建议使用ArrayList ​ 使用List集合的建议： 如果需要遍历集合元素，对于ArrayList / Vector,应该使用随机访问方法get()来遍历集合元素，这样性能更好；对于LinkedList应该使用迭代器（Iteator）来遍历集合。 如果需要经常执行插入、删除操作对集合进行改变，可以考虑使用LinkedList集合，因为使用ArrayList / Vector的话可能需要经常重新分配底层的数组大小，性能会受到影响。 如果有多个线程访问同一个List集合，应该考虑利用Collections将集合包装成线程安全的集合。 1.4 Queue(队列)Queue用来模拟队列这种数据结构。 在Queue接口中定义了如下方法： 123456void add(Object o):将元素添加到队列尾部void offer(Object o):将元素加入队列的尾部，在队列容量有限的时候，这种方法更好。Object element():获取队列头部元素，但是不删除Object remove():获取队列头部元素并删除Object peek():获取队列头部元素，不删除，如果队列为空，返回 nullObject poll():获取队列头部元素，删除。队列为空的话返回null 1.4.1 Deque(上图名称错误)​ Deque是Queue接口的子接口，代表一个双端队列，Deque接口里面定义了一些操作双端队列的方法。多数方法只需要在Queue接口提供的方法后加上First / Last即可。这里只介绍一些额外的方法： 12Iterator descendingIterator():返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。（反向迭代器）和常用迭代器迭代的结果是相反的。Object removeFirst/LastOccurrence(Object o):删除双端队列第一次/最后一次出现的元素 ​ Queue方法和Deque方法以及Stack比较 Queue的方法 Deque的方法 Stack add(e) / offer(e) addLast(e) / offerLast(e) push(e) remove() / poll() removeFirst() / pollFirst() pop element() / peek() getFirst() / peekFirst() peek 1.4.2 ArrayQueue​ ArrayQueue是Deque的一个典型实现类。这是一个基于数组的双端队列。创建Deque的时候同样可以指定一个numElements参数,用于指定底层的Object[] 数组的长度，不指定的话就是默认长度：16。和ArrayList两个集合类的实现机制基本相似，当集合元素超过数组长度的时候，系统会自动在底层重新分配一个数组。 ​ 前面说到了当程序中需要使用栈这种数据结构的时候应该尽量避免使用Stack,因为性能较差。在这里推荐使用ArrayQueue。 ​ ArrayQueue既可以当做队列使用，也可以当做栈使用。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（一）","slug":"集合知识浅析（一）","date":"2019-05-30T09:17:17.601Z","updated":"2019-06-09T01:40:38.849Z","comments":true,"path":"2019/05/30/集合知识浅析（一）/","link":"","permalink":"http://yoursite.com/2019/05/30/集合知识浅析（一）/","excerpt":"","text":"集合知识浅析（一）1.1集合概述 Java是面向对象的语言，面向对象语言对事物的描述是通过对象体现的，为了方便对多个对象 进行操作，就必须把这个对象进行存储，但是想要存储多个对象，就不能是一个基本数据类型 而应该是一个容器类型。 为什么不选择数组或者字符缓冲区来存储多个对象呢？ ​ 数组和StringBuffer就是容器，但是StringBuffer的结果是一个字符串，不一定能够满足要求。 因此只能选择数组作为容器，即对象数组，但是对象数组无法适应变化的需求，因为数组长度固定。因此Java提供了相应的集合类用来使用 数组和集合的区别: 1）数组长度固定，集合长度可变； 2）数组用来存储同一类型数据，集合可以存储不同类型 3）数组可以用来存储基本数据类型，也可以用来存储引用类型集合只能存 储引用类型 集合可以存储多个元素的，但是，存储多个元素也是有不同需求的，比如说，多个元素中不能有相同 元素，针对不同的需求，Java提供了不同的集合类，多个集合类的数据结构不同，但是绝对有共性。通过不断提取共性，就可以得到所有集合类的一个总集合：Collection 数据结构:数据的存储方式 1.2继承关系Java的集合类主要由Collection和Map两个接口派生出来。也即： Map的继承关系： Collection的继承关系：","categories":[],"tags":[],"keywords":[]},{"title":"泛型浅析","slug":"泛型浅析","date":"2019-05-30T02:37:42.560Z","updated":"2019-06-01T07:11:58.792Z","comments":true,"path":"2019/05/30/泛型浅析/","link":"","permalink":"http://yoursite.com/2019/05/30/泛型浅析/","excerpt":"","text":"泛型首先来看一下什么叫做泛型​ 泛型是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊类型。也叫做参数化类型，把类型当作参数一样传递。 ​ 其实说白了，可以将泛型看成对集合里面元素的一种限制手段 ​ 简而言之就是使用集合那种结构的时候会出现黄色警告线，但是往往我们会忽略这样的警告，进而导致类型不匹配等不可预知的错误。但是采用泛型的话会在创建对象或者调用方法的时候如果出现参数类型不匹配的结果会直接报错，而不是仅仅给出警告。 格式： 12&lt;数据类型&gt; 此处的数据类型只能是引用类型。 使用位置： 1看API文档，如果类，接口，抽象类后面跟有&lt;E&gt;就说明要使用泛型。一般来说就是在集合中使用(如果集合不使用泛型的话，默认就是Object类型，可以存储任意类型的数据。 泛型应用： 泛型类： 把泛型定义在类上 格式：public class 类名&lt;泛型类型1....&gt; 注意：泛型类型必须是引用类型 举例： public class Test&lt;E&gt;{ private E name; public void setName(E name){ this.name=name; } } 泛型方法： 把泛型定义在方法上 格式：public &lt;泛型类型&gt; 返回类型 方法名(泛型类型) 举例： public &lt;E&gt; void method(E e){ ... } 泛型接口： 把泛型定义在接口上 格式：public interface 接口名&lt;泛型类型1....&gt; 举例： public interface myInterface&lt;E&gt;{} 注意：泛型是没有继承概念的 泛型通配符​ 当使用泛型类或者接口的时候，在传递的数据中如果泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符之后，只能使用Object类中的共性方法，集合中元素自身的方法无法使用。不能创建对象使用，只能作为方法的参数使用 高级使用 —-受限泛型​ 设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以设置一个上限或者下限。 ###### 泛型的上限： ​ 格式：类型名称&lt;? extends 类&gt; 对象名称 ​ 意义：之能接受该类型以及其子类 ​ 举例：public static void getElement(Collection&lt;? extends XXX&gt; coll){} 反省的下限​ 格式：类型名称&lt;? super 类&gt; 对象名称 ​ 意义：之能接受该类型以及其父类 ​ 举例：public static void getElement(Collection&lt;? super XXX&gt; coll){}","categories":[],"tags":[],"keywords":[]},{"title":"String , String Builder , String Buffer的区别浅析","slug":"String , String Builder , String Buffer的区别","date":"2019-05-29T13:14:53.886Z","updated":"2019-06-03T03:11:10.057Z","comments":true,"path":"2019/05/29/String , String Builder , String Buffer的区别/","link":"","permalink":"http://yoursite.com/2019/05/29/String , String Builder , String Buffer的区别/","excerpt":"","text":"String , String Builder , String Buffer的区别首先来看这三个类分别代表什么什么意思​ String类代表字符串 ，但是它是代表一个常量，底层是一个被final修饰的数组，它的值在创建之后不能够被更改。 ​ StringBuilder（字符串缓冲区）与StringBuffer（字符串缓冲区）虽然也是代表字符串并且底层也是数组，但是这个数组没有被final修饰，他们都是可变量，他们在创建对象实例并且赋值之后可以重新更改值得内容。 ​ 这三者的区别主要存在与两点：运行速度和线程安全 运行速度:​ 三者的运行速度大小如下：StringBuilder &gt; StringBuffer &gt; String ​ 原因： ​ 先来看一段代码: 123456String s=&quot;Hello&quot;;System.out.println(s);//HelloSystem.out.println(s.getBytes());//[B@3f99bd52s=s+&quot;World&quot;；System.out.println(s);//HelloWorldSystem.out.println(s.getBytes());//[B@119d7047 ​ 上述代码输出的结果是Hello [B@3f99bd52 和HelloWorld [B@119d7047,这段代码在虚拟机上的执行过程实际是这样的：首先，在创建了一个对象s之后，将Hello赋值给了s，然后又创建了一个同名对象s，并且将之前的s对象的值和World进行拼接之后赋值给了这个新的s。那么第一次创建的对象s去哪了呢？答案是被虚拟机的垃圾回收机制回收掉了（连同对象s 的值）。因此，在对String类型的对象进行操作的时候实际上就是一个不断创建同名新对象的删除旧对象的一个过程，这期间需要不断的消耗虚拟机的资源，因此执行速度很慢。 ​ 但是StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 线程安全:​ StringBuilder是线程不安全的，StringBuffer是线程安全的 总结： String：适用于少量的字符串操作的情况 String Builder：适用于单线程下在字符缓冲区进行大量操作的情况 String Buffer：适用多线程下在字符缓冲区进行大量操作的情况 StringBuilder/StringBuilder - - &gt; String ​ 可以使用StringBuilder的构造方法：StringBuilder(String str) String - - &gt;StringBuilder/StringBuilder ​ 可以使用StringBuilder的toString方法 String常用构造方法： 123456public String()：空构造public String(byte[] bytes)：把字节数组转换成字符串public String(byte[] bytes,int offset,int length)：把字节数组一部分转换成字符串public String(char[] value)：把字节数组转换成字符串public String(byte[] bytes,int offset,int count)：把字符数组一部分转换成字符串public String(String original)：把字符串常量值转成字符串,换句话说新创建的字符串是参数字符串的副本。 常用函数： 123456789101112131415161718192021222324252627282930313233343536String类的获取功能 int length();获取长度 char charAt(int index);返回指定索引位置的字符 int indexOf(int ch);返回指定字符在此字符串第一次出现的索引 int indexOf(String str);返回指定字符串（首字母）在此字符串第一次出现的索引 int indexOf(int ch,int fromIndex);返回指定字符在此字符串从指定位置之后第一次出现的索引 String substring(int start);截取字符串，默认到末尾。返回被截取的子串。 String substring(int start,int end); String类的转换功能 byte[] getBytes();把字符串转换成字节数组 char[] toCharArray();把字符串转换成字符数组 static String valueOf(char[] chs);把字符数组转换成字串，其他类型数组用不了此方法 static String valueOf(int i);把某种类型数据转换成字符串(四类八种除了byte/short,外加) String类的valueOf方法可以把任意类型的数据转换成字符串 toCharArray():可以将字符串转化成数组 String toLoweCase(); String toUpperCase(); String concat(String str):进行字符串的拼接 toCharArray(): 将此字符串转换为新的字符数组。 String类的其他功能 替换功能 String replace(char old,char new); String replace(String old,String new); String replaceFirst(String regex, String replacement)用给定的序列替换调用者的第一个子字符串 去除字符串两端空格 String trim(); 按照字典顺序比较字符串 int compareTo(String str); int compareToIgnoreCse(String str); 判断功能： boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开头。 boolean startsWith(String prefix, int toffset) 测试在指定索引处开始的此字符串的子字符串 是否以指定的前缀开头。 拆封功能 String[] split(String regex)：根据给定的表达式拆分此字符串 注意：1.String s=new String(&quot;hello&quot;);String s=&quot;hello&quot;区别： ​ 前者创建两个对象（常量池中没有这个hello对象的时候）或一个对象（常量池中有这个hello对象的时候），后者创建一个对象（常量池中没有这个hello对象的时候）或不创建对象（常量池中有这个hello对象的时候） 2.字符串如果是变量相加，先开空间，在拼接。 12String s1=\"Hello\",s2=\"World\";s1+s2 3.字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1\"Hello\"+\"World\" String Builder和String Buffer常用构造方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 1234StringBuilder() 构造一个没有字符的字符串构建器，初始容量为16个字符。 StringBuilder(int capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。 StringBuilder(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。 StringBuilder(String str) 构造一个初始化为指定字符串内容的字符串构建器。 常用方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 123456789101112131415StringBuilder append(参数) 将指定参数的字符串表示附加到序列中。除了byte/short StringBuilder append(char[] str) 将 char数组参数的字符串表示追加到此序列。 StringBuilder append(char[] str, int offset, int len) 将 char数组参数的子阵列的字符串表示追加到此序列。 StringBuilder append(String str) 将指定的字符串附加到此字符序列。 StringBuilder append(StringBuffer sb) 追加指定的 StringBuffer到这个序列。 int capacity() 返回当前容量。 char charAt(int index) 返回指定索引位置的值void setCharAt(int index, char ch) 设置指定位置的值为ch StringBuilder reverse() 导致该字符序列被序列的相反代替。StringBuilder replace(int start, int end, String str) 用指定的 String的字符替换此序列的子字符串中的字符 int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 int indexOf(String str, int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串的最后一次出现的字符串中的索引，从指定索引开始向后搜索。 String toString() 返回表示此顺序中的数据的字符串。","categories":[],"tags":[],"keywords":[]},{"title":"接口的知识浅析","slug":"接口的知识浅析","date":"2019-05-26T15:58:29.816Z","updated":"2019-06-09T11:47:07.242Z","comments":true,"path":"2019/05/26/接口的知识浅析/","link":"","permalink":"http://yoursite.com/2019/05/26/接口的知识浅析/","excerpt":"","text":"接口什么是接口？​ 接口是多个类的一种公共规范，它是一种引用数据类型。接口中最重要的内容是接口中的抽象方法。 接口如何定义？格式：​ 1public interface 接口名称&#123;...&#125; 如何使用接口呢？1.接口不能直接使用，必须有一个“实现类”来实现接口格式： 1public class 实现类名称 implements 接口名称1,接口名称2...&#123;...&#125; 2.接口的实现类必须重写接口中的所有抽象方法3.创建实现类的对象，进行使用如果是Java 7,那么接口中可以包含的内容有：常量/抽象方法 如果是Java 8,还可以额外包含：默认方法/静态方法 如果是Java 9,还可以额外包含：私有方法 接口中的抽象方法（最重要的）格式： 1public abstract 返回值类型 方法名称(参数列表) 注意： ​ public abstract这两个关键字修饰符是固定格式，但是可以选择性的省略 接口中的default（默认）方法格式： 1public default 返回值类型 方法名称(参数列表)&#123;...&#125; 这个默认方法有什么用？​ 作用：默认方法会被实现类自动继承，因此可以用于接口升级。 什么叫做接口升级？​ 比如有一个接口A，并且B,C实现该接口，但是如果接口A中进行了抽象方法的修改，那么相应的就要去修改B,C 但是现实开发中这种并无法理想实现（比如实现了A接口的某个方法已经投入了大规模使用），因此这个时候进行接口的升级操作就需要用到这个默认的方法。 ​ 高级吗？一点都不高级。就是只需要把需要接口中新增的方法声明称默认方法就可以了。😂 接口中的静态方法（Java 8开始）格式： 1public static 返回值类型 方法名称(参数列表)&#123;...&#125; 接口中静态方法的使用​ 通过接口名称直接调用： 1接口名称.静态方法名(参数) ​ 注意： ​ 不能通过接口实现类的对象去调用接口中的静态方法 ​ 例如： 1234567891011121314public interface A&#123; public static void test()&#123; System.out.println(&quot;你好&quot;); &#125;&#125;public class B extends A&#123; public static void main(String[] args)&#123; A.test();//正确 new B().test();//错误 &#125;&#125; 接口中的私有方法（Java 9开始）1.普通私有方法​ 作用：解决多个默认方法之间重复代码问题 ​ 格式： 1private 返回值类型 方法名称(参数列表)&#123;...&#125; 2.静态私有方法​ 作用：解决多个静态方法之间重复代码问题 ​ 格式： 1private static 返回值类型 方法名称(参数列表)&#123;...&#125; 私有方法有啥用啊？来看一段代码(以普通私有方法为例)： 12345public interface A&#123; public default void methodDefault1&#123;...&#125; public default void methodDefault2&#123;...&#125;&#125; 假设methodDefault1方法和methodDefault2方法中有大量重复的代码的话,可以将这部分重复代码抽离出来形成一个新的方法。但是！抽离出来的这部分方法应当只能由methodDefault1和methodDefault2来使用，而不能由实现类来使用 将公共代码抽离出来，这样一来，便无法在实现类中访问到methodCommon(),如下： 12345678910111213public interface A&#123; public default void methodDefault1&#123; ... methodCommon(); &#125; public default void methodDefault2&#123; ... methodCommon(); &#125; private void methodCommon()&#123; 公共方法 &#125;&#125; 接口中的常量​ 接口中也可以定义”成员变量”，但是必修使用 public static final 三个关键字修饰。从效果上看，相当于接口的常量。这三个关键之可以省略，但是即使省略之后，也默认还是这三个修饰。而且必须赋值。 格式： 1public static final 数据类型 常量名称 = 数据值 如何访问呢？ ​ 这样理解：修饰符里面由static关键字，那么自然只能通过接口名进行访问：接口名.常量名 接口使用注意事项​ 1.接口内没有静态代码块或者构造方法（有了构造方法就可以直接new了） ​ 2.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要重写一次就行，而且必须重写。 ​ 3.如果实现类没有完全重写接口的抽象方法，那么实现类同样是一个抽象类 ​ 4.接口与接口之间是多继承的（类和类之间单继承，类和接口之间多实现） ​ 5.多个父接口当中的抽象方法重复没事，但是默认方法重复的话，那么子接口必须进行默认方法的重写并且要带有default关键字 ​","categories":[],"tags":[],"keywords":[]}]}