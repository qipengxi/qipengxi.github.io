{"meta":{"title":"向阳成长","subtitle":"个人博客","description":"几乎所有的事情都具有多面性","author":"小青年","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"集合知识浅析（三）","slug":"集合知识浅析（三）","date":"2019-06-01T00:30:34.238Z","updated":"2019-06-01T13:53:48.928Z","comments":true,"path":"2019/06/01/集合知识浅析（三）/","link":"","permalink":"http://yoursite.com/2019/06/01/集合知识浅析（三）/","excerpt":"","text":"Map体系首先来一张Map体系图： 1.1 Map​ Map用于保存具有映射关系的数据，因此Map集合里面保存着两组值：key 和 value，key value可以是任何引用类型的数据，同时key不允许重复，value可以重复。key和value之间存在单向一对一的关系，通过key总是能找到唯一的确定的value。 ​ 如果将Map集合中所有的key放在一起来看的话，这些key就相当于一个Set集合（所有的key无序且不可重复），在Map接口里面的确包含了一个keySet()方法,可以用来获取这个key组成的“集合”。 ​ Map和Set之间的关系相当密切。虽然Map里面存储的是键值对，Set里面存放的是单个对象，但是由于Map集合键值对的映射关系是单向一对一，因此如果将value看成key的附属的话，那么这个Map就可以当成Set来看待。事实上，在Map中还真的有一个方法：entrySet()。这个方法可以用来将Map的每一个键值对封装在一起形成一个整体（Set）。 ​ 如果将Map集合中所有的value放在一起来看，这些value就相当于一个List集合：元素和元素之间可以重复，元素可以根据索引值来查找，只不过Map中查找value用的索引值是key值。 ==强调：==Java源码就是先实现了Map的一系列集合，然后通过包装一个value都等于null的Map集合实现了Set集合类。 Map接口中定义了如下常用方法： 12345678910111213141516void clear():删除所有的键值对boolean containsKey(Object key):查询是否包含指定的键boolean containsValue(Object value):查询是否包含指定的键Object get(Object key):返回指定key所对应的的value。没有这个key就返回nullboolean isEmpty():判断集合是否为空Set entrySet():返回Map集合中所有键值对所组成的Set集合，集合元素都是Map.Entry对象Set keySet():返回Map中所有key组成的Set集合Collection values():返回Map中所有value组成的Collection集合Object put(Object key,Object value):向集合中添加一个键值对，如果集合中已经有了相同的key，那么就会覆盖掉原本的键值对并返回被覆盖掉的valuevoid putAll(Map m):将制定Map中的键值对添加到本Map中Object remove(Object key):删除指定key对应的键值对，返回对应的value；如果key不存在，就返回nullboolean remove(Object key,Object value):Java 8新增方法。成功删除返回true,否则返回falseboolean replace(K key,V oldValue,V new newValue):用新的value替换旧的valueint size():返回集合元素个数 Map中包括了一个内部类Entry，这个类封装了一个键值对。Entry包含如下三个方法：、 123Object getKey():返回该Entry里面包含的keyObject getValue():返回该Entry里面包含的valueObject setValue(V value):设置Entry里面包含的value值，并返回这个值 Map系列都重写了toString()方法。 1.2 HashMap / Hashtable​ HashMap和Hashtable都是Map接口的典型实现类，他们的关系完全类似于ArrayList和Vector的关系。 HashMap和Hashtable的典型区别： Hashtable是一个线程安全的Map实现类，而HashMap是县城不安全的实现。所以HashMap比HashTable的性能高一些。但是再多线程条件下，使用Hashtable会更安全。 Hashtable的key和value不能为null,否则抛出NullPointerException异常。但是HashMap的key和value可以为null ​ 和HashSet一样的是HashMap / Hashtable不能保证其中的键值对的顺序，而且判断key相等的标准也是通过equals()方法比较返回true,两个key的hashCode相等。 为了能够在HashMap / Hashtable中进行存储、获取对象，用作key的对象所属的类必须实现hashCode()和equals()方法。同时两个方法的判断标准应该一致：当两个key通过equals方法返回true时候，两个key的hashCode的值也应该相等。 1.3 LinkedHashMap​ 同HashSet有一个子类LinkedHashSet一样，HashMap也有一个LinkedHashMap子类。这个类可以保证键值对的顺序（添加顺序和取出顺序），在迭代访问Map集合的全部元素时有比较好的性能 1.4 Properties​ Properties时Hashtable的一个子类，相当于一个key和value都是String类型的Map集合。经常用于从外部文件进行读写操作。 123456String getProperty(String key):获取Properties中指定属性名对应的属性值String getProperty(String key,String defaultValue):与上一个方法基本相似，但是集合中没有key值的情况下会返回指定的默认值Object setProperty(String key,String value):设置属性void load(InputStream inStream):从属性文件中（以输入流的形式）加载键值对。把加载到的键值对追加到Properties里面。void store(OutPutStream out,String comments):将Properties中的键值对输出到指定的属性文件中（输出流的表示形式） ## 1.5 SortedMap / TreeMap​ SortedMap是Map的子接口，而TreeMap是SortedMap的实现类。TreeMap是一个红黑树的数据结构，每个键值对作为数的一个节点。TreeMap存储元素的时候会根据key值对节点进行排序。TreeMap可以保证所有的键值对处于排序状态，同样TreeMap也有两种排序方式： 自然排序：TreeMap的key必须实现Comparable接口，而且所有的key必须是同一个类的对象，否则会抛出ClassCastException异常 定制排序：创建TreeMap的时候，传入一个Comparator对象，该对象负责对TreeMap中的所有key进行排序。此时不要求Map的key实现Comparable接口。 注意： TreeMap判断两个key是否相同的标准和TreeSet判断两个元素相等的标准（也是唯一标准）是一样的：两个key通过compareTo()方法返回0，就认为两个key相等。 如果使用自定义类作为key，那么自定义类需要重写equals()和compareTo()方法，且应该保持一致的返回结果。（和TreeSet一模一样）。 TreeMap中根据key顺序访问键值对的(部分)方法： 12345678910111213Map.Entry first/lastEntry():返回Map里面最小/大key对应的键值对，如果Map为空就返回nullObject first/lastKey():返回Map中最小/大的key值。Map为空就返回nullMap.Entry higher/lowerEntry():返回指定key后面一个为对应的键值对，如果Map为空就返回nullObject higher/lowerKey():返回指定key后面一位的key值。Map为空就返回nullSortedMap subMap(Object fromKey,Object toKey):截取，不包括右SortedMap tailMap(Object fromKey):返回该Map的子Map,key的范围是大于fromKey的所有keySortedMap headMap(Object toKey):和上面一样，key的范围是小于toKey的所有keyNevigableMap subMap(Object fromKey,boolean from,Object toKey,boolean to):截取，是否包含取决于具体参数NevigableMap tailMap(Object fromKey,boolean from):返回该Map的子Map,是否包含取决于第二个参数NevigableMap headMap(Object toKey,boolean inclusive):是否包括取决于第二个参数 1.6 IndetityHashMap​ 这个Map的实现机制和HashMap很相似，但是它在处理两个相等的key不一样。 ​ 在IdentityHashMap中，当且仅当两个key严格相等（key1==key2）的时候,IdentityHashMap才认为两个key相等。而对于普通的HashMap来说，只要key1和key2通过equals()方法返回true，并且他们的hashCode值相等即可。允许使用Null作为key和value。 1.7 WeakHashMap​ 与HashMap用法基本相似。只不过HashMap的key保留了对实际对象的强引用，这意味着只要HashMap的对象不被销毁，那么该HashMap的所有key所引用的对象就不会被垃圾回收机制回收，HashMap也不会自动删除这些key所对应的的键值对；而WeakHashMap的key只保留了对实际对象的弱引用，当垃圾回收机制回收了key所对应的的实际对象之后，WeakHashMap就会自动删除该key所对应的的键值对。 1.8 EnumMap EnumMap在内部以数组的形式保存，因此这种实现形式相当高效 根据key的自然排序（枚举值在枚举类中定义的顺序）来维护键值对的顺序 不允许使用null作为key。 创建EnumMap的时候必须指定一个枚举类吗，从而将该EnumMap集合和枚举类关联起来 各个Map实现类的性能分析：* 对于Map常用的实现类而言，HshMap和Hashtable几乎一样，但是Hashtable是一个古老的、线程安全的实现类，因此性能不如HashMap。 * TreeMap通常比HashMap / Hashtable要慢，特别是在插入和删除键值对的时候更慢。因为TreeMap底层采用红黑树来管理键值对。但是TreeMap有一个好处：键值对总是处于有序状态，不需要专门进行排序操作。想要获取TreeMap的元素，只需要调用keySet()，得到key组成的Set集合，然后使用toArray()方法来转换成数组，接下来使用Arrays的binarySearch()方法在已排序的数组中进行快速的查询既可。 * 对于一般的应用场景，应当多考虑使用HashMap,但是程序要求一个总是排序好的Map的时候就应该使用TreeMap. * LinkedHashMap比HashMap要慢一些，因为需要维护两边保持键值对的添加顺序。 * IdentityHashMap没有出色之处，只不过使用的是“==”来判断元素是否相等 * EnumMap的性能最好，但是只能使用同一个枚举类的枚举值作为key。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（二）","slug":"集合知识浅析（二）","date":"2019-05-31T09:03:27.458Z","updated":"2019-06-01T13:52:43.961Z","comments":true,"path":"2019/05/31/集合知识浅析（二）/","link":"","permalink":"http://yoursite.com/2019/05/31/集合知识浅析（二）/","excerpt":"","text":"Collection体系先来一张Collection体系图： 1.1 Collection​ Collection是单列集合的根接口，提供了所有单列集合的共性方法。在这个接口下有两个很重要的子接口：java.util.List和java.util.Set。 ​ 其中List中元素有序，可重复，有索引因此可以使用普通的for循环进行遍历，Set中的元素无序，不可重复，没有索引因此不能够使用普通for循环进行遍历，那Collection当中提供了和索引相关的方法吗？答案是否定的。 注意：由于Collection List Set是接口，因此不能进行实例化,只能使用期实现类来进行实现。 Collection常用方法 1234567891011boolean add(Object o):添加元素boolean addAll(Collection c):将集c里面的元素全部添加进指定集合void clear():清空集合boolean contains(Object o):返回集合里面是否包含指定元素boolean isEmpty():判断集合是否为空Iterator iterator():返回一个迭代器，用于遍历集合内容boolean remove():删除指定元素（删除第一个）boolean removeAll():删除指定元素（全部）boolean retain():从集合中删除集合c里面不包含的元素int size():返回集合里面元素的个数Object[] toArray():把集合转换成一个数组，所有的集合元素会变成相应的数组元素 ​ 在传统的模式下，当把一个对象放到集合里面之后，集合就会将该对象的类型当成Object类型。如果要进行集合元素的其他一些操作的话需要进行向下转型操作。但是在JDK 1.5之后，可以使用来泛型进行改进。 1.2 Set​ Set和Collection没有多大的差别。只不过在Set中不允许有重复的元素且元素无序。在Collection中定义的方法，在Set中都可以使用。 1.2.1 HashSet​ HashSet是Set的典型实现类，HashSet按照Hash算法进行集合元素的存储，因此在存取和查找方面具有很好的性能。 特点： 1234* HashSet不保证元素的排列顺序，也就是说取出来的顺序和放进去的顺序有可能不一致* HashSet不是同步的，也即是线程不安全。* 元素可以为NULL* 底层是Hash表 为什么HashSet中不允许有重复元素呢？ ​ 这主要依赖于两个方法：hashCode和equals。 在介绍具体原理之前，先介绍一些相关其他知识： ​ 哈希值：是一个十进制的整数，由系统随机给出（也就是对象的地址值，是一个逻辑地址而非实际存储的物理地址），在Object类中可以使用hashCode返回对象的哈希值。 ​ HashSet集合存储数据的结构(哈希表): ​ 哈希表： ​ 在JDK 1.8之前，哈希表底层采用 数组+链表 来实现。即使用链表处理冲突，具有相同Hash值的对象都存储在一个链表里面。但是当相同哈希值的元素很多的时候进行查找的效率就很低，因此在JDK1.8开始，哈希表采用了 数组+链表+红黑树 实现。当链表长度超过阈值（8）的时候，就会将链表转换成红黑树，从来减少了查找时间，提高效率。 下面来看一段代码： 12345678HashSet&lt;String&gt; set=new HashSet&lt;&gt;();String s1=new String(\"abc\");String s2=new String(\"abc\");set.add(s1);set.add(s2);set.add(\"通话\");set.add(\"重地\");set.add(\"abc\"); Set集合在调用add方法的时候，add方法会调用元素的hashCode方法和equals方法来判断元素是否相同。 set.add(s1): add方法会调用s1的hashCode方法，计算字符串”abc”的哈希值得出结果为96354，在集合中查找有没有这个哈希值的元素，没有有的话就把s1存入集合中 set.add(s2): add方法会调用s2的hashCode方法，计算字符串”abc”的哈希值为96354，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较s2.equals(s1),返回true。两个元素的哈希值相同，而且equals方法返回true，可以认定两个元素相同。就不会把s2存储到集合中。 set.add(&quot;通话&quot;)： add方法会调用hashCode方法，计算字符串“重地”的哈希值为1179395，在集合中没有找到相同哈希值的元素，就会将这个元素添加到集合中 set.add(&quot;重地&quot;): add方法会调用 “通话” 的hashCode方法，计算字符串”abc”的哈希值为1179395，在集合中查到相同哈希值的元素，出现了哈希冲突，然后s2会调用equals方法和哈希值相同的元素进行比较&quot;通话&quot;.equals(&quot;重地&quot;),返回false。两个元素的哈希值相同，equals方法返回false，可以认定两个元素不相同。就会把s2存储到集合中。 1.2.2 LinkedHashSet​ LinkedHashSet是HashSet的一个子类，不过他与HashSet不同的是，LinkedHashSet底层多了一个链表，这样能够保证LinkedHashSet的元素是有序的 1.2.3 TreeSet​ TreeSet是SortedSet接口的实现类,正如名字所示TreeSet可以确保集合元素处于排序状态。和HashSet相比,还额外提供了如下方法： 12345678Comparator comparator():如果TreeSet采用了定制排序，那么该方法会返回定制排序所使用的Comoparator，如果采用的是自然排序就返回nullObject first():返回集合中的第一个元素Object last():返回集合中的最后一个元素Object lower(Object e):返回集合中位于指定元素之前的元素Object higher(Object e):返回集合中位于指定元素之后的元素SortedSet subSet(Object fromElement,Object toElement):返回此Set的子集合，包左不包右SortedSet headSet(Object toElement):返回此Set子集，由小于toElement的元素组成SortedSet tailSet(Object fromElement):返回此Set子集，由大于等于toElement的元素组成 ​ TreeSet支持的的排序分为两种：自然排序（默认情况）/定制排序 自然排序：​ TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小，然后将集合元素按照升序排列，这种方式就是自然排序。 ​ 如果试图想TreeSet集合添加一个对象，在自然排序条件下该对象所属的类必须实现Comparable接口，否则程序会出现运行时期异常：ClassCastException。并且由于大部分类在实现compareTo(Object obj)方法的时候，都需要将被比较对象obj抢之类型转换成相同类型（因为只有相同类的两个实例才会比较大小），这也就要求了TreeSet集合里面的对象都属于一个类。 实现了Comparable接口的常用类： 1BigDecimal、BigInteger / Character / Boolean / String /Date、Time ​ 注意： 和HashSet判断对象是否相同不一样的是TreeSet判断两个对象是否相同的唯一标准就是通过调用该对象的compareTo(Object obj)方法和容器中的其他对象比较大小，如果返回值是 0 ，那么TreeSet就会认为他们相等，否则就认为他们不相等。 HashSet根据哈希值来找到元素在集合中的存储位置，TreeSet则是根据红黑树的结构来确定元素在集合中的位置。虽然往TreeSet集合中添加自定义对象的时候可以添加多种类型的对象（自定义类必须实现Comparable接口并且实现compareTo方法没有进行强制类型转换），但是当试图取出集合元素的时候，不同类型的元素依然会发生ClassCastExcepion异常。所以！如果希望TreeSet能够正常运行，TreeSet只能添加同一种类型的对象。 当需要把一个对象放入TreeSet集合中的时候，重写该对象对应类的equals方法时候应该保证该方法与compareTo(Object obj)有一样的结果。规则如下：如果两个对象通过equals方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较应该返回 0 。因为如果compareTo(Object obj)返回0，TreeSet就不会让元素进入集合内（因为compareTo(Object obj)的返回结果是作为TreeSet元素是否相等的唯一标准），但是equals方法返回false时候代表两个元素不相等，结果TreeSet和Set规则冲突。 #####定制排序： ​ TreeSet的自然排序是根据集合元素的大小进行升序排序。如果需要实现定制排序（比如降序排序），则需要在创建TreeSet的时候传入Comparator对象。这个接口里面包含了一个int compare(T t1,T t2)方法。根据返回值和0的关系来判断大小。 1.2.4 EnumSet​ EnumSet是一个专门为枚举设计的类，其中的元素必须是指定枚举类型的枚举值。该枚举类型在创建EnumSet的时候现实或者隐含的指定。也是有序的，不允许空值，否则会抛出NullPointerException异常。 ​ EnumSet没有暴露任何构造器来创建该类的实例，也就是说无法像其他集合一样new一个对象出来。但是它提供了如下方法来创建EnumSet对象： 1234567EnumSet allOf(Class elementType):创建一个包含指定枚举类里面所有枚举值的EnumSet集合EnumSet copyOf(Collection c):使用普通集合来创建EnumSet集合EnumSet copyOf(EnumSet e)EnumSet noneOf(Class elementType):使用指定元素类型来新建一个空的EnumSet集合EnumSet of(E first，E...rest):创建一个包含一个或多个枚举值得EnumSet集合。传入的枚举值必须属于同一个值EnumSet range(E from,E to):创建一个包含从from枚举值到to枚举值范围内所有枚举值的EnumSet集合EnumSet complementOf(EnumSet s):创建一个其元素类型与指定EnumSet里元素类型相同的集合，新的集合包含原来那个集合不包含的，此枚举类剩下的枚举值 1.2.5 各个Set实现类的性能分析HashSet和TreeSet是Set的两个典型实现。那么在应用中应该如何选择呢？ 123456* 记住一句话：只有需要一个保持排序的Set集合的时候再选择T`reeSet`,否则就选择`HashSet`。此外HashSet有一个子类：`LinkedHashSet`,对于普通的插入删除操作，性能要比HashSet稍微差一些，因为维护链表会造成额外的开销，但是由于有了链表的存在，使得`LinkedHashSet`在遍历方面会更快。* `EnumSet`是所有Set实现类中性能最好的，但是它只能保存同一个枚举类的枚举值作为集合元素。* `HashSet` `TreeSet` `EnumSet` 都是**线程不安全的**，如果有多个线程同时访问Set集合并且超过一个线程对Set集合进行了修改，那么必须使用`Collections`工具类的`synchronizedSortedSet`方法来包装Set集合,代码如下： SortedSet s=Collections.synchronizedSortedSet(new TreeSet(...)); 1.3 List（线性表接口）​ List作为Collection接口的子接口，元素有序，可重复，能够使用collection里面所有的方法。而且因为List是有序的，因此List里面还有针对于索引进行操作的方法。 12345678void add(int index,Object element):将元素插入到指定的索引位置boolean addAll(int index,Collection c):将集合c中的所有元素插入到List集合的index索引位置Object get(int index):返回集合index索引位置处的元素int indexOf(Object o):返回对象在List集合中第一次出现的位置int LastIndexOf(Object o):返回对象在List集合中最后一次出现的位置Object remove(int index):删除并返回指定位置的元素Object set(int index,Object element):将index索引处的元素设置成element，同时返回被替换的对象List subList(int fromIndex,int toIndex):返回指定范围的集合，包左 不包 ​ 所有的List实现类都可以使用以上方法。 1.3.1 ArrayList / Vector​ ArrayList和vector是List的典型实现，完全支持List接口的全部功能。 ​ ArrayList和Vector都是基于数组实现的List类，他们封装了一个动态的、允许被再次分配的Object数组。可以使用initialCapacity来设置该数组的长度，当添加的元素超过数组的长度之后，这个initialCapacity会自动增加。不过在实际开发中，可以使用ensureCapacity(int minCapacity)方法一次性的增加initialCapacity.如果在创建对象的时候不指定初始化长度，那默认长度就是 10。 ​ 重新分配Object数组的两个方法： 12void ensureCapacity(int minCapacity)：将ArrayList或Vector数组增加至大于或等于minCapacity值void trimToSize():调整ArrayList或Vector数组长度为当前元素个数 ​ ArrayList和Vector的一个显著区别就是：ArrayList是线程不安全的，当多个线程访问同一个ArrayList集合并且有超过一个线程修改了ArrayList集合，那么程序必须手动保证该集合的同步性。Vector是线程安全的，无需保证集合的同步性，但也就是因为这样使得Vector的性能要比ArrayList性能要低。 ​ 总结：推荐选择ArrayList集合使用，线程安全的问题使用Collections工具类来保证。 1.3.2 Stack​ Stack是Vector的一个子类，名为“栈”，特点是“先进后出”、线程安全但是性能较差。 ​ Stack里面有如下几个方法： 123Object peek():返回栈的第一个元素，但是不出栈Object pop():返回栈的第一个元素，出栈void push():向栈中压入元素 ​ 由于Stack是Vector的子类，同样建议少用Stack,如果需要使用“栈”这种数据结构的话，可以考虑ArrayDequeue(之后介绍) 1.3.3 固定长度的ArrayList​ 在介绍数组的时候提到过一个操作数组的工具类：Arrays ，这个类中提供了asList(Object...a)方法，这个方法可以将数组或者指定个数的对象转换成一个List集合，这个集合就不再是ArrayList或者Vector实现类的实例了，而是Arrays的内部类ArrayList的实例。 ​ Arrays.ArrayList是一个固定长度的List集合，程序只能对其进行遍历访问，而不能进行任何改变集合的操作。 1.3.4 LinkedList​ LinedList是List的一个实现类，说明他是一个List集合，可以根据索引来随机访问元素值。同时也实现了Deque接口,因此也可以被当做双端队列来使用，同时还能被当成“栈”来使用。 来通过一些代码示范LinkedList作为 List集合、双端队列、栈的用法 123456789101112131415161718192021222324252627LinkedList books=new LinkedList();//将元素加入“队列”尾部 books.offer(\"123\");//将元素加入“栈”的顶部books.push(\"456\");//将元素加入“队列”的头部，相当于“栈”的顶部books.offerFirst(\"789\");//输出集合System.out.println(books);System.out.println(\"=====================\");//遍历“集合”元素for (int i = 0; i &lt; books.size(); i++) &#123; System.out.println(books.get(i));&#125;System.out.println(\"=====================\");System.out.println(books.peekFirst());//访问栈顶元素System.out.println(books.peekLast());//访问栈底元素System.out.println(books.pop());//弹出栈顶元素System.out.println(books);System.out.println(\"=====================\");System.out.println(books.pollLast());//删除队列最后一个元素 输出结果如下： 123456789101112[789, 456, 123]=====================789456123=====================789123789[456, 123]=====================123 1.3.5 各种线性表性能分析​ 一般来说，由于数组以一块连续内存区域来保存所有的数组元素，因此数组在随机访问时候性能最好，所以所有内部以数组作为底层实现的集合在随机访问的时候性能都很好；而内部用链表作为底层实现的集合在进行插入、删除操作的时候性能比较好。总体来说ArrayList的性能要比LinkedList的性能要好,因此大多数情况下建议使用ArrayList ​ 使用List集合的建议： 如果需要遍历集合元素，对于ArrayList / Vector,应该使用随机访问方法get()来遍历集合元素，这样性能更好；对于LinkedList应该使用迭代器（Iteator）来遍历集合。 如果需要经常执行插入、删除操作对集合进行改变，可以考虑使用LinkedList集合，因为使用ArrayList / Vector的话可能需要经常重新分配底层的数组大小，性能会受到影响。 如果有多个线程访问同一个List集合，应该考虑利用Collections将集合包装成线程安全的集合。 1.4 Queue(队列)Queue用来模拟队列这种数据结构。 在Queue接口中定义了如下方法： 123456void add(Object o):将元素添加到队列尾部void offer(Object o):将元素加入队列的尾部，在队列容量有限的时候，这种方法更好。Object element():获取队列头部元素，但是不删除Object remove():获取队列头部元素并删除Object peek():获取队列头部元素，不删除，如果队列为空，返回 nullObject poll():获取队列头部元素，删除。队列为空的话返回null 1.4.1 Deque(上图名称错误)​ Deque是Queue接口的子接口，代表一个双端队列，Deque接口里面定义了一些操作双端队列的方法。多数方法只需要在Queue接口提供的方法后加上First / Last即可。这里只介绍一些额外的方法： 12Iterator descendingIterator():返回该双端队列对应的迭代器，该迭代器将以逆向顺序来迭代队列中的元素。（反向迭代器）和常用迭代器迭代的结果是相反的。Object removeFirst/LastOccurrence(Object o):删除双端队列第一次/最后一次出现的元素 ​ Queue方法和Deque方法以及Stack比较 Queue的方法 Deque的方法 Stack add(e) / offer(e) addLast(e) / offerLast(e) push(e) remove() / poll() removeFirst() / pollFirst() pop element() / peek() getFirst() / peekFirst() peek 1.4.2 ArrayQueue​ ArrayQueue是Deque的一个典型实现类。这是一个基于数组的双端队列。创建Deque的时候同样可以指定一个numElements参数,用于指定底层的Object[] 数组的长度，不指定的话就是默认长度：16。和ArrayList两个集合类的实现机制基本相似，当集合元素超过数组长度的时候，系统会自动在底层重新分配一个数组。 ​ 前面说到了当程序中需要使用栈这种数据结构的时候应该尽量避免使用Stack,因为性能较差。在这里推荐使用ArrayQueue。 ​ ArrayQueue既可以当做队列使用，也可以当做栈使用。","categories":[],"tags":[],"keywords":[]},{"title":"集合知识浅析（一）","slug":"集合知识浅析（一）","date":"2019-05-30T09:17:17.601Z","updated":"2019-06-01T07:12:12.892Z","comments":true,"path":"2019/05/30/集合知识浅析（一）/","link":"","permalink":"http://yoursite.com/2019/05/30/集合知识浅析（一）/","excerpt":"","text":"集合知识浅析（一）1.1集合概述 Java是面向对象的语言，面向对象语言对事物的描述是通过对象体现的，为了方便对多个对象 进行操作，就必须把这个对象进行存储，但是想要存储多个对象，就不能是一个基本数据类型 而应该是一个容器类型。 为什么不选择数组或者字符缓冲区来存储多个对象呢？ ​ 数组和StringBuffer就是容器，但是StringBuffer的结果是一个字符串，不一定能够满足要求。 因此只能选择数组作为容器，即对象数组，但是对象数组无法适应变化的需求，因为数组长度固定。因此Java提供了相应的集合类用来使用 数组和集合的区别: 1）数组长度固定，集合长度可变； 2）数组用来存储同一类型数据，集合可以存储不同类型 3）数组可以用来存储基本数据类型，也可以用来存储引用类型集合只能存 储引用类型 集合可以存储多个元素的，但是，存储多个元素也是有不同需求的，比如说，多个元素中不能有相同 元素，针对不同的需求，Java提供了不同的集合类，多个集合类的数据结构不同，但是绝对有共性。通过不断提取共性，就可以得到所有集合类的一个总集合：Collection 数据结构:数据的存储方式 1.2继承关系Java的集合类主要由Collection和Map两个接口派生出来。也即： Map的继承关系： Collection的继承关系：","categories":[],"tags":[],"keywords":[]},{"title":"泛型浅析","slug":"泛型浅析","date":"2019-05-30T02:37:42.560Z","updated":"2019-06-01T07:11:58.792Z","comments":true,"path":"2019/05/30/泛型浅析/","link":"","permalink":"http://yoursite.com/2019/05/30/泛型浅析/","excerpt":"","text":"泛型首先来看一下什么叫做泛型​ 泛型是一种把类型明确的工作推迟到创建对象或者调用方法的时候才去明确的特殊类型。也叫做参数化类型，把类型当作参数一样传递。 ​ 其实说白了，可以将泛型看成对集合里面元素的一种限制手段 ​ 简而言之就是使用集合那种结构的时候会出现黄色警告线，但是往往我们会忽略这样的警告，进而导致类型不匹配等不可预知的错误。但是采用泛型的话会在创建对象或者调用方法的时候如果出现参数类型不匹配的结果会直接报错，而不是仅仅给出警告。 格式： 12&lt;数据类型&gt; 此处的数据类型只能是引用类型。 使用位置： 1看API文档，如果类，接口，抽象类后面跟有&lt;E&gt;就说明要使用泛型。一般来说就是在集合中使用(如果集合不使用泛型的话，默认就是Object类型，可以存储任意类型的数据。 泛型应用： 泛型类： 把泛型定义在类上 格式：public class 类名&lt;泛型类型1....&gt; 注意：泛型类型必须是引用类型 举例： public class Test&lt;E&gt;{ private E name; public void setName(E name){ this.name=name; } } 泛型方法： 把泛型定义在方法上 格式：public &lt;泛型类型&gt; 返回类型 方法名(泛型类型) 举例： public &lt;E&gt; void method(E e){ ... } 泛型接口： 把泛型定义在接口上 格式：public interface 接口名&lt;泛型类型1....&gt; 举例： public interface myInterface&lt;E&gt;{} 注意：泛型是没有继承概念的 泛型通配符​ 当使用泛型类或者接口的时候，在传递的数据中如果泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符之后，只能使用Object类中的共性方法，集合中元素自身的方法无法使用。不能创建对象使用，只能作为方法的参数使用 高级使用 —-受限泛型​ 设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以设置一个上限或者下限。 ###### 泛型的上限： ​ 格式：类型名称&lt;? extends 类&gt; 对象名称 ​ 意义：之能接受该类型以及其子类 ​ 举例：public static void getElement(Collection&lt;? extends XXX&gt; coll){} 反省的下限​ 格式：类型名称&lt;? super 类&gt; 对象名称 ​ 意义：之能接受该类型以及其父类 ​ 举例：public static void getElement(Collection&lt;? super XXX&gt; coll){}","categories":[],"tags":[],"keywords":[]},{"title":"String , String Builder , String Buffer的区别浅析","slug":"String , String Builder , String Buffer的区别","date":"2019-05-29T13:14:53.886Z","updated":"2019-05-29T13:55:03.993Z","comments":true,"path":"2019/05/29/String , String Builder , String Buffer的区别/","link":"","permalink":"http://yoursite.com/2019/05/29/String , String Builder , String Buffer的区别/","excerpt":"","text":"String , String Builder , String Buffer的区别首先来看这三个类分别代表什么什么意思​ String类代表字符串 ，但是它是代表一个常量，底层是一个被final修饰的数组，它的值在创建之后不能够被更改。 ​ StringBuilder（字符串缓冲区）与StringBuffer（字符串缓冲区）虽然也是代表字符串并且底层也是数组，但是这个数组没有被final修饰，他们都是可变量，他们在创建对象实例并且赋值之后可以重新更改值得内容。 ​ 这三者的区别主要存在与两点：运行速度和线程安全 运行速度:​ 三者的运行速度大小如下：StringBuilder &gt; StringBuffer &gt; String ​ 原因： ​ 先来看一段代码: 123456String s=&quot;Hello&quot;;System.out.println(s);//HelloSystem.out.println(s.getBytes());//[B@3f99bd52s=s+&quot;World&quot;；System.out.println(s);//HelloWorldSystem.out.println(s.getBytes());//[B@119d7047 ​ 上述代码输出的结果是Hello [B@3f99bd52 和HelloWorld [B@119d7047,这段代码在虚拟机上的执行过程实际是这样的：首先，在创建了一个对象s之后，将Hello赋值给了s，然后又创建了一个同名对象s，并且将之前的s对象的值和World进行拼接之后赋值给了这个新的s。那么第一次创建的对象s去哪了呢？答案是被虚拟机的垃圾回收机制回收掉了（连同对象s 的值）。因此，在对String类型的对象进行操作的时候实际上就是一个不断创建同名新对象的删除旧对象的一个过程，这期间需要不断的消耗虚拟机的资源，因此执行速度很慢。 ​ 但是StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。 线程安全:​ StringBuilder是线程不安全的，StringBuffer是线程安全的 总结： String：适用于少量的字符串操作的情况 String Builder：适用于单线程下在字符缓冲区进行大量操作的情况 String Buffer：适用多线程下在字符缓冲区进行大量操作的情况 StringBuilder/StringBuilder - - &gt; String ​ 可以使用StringBuilder的构造方法：StringBuilder(String str) String - - &gt;StringBuilder/StringBuilder ​ 可以使用StringBuilder的toString方法 String常用构造方法： 123456public String()：空构造public String(byte[] bytes)：把字节数组转换成字符串public String(byte[] bytes,int offset,int length)：把字节数组一部分转换成字符串public String(char[] value)：把字节数组转换成字符串public String(byte[] bytes,int offset,int count)：把字符数组一部分转换成字符串public String(String original)：把字符串常量值转成字符串,换句话说新创建的字符串是参数字符串的副本。 常用函数： 123456789101112131415161718192021222324252627282930313233343536String类的获取功能 int length();获取长度 char charAt(int index);返回指定索引位置的字符 int indexOf(int ch);返回指定字符在此字符串第一次出现的索引 int indexOf(String_01 str);返回指定字符串（首字母）在此字符串第一次出现的索引 int indexOf(int ch,int fromIndex);返回指定字符在此字符串从指定位置之后第一次出现的索引 String substring(int start);截取字符串，默认到末尾。返回被截取的子串。 String substring(int start,int end); String类的转换功能 byte[] getBytes();把字符串转换成字节数组 char[] toCharArray();把字符串转换成字符数组 static String valueOf(char[] chs);把字符数组转换成字串，其他类型数组用不了此方法 static String valueOf(int i);把某种类型数据转换成字符串(四类八种除了byte/short,外加) String类的valueOf方法可以把任意类型的数据转换成字符串 toCharArray():可以将字符串转化成数组 String toLoweCase(); String toUpperCase(); String concat(String str):进行字符串的拼接 toCharArray(): 将此字符串转换为新的字符数组。 String类的其他功能 替换功能 String replace(char old,char new); String replace(String old,String new); String replaceFirst(String regex, String replacement)用给定的序列替换调用者的第一个子 字符串 去除字符串两端空格 String trim(); 按照字典顺序比较字符串 int compareTo(String str); int compareToIgnoreCse(String str); 判断功能： boolean startsWith(String prefix) 测试此字符串是否以指定的前缀开头。 boolean startsWith(String prefix, int toffset) 测试在指定索引处开始的此字符串的子字符串 是否以指定的前缀开头。 拆封功能 String[] split(String regex)：根据给定的表达式拆分此字符串 注意：1.String s=new String(&quot;hello&quot;);String s=&quot;hello&quot;区别： ​ 前者创建两个对象（常量池中没有这个hello对象的时候）或一个对象（常量池中有这个hello对象的时候），后者创建一个对象（常量池中没有这个hello对象的时候）或不创建对象（常量池中有这个hello对象的时候） 2.字符串如果是变量相加，先开空间，在拼接。 12String s1=&quot;Hello&quot;,s2=&quot;World&quot;;s1+s2 3.字符串如果是常量相加，是先加，然后在常量池找，如果有就直接返回，否则，就创建。 1&quot;Hello&quot;+&quot;World&quot; String Builder和String Buffer常用构造方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 1234StringBuilder() 构造一个没有字符的字符串构建器，初始容量为16个字符。 StringBuilder(int capacity) 构造一个没有字符的字符串构建器，以及由 capacity参数指定的初始容量。 StringBuilder(CharSequence seq) 构造一个字符串构建器，其中包含与指定的 CharSequence相同的字符。 StringBuilder(String str) 构造一个初始化为指定字符串内容的字符串构建器。 常用方法(String Builder为例，String Buffer大致看了一眼，和String Builder几乎一摸一样)： 123456789101112131415StringBuilder append(参数) 将指定参数的字符串表示附加到序列中。除了byte/short StringBuilder append(char[] str) 将 char数组参数的字符串表示追加到此序列。 StringBuilder append(char[] str, int offset, int len) 将 char数组参数的子阵列的字符串表示追加到此序列。 StringBuilder append(String str) 将指定的字符串附加到此字符序列。 StringBuilder append(StringBuffer sb) 追加指定的 StringBuffer到这个序列。 int capacity() 返回当前容量。 char charAt(int index) 返回指定索引位置的值void setCharAt(int index, char ch) 设置指定位置的值为ch StringBuilder reverse() 导致该字符序列被序列的相反代替。StringBuilder replace(int start, int end, String str) 用指定的 String的字符替换此序列的子字符串中的字符 int indexOf(String str) 返回指定子字符串第一次出现的字符串内的索引。 int indexOf(String str, int fromIndex) 返回指定子串的第一次出现的字符串中的索引，从指定的索引开始。 int lastIndexOf(String str) 返回指定子字符串最后一次出现的字符串中的索引。 int lastIndexOf(String str, int fromIndex) 返回指定子字符串的最后一次出现的字符串中的索引，从指定索引开始向后搜索。 String toString() 返回表示此顺序中的数据的字符串。","categories":[],"tags":[],"keywords":[]},{"title":"接口的知识浅析","slug":"接口的知识浅析","date":"2019-05-26T15:58:29.816Z","updated":"2019-05-28T16:11:42.154Z","comments":true,"path":"2019/05/26/接口的知识浅析/","link":"","permalink":"http://yoursite.com/2019/05/26/接口的知识浅析/","excerpt":"","text":"接口什么是接口？​ 接口是多个类的一种公共规范，它是一种引用数据类型。接口中最重要的内容是接口中的抽象方法。 接口如何定义？格式：​ 1public interface 接口名称&#123;...&#125; 如何使用接口呢？1.接口不能直接使用，必须有一个“实现类”来实现接口格式： 1public class 实现类名称 implements 接口名称1,接口名称2...&#123;...&#125; 2.接口的实现类必须重写接口中的所有抽象方法3.创建实现类的对象，进行使用如果是Java 7,那么接口中可以包含的内容有：常量/抽象方法 如果是Java 8,还可以额外包含：默认方法/静态方法 如果是Java 9,还可以额外包含：私有方法 接口中的抽象方法（最重要的）格式： 1public abstract 返回值类型 方法名称(参数列表) 注意： ​ public abstract这两个关键字修饰符是固定格式，但是可以选择性的省略 接口中的default（默认）方法格式： 1public default 返回值类型 方法名称(参数列表)&#123;...&#125; 这个默认方法有什么用？​ 作用：默认方法会被实现类自动继承，因此可以用于接口升级。 什么叫做接口升级？​ 比如有一个接口A，并且B,C实现该接口，但是如果接口A中进行了抽象方法的修改，那么相应的就要去修改B,C 但是现实开发中这种并无法理想实现（比如实现了A接口的某个方法已经投入了大规模使用），因此这个时候进行接口的升级操作就需要用到这个默认的方法。 ​ 高级吗？一点都不高级。就是只需要把需要接口中新增的方法声明称默认方法就可以了。😂 接口中的静态方法（Java 8开始）格式： 1public static 返回值类型 方法名称(参数列表)&#123;...&#125; 接口中静态方法的使用​ 通过接口名称直接调用： 1接口名称.静态方法名(参数) ​ 注意： ​ 不能通过接口实现类的对象去调用接口中的静态方法 ​ 例如： 1234567891011121314public interface A&#123; public static void test()&#123; System.out.println(&quot;你好&quot;); &#125;&#125;public class B extends A&#123; public static void main(String[] args)&#123; A.test();//正确 new B().test();//错误 &#125;&#125; 接口中的私有方法（Java 9开始）1.普通私有方法​ 作用：解决多个默认方法之间重复代码问题 ​ 格式： 1private 返回值类型 方法名称(参数列表)&#123;...&#125; 2.静态私有方法​ 作用：解决多个静态方法之间重复代码问题 ​ 格式： 1private static 返回值类型 方法名称(参数列表)&#123;...&#125; 私有方法有啥用啊？来看一段代码(以普通私有方法为例)： 12345public interface A&#123; public default void methodDefault1&#123;...&#125; public default void methodDefault2&#123;...&#125;&#125; 假设methodDefault1方法和methodDefault2方法中有大量重复的代码的话,可以将这部分重复代码抽离出来形成一个新的方法。但是！抽离出来的这部分方法应当只能由methodDefault1和methodDefault2来使用，而不能由实现类来使用 将公共代码抽离出来，这样一来，便无法在实现类中访问到methodCommon(),如下： 12345678910111213public interface A&#123; public default void methodDefault1&#123; ... methodCommon(); &#125; public default void methodDefault2&#123; ... methodCommon(); &#125; private void methodCommon()&#123; 公共方法 &#125;&#125; 接口中的常量​ 接口中也可以定义”成员变量”，但是必修使用 public static final 三个关键字修饰。从效果上看，相当于接口的常量。这三个关键之可以省略，但是即使省略之后，也默认还是这三个修饰。而且必须赋值。 格式： 1public static final 数据类型 常量名称 = 数据值 如何访问呢？ ​ 这样理解：修饰符里面由static关键字，那么自然只能通过接口名进行访问：接口名.常量名 接口使用注意事项​ 1.接口内没有静态代码块或者构造方法（有了构造方法就可以直接new了） ​ 2.如果实现类所实现的多个接口中，存在重复的抽象方法，那么只需要重写一次就行，而且必须重写。 ​ 3.如果实现类没有完全重写接口的抽象方法，那么实现类同样是一个抽象类 ​ 4.接口与接口之间是多继承的（类和类之间单继承，类和接口之间多实现） ​ 5.多个父接口当中的抽象方法重复没事，但是默认方法重复的话，那么子接口必须进行默认方法的重写并且要带有default关键字","categories":[],"tags":[],"keywords":[]}]}